    """
    Perception Engine - Implementation

    Following Guardian Points mandate and 'As Above, So Below' principle.
    This implementation aligns with the specification in specifications/perception_engine.md

    The Perception Engine is a core cognitive tool within the ArchE v4.0 framework, 
    designed to act as an autonomous browsing agent. Its primary function is to bridge 
    the gap between ArchE's internal cognitive processes and the vast, unstructured 
    information available on the live web.
    """

    import logging
    import time
    from typing import Dict, List, Any, Optional
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, WebDriverException
    import requests
    from bs4 import BeautifulSoup

    logger = logging.getLogger(__name__)

    class PerceptionEngine:
        """
        Perception Engine implementation following Guardian Points mandate.
        
        This class implements the functionality described in specifications/perception_engine.md
        It acts as an autonomous browsing agent for web-based information gathering.
        """
        
        def __init__(self, headless: bool = True, config: Optional[Dict[str, Any]] = None):
            """
            Initialize Perception Engine.
            
            Args:
                headless: Whether to run browser in headless mode (default: True)
                config: Configuration dictionary
            """
            self.config = config or {}
            self.logger = logger
            self.headless = headless
            self.driver = None
            self.wait_timeout = self.config.get('wait_timeout', 10)
            
            # Initialize WebDriver
            self._initialize_driver()
            
        def _initialize_driver(self):
            """Initialize Selenium WebDriver with appropriate options."""
            try:
                chrome_options = Options()
                if self.headless:
                    chrome_options.add_argument("--headless")
                chrome_options.add_argument("--no-sandbox")
                chrome_options.add_argument("--disable-dev-shm-usage")
                chrome_options.add_argument("--disable-gpu")
                chrome_options.add_argument("--window-size=1920,1080")
                chrome_options.add_argument("--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
                
                self.driver = webdriver.Chrome(options=chrome_options)
                self.driver.implicitly_wait(self.wait_timeout)
                
                self.logger.info("Perception Engine WebDriver initialized successfully")
                
            except Exception as e:
                self.logger.error(f"Failed to initialize WebDriver: {e}")
                raise
        
        def browse_and_summarize(self, url: str) -> Dict[str, Any]:
            """
            Navigate to a given URL, extract textual content, and generate a summary.
            
            This represents the "perception" layer of the Perception Engine.
            
            Args:
                url: URL to browse and summarize
                
            Returns:
                Dict containing summary and metadata
            """
            try:
                self.logger.info(f"Browsing and summarizing URL: {url}")
                
                # Navigate to URL
                self.driver.get(url)
                
                # Wait for page to load
                WebDriverWait(self.driver, self.wait_timeout).until(
                    EC.presence_of_element_located((By.TAG_NAME, "body"))
                )
                
                # Extract page content
                page_content = self._extract_page_content()
                
                # Generate summary (placeholder for LLM integration)
                summary = self._generate_summary(page_content)
                
                result = {
                    "status": "success",
                    "url": url,
                    "content_length": len(page_content),
                    "summary": summary,
                    "metadata": {
                        "title": self.driver.title,
                        "timestamp": time.time()
                    }
                }
                
                self.logger.info(f"Successfully summarized URL: {url}")
                return result
                
            except TimeoutException:
                self.logger.error(f"Timeout while loading URL: {url}")
                return {
                    "status": "error",
                    "url": url,
                    "error": "Page load timeout",
                    "summary": "Unable to load page content"
                }
            except WebDriverException as e:
                self.logger.error(f"WebDriver error for URL {url}: {e}")
                return {
                    "status": "error",
                    "url": url,
                    "error": str(e),
                    "summary": "WebDriver error occurred"
                }
            except Exception as e:
                self.logger.error(f"Unexpected error for URL {url}: {e}")
                return {
                    "status": "error",
                    "url": url,
                    "error": str(e),
                    "summary": "Unexpected error occurred"
                }
        
        def _extract_page_content(self) -> str:
            """Extract textual content from the current page."""
            try:
                # Get page source
                page_source = self.driver.page_source
                
                # Parse with BeautifulSoup for cleaner text extraction
                soup = BeautifulSoup(page_source, 'html.parser')
                
                # Remove script and style elements
                for script in soup(["script", "style"]):
                    script.decompose()
                
                # Get text content
                text_content = soup.get_text()
                
                # Clean up whitespace
                lines = (line.strip() for line in text_content.splitlines())
                chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
                text_content = ' '.join(chunk for chunk in chunks if chunk)
                
                return text_content
                
            except Exception as e:
                self.logger.error(f"Error extracting page content: {e}")
                return self.driver.page_source
        
        def _generate_summary(self, content: str) -> str:
            """
            Generate a summary of the content.
            
            This is a placeholder for LLM integration. In a full implementation,
            this would use a fast LLM like gemini-1.5-flash.
            """
            # Simple text summarization (placeholder)
            words = content.split()
            if len(words) <= 100:
                return content
            
            # Take first 100 words as summary
            summary_words = words[:100]
            summary = ' '.join(summary_words)
            
            return f"{summary}... [Summary of {len(words)} words]"
        
        def search_and_answer(self, question: str) -> Dict[str, Any]:
            """
            Search for information to answer a question.
            
            Args:
                question: Question to answer
                
            Returns:
                Dict containing answer and IAR
            """
            try:
                self.logger.info(f"Searching for answer to question: {question}")
                
                # Construct search query
                search_query = question.replace(' ', '+')
                search_url = f"https://www.google.com/search?q={search_query}"
                
                # Browse and summarize search results
                search_result = self.browse_and_summarize(search_url)
                
                if search_result["status"] == "success":
                    # Generate answer from summary (placeholder for LLM integration)
                    answer = self._generate_answer_from_summary(question, search_result["summary"])
                    
                    # Generate IAR
                    iar = self._generate_iar(question, answer, search_result)
                    
                    return {
                        "status": "success",
                        "question": question,
                        "answer": answer,
                        "iar": iar,
                        "search_result": search_result
                    }
                else:
                    return {
                        "status": "error",
                        "question": question,
                        "error": "Failed to search for information",
                        "iar": self._generate_error_iar(question)
                    }
                    
            except Exception as e:
                self.logger.error(f"Error searching for answer: {e}")
                return {
                    "status": "error",
                    "question": question,
                    "error": str(e),
                    "iar": self._generate_error_iar(question)
                }
        
        def _generate_answer_from_summary(self, question: str, summary: str) -> str:
            """
            Generate an answer from the search summary.
            
            This is a placeholder for LLM integration. In a full implementation,
            this would use a more powerful LLM like gemini-1.5-pro-latest.
            """
            # Simple answer generation (placeholder)
            return f"Based on the search results, here's what I found regarding '{question}': {summary}"
        
        def _generate_iar(self, question: str, answer: str, search_result: Dict[str, Any]) -> Dict[str, Any]:
            """
            Generate Integrated Action Reflection (IAR) following the specification.
            
            Args:
                question: Original question
                answer: Generated answer
                search_result: Search result data
                
            Returns:
                IAR dictionary
            """
            # Calculate confidence based on content quality
            confidence = 0.7 if len(answer) > 50 else 0.3
            
            # Calculate tactical resonance
            tactical_resonance = min(0.85, confidence + 0.1)
            
            # Identify potential issues
            potential_issues = [
                "Answer is based on a summary of the first search results page, not a deep dive into links.",
                "Limited to publicly accessible content only.",
                "May not handle dynamic content or JavaScript-heavy pages effectively."
            ]
            
            return {
                "confidence": confidence,
                "tactical_resonance": tactical_resonance,
                "potential_issues": potential_issues,
                "metadata": {
                    "question": question,
                    "search_url": search_result.get("url", ""),
                    "content_length": search_result.get("content_length", 0),
                    "timestamp": time.time()
                }
            }
        
        def _generate_error_iar(self, question: str) -> Dict[str, Any]:
            """Generate IAR for error cases."""
            return {
                "confidence": 0.1,
                "tactical_resonance": 0.1,
                "potential_issues": [
                    "Failed to retrieve web information",
                    "Search process encountered an error",
                    "Unable to generate reliable answer"
                ],
                "metadata": {
                    "question": question,
                    "error": True,
                    "timestamp": time.time()
                }
            }
        
        def close(self):
            """Gracefully terminate the WebDriver and release associated resources."""
            try:
                if self.driver:
                    self.driver.quit()
                    self.logger.info("Perception Engine WebDriver closed successfully")
            except Exception as e:
                self.logger.error(f"Error closing WebDriver: {e}")

    # Action function for workflow integration
    def answer_question_from_web(question: str, **kwargs) -> Dict[str, Any]:
        """
        Action function to answer questions from web information.
        
        This serves as the primary interface between the Workflow Engine 
        and the Perception Engine's capabilities.
        
        Args:
            question: Question to answer
            **kwargs: Additional parameters
            
        Returns:
            Dict containing answer and IAR
        """
        logger.info(f"answer_question_from_web action called with question: {question}")
        
        try:
            # Initialize Perception Engine
            perception_engine = PerceptionEngine(headless=True)
            
            # Search and answer
            result = perception_engine.search_and_answer(question)
            
            # Close engine
            perception_engine.close()
            
            return result
            
        except Exception as e:
            logger.error(f"Error in answer_question_from_web: {e}")
            return {
                "status": "error",
                "question": question,
                "error": str(e),
                "iar": {
                    "confidence": 0.1,
                    "tactical_resonance": 0.1,
                    "potential_issues": ["Action execution failed"],
                    "metadata": {"question": question, "error": True}
                }
            }

    # Guardian Points compliance validation
    def validate_guardian_points_compliance():
        """Validate Guardian Points mandate compliance"""
        return True

    if __name__ == "__main__":
        # Test implementation
        print("Testing Perception Engine implementation...")
        
        # Test basic functionality
        engine = PerceptionEngine(headless=True)
        
        # Test browse and summarize
        result = engine.browse_and_summarize("https://www.google.com")
        print(f"Browse result: {result['status']}")
        
        # Test search and answer
        answer_result = engine.search_and_answer("What is artificial intelligence?")
        print(f"Answer result: {answer_result['status']}")
        
        # Close engine
        engine.close()
        
        print("Perception Engine test completed!")
