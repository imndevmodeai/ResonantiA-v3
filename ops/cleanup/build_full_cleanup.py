#!/usr/bin/env python3
"""
Build a single cleanup_FULL.md that contains:
  - Story docs (key narrative files)
  - All specification files (specifications/)
  - Core code (Three_PointO_ArchE/*.py) and key project scripts

Notes:
  - This script concatenates raw contents with clear section headers.
  - It preserves original file content verbatim inside fenced blocks.
  - Run from project root: python3 ops/cleanup/build_full_cleanup.py
"""
from __future__ import annotations

import os
from pathlib import Path
from typing import Iterable, List

PROJECT_ROOT = Path(__file__).resolve().parents[2]
OUTPUT = PROJECT_ROOT / "cleanup_FULL.md"

# Curated "story" sources (ordered)
STORY_SOURCES = [
    "00_START_HERE.md",
    "README_ZEPTO_SOLUTION.md",
    "ZEPTO_COMPLETE_SOLUTION.txt",
    "ZEPTO_ZERO_LOSS_ANALYSIS.md",
    "ZEPTO_EXECUTIVE_SUMMARY.md",
    "SOUL_OF_ABSTRACTION.md",
    "META_ABSTRACTION_THEORY.md",
    "UNIVERSAL_ABSTRACTION_SUMMARY.md",
    "UNIVERSAL_ABSTRACTION_COMPRESSION.md",
]

# Extra top-level narrative/philosophy if present
STORY_OPTIONAL = [
    "ARCHE_SEED_DEPLOYMENT_PHILOSOPHY.md",
    "LOSSLESS_VS_LOSSY_FRAMEWORK.md",
    "TEACHING_SYMBOLS_MODALITIES.md",
    "FRAMEWORK_SUMMARY.md",
]

# Code/script globs
CODE_DIRS = [
    "Three_PointO_ArchE",     # core
]
CODE_TOPLEVEL = [
    "compress_with_spr_context.py",
    "prime_arche_init.py",
    "ARCHE_KNOWLEDGE_SEED_GENERATOR.py",
    "RESONANTIA_KNOWLEDGE_SEED.py",
]

def find_existing(paths: Iterable[str]) -> List[Path]:
    out: List[Path] = []
    for p in paths:
        fp = PROJECT_ROOT / p
        if fp.exists():
            out.append(fp)
    return out

def write_header(f, title: str, level: int = 1):
    f.write(f"\n{'#' * level} {title}\n\n")

def emit_file(f, file_path: Path, language_hint: str = ""):
    rel = file_path.relative_to(PROJECT_ROOT)
    f.write(f"\n---\n\n")
    f.write(f"### {rel}\n\n")
    fence = "```" + language_hint if language_hint else "```"
    f.write(f"{fence}\n")
    try:
        text = file_path.read_text(encoding="utf-8", errors="replace")
    except Exception as e:
        text = f"[error] unable to read file: {e}"
    f.write(text)
    f.write("\n```\n")

def main() -> int:
    with OUTPUT.open("w", encoding="utf-8") as out:
        # Title
        write_header(out, "aRCHe Full Cleanup Bundle (Story + Specs + Code)", 1)
        out.write("This unified document aggregates the core narrative, full specifications, and the principal codebase for offline, portable review.\n")

        # Story
        write_header(out, "Story & Narrative", 2)
        story_files = find_existing(STORY_SOURCES) + find_existing(STORY_OPTIONAL)
        for sf in story_files:
            emit_file(out, sf, language_hint="md")

        # Specifications
        write_header(out, "Specifications", 2)
        specs_dir = PROJECT_ROOT / "specifications"
        if specs_dir.exists():
            for p in sorted(specs_dir.rglob("*")):
                if p.is_file():
                    # choose hint by extension
                    hint = "md" if p.suffix.lower() in [".md", ".txt"] else ""
                    emit_file(out, p, language_hint=hint)
        else:
            out.write("_No specifications/ directory found._\n")

        # Code
        write_header(out, "Codebase (Primary Modules & Scripts)", 2)
        # Top-level scripts
        for t in find_existing(CODE_TOPLEVEL):
            hint = "python" if t.suffix == ".py" else ""
            emit_file(out, t, language_hint=hint)
        # Code directories
        for d in CODE_DIRS:
            base = PROJECT_ROOT / d
            if not base.exists():
                continue
            for p in sorted(base.rglob("*.py")):
                emit_file(out, p, language_hint="python")

        # Footer
        write_header(out, "End of Bundle", 3)
        out.write("Generated by ops/cleanup/build_full_cleanup.py\n")

    print(f"Wrote: {OUTPUT}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())









































