[
  {
    "stage_name": "Narrative",
    "content": "TERM: Class: NexusInterface\n\nDEFINITION:\nCentral communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_interface.py, type: python_class\n\nFULL IMPLEMENTATION CODE (nexus_interface.py):\n```python\n\"\"\"\nNexusInterface: ArchE's Central Nervous System\n==============================================\n\nThe NexusInterface serves as ArchE's central communication bus, implementing\na publisher-subscriber pattern for asynchronous, decoupled communication\nbetween all system components.\n\nThis implementation provides:\n- Event publishing and subscription\n- Real-time message routing\n- ThoughtTrail integration\n- WebSocket support for external clients\n- Event filtering and routing\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport threading\nimport time\nfrom collections import defaultdict\nfrom datetime import datetime\n\n# ============================================================================\n# TEMPORAL CORE INTEGRATION (CANONICAL DATETIME SYSTEM)\n# ============================================================================\nfrom .temporal_core import now_iso, format_filename, format_log, Timer\nfrom typing import Dict, List, Any, Callable, Optional, Set\nimport websockets\nfrom websockets.server import WebSocketServerProtocol\n\nlogger = logging.getLogger(__name__)\n\nclass NexusInterface:\n    \"\"\"\n    Central communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n    \"\"\"\n    \n    def __init__(self, websocket_port: int = 8765):\n        \"\"\"\n        Initialize the NexusInterface.\n        \n        Args:\n            websocket_port: Port for WebSocket server\n        \"\"\"\n        self.subscribers = defaultdict(list)  # topic -> list of callbacks\n        self.event_history = []  # Store recent events for debugging\n        self.max_history = 1000\n        self.websocket_port = websocket_port\n        self.websocket_clients: Set[WebSocketServerProtocol] = set()\n        self._thoughttrail = None\n        self._running = False\n        self._lock = threading.Lock()\n        self._server_thread = None\n        self._loop = None\n        \n        logger.info(f\"NexusInterface initialized with WebSocket port {websocket_port}\")\n    \n    def publish(self, topic: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Publish an event to a specific topic.\n        \n        Args:\n            topic: The topic/channel name\n            data: The event data to publish\n        \"\"\"\n        event = {\n            \"topic\": topic,\n            \"data\": data,\n            \"timestamp\": now_iso(),\n            \"event_id\": f\"{topic}_{int(time.time() * 1000)}\"\n        }\n        \n        with self._lock:\n            # Store in history\n            self.event_history.append(event)\n            if len(self.event_history) > self.max_history:\n                self.event_history.pop(0)\n            \n            # Notify subscribers\n            if topic in self.subscribers:\n                for callback in self.subscribers[topic]:\n                    try:\n                        callback(data)\n                    except Exception as e:\n                        logger.error(f\"Subscriber callback failed for topic {topic}: {e}\")\n        \n        # Broadcast to WebSocket clients\n        if self._loop:\n            asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop)\n        \n        logger.debug(f\"Published event to topic '{topic}': {event['event_id']}\")\n    \n    def subscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Subscribe to events from a specific topic.\n        \n        Args:\n            topic: The topic to subscribe to\n            callback: Function to call when events are published\n        \"\"\"\n        with self._lock:\n            self.subscribers[topic].append(callback)\n        \n        logger.info(f\"Subscribed to topic '{topic}'\")\n    \n    def unsubscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Unsubscribe from a specific topic.\n        \n        Args:\n            topic: The topic to unsubscribe from\n            callback: The callback function to remove\n        \"\"\"\n        with self._lock:\n            if topic in self.subscribers:\n                try:\n                    self.subscribers[topic].remove(callback)\n                except ValueError:\n                    logger.warning(f\"Callback not found in subscribers for topic '{topic}'\")\n        \n        logger.info(f\"Unsubscribed from topic '{topic}'\")\n    \n    def inject_thoughttrail(self, thoughttrail_instance) -> None:\n        \"\"\"\n        Inject ThoughtTrail instance for bidirectional communication.\n        \n        Args:\n            thoughttrail_instance: The ThoughtTrail instance\n        \"\"\"\n        self._thoughttrail = thoughttrail_instance\n        thoughttrail_instance.inject_nexus(self)\n        logger.info(\"ThoughtTrail injected into NexusInterface\")\n    \n    def get_event_history(self, topic: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get recent event history.\n        \n        Args:\n            topic: Filter by topic (None for all topics)\n            limit: Maximum number of events to return\n            \n        Returns:\n            List of recent events\n        \"\"\"\n        with self._lock:\n            events = self.event_history[-limit:] if limit else self.event_history\n            \n            if topic:\n                events = [e for e in events if e[\"topic\"] == topic]\n            \n            return events\n    \n    def get_subscriber_count(self, topic: str) -> int:\n        \"\"\"\n        Get the number of subscribers for a topic.\n        \n        Args:\n            topic: The topic to check\n            \n        Returns:\n            Number of subscribers\n        \"\"\"\n        with self._lock:\n            return len(self.subscribers.get(topic, []))\n    \n    def get_topics(self) -> List[str]:\n        \"\"\"\n        Get all active topics.\n        \n        Returns:\n            List of topic names\n        \"\"\"\n        with self._lock:\n            return list(self.subscribers.keys())\n    \n    def start_server_in_thread(self):\n        \"\"\"Starts the WebSocket server in a separate thread.\"\"\"\n        if self._running:\n            logger.warning(\"WebSocket server is already running.\")\n            return\n\n        self._server_thread = threading.Thread(target=self._run_server, daemon=True)\n        self._server_thread.start()\n        logger.info(\"WebSocket server thread started.\")\n\n    def _run_server(self):\n        \"\"\"The target function for the server thread.\"\"\"\n        self._loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._loop)\n        self._loop.run_until_complete(self.start_websocket_server())\n\n    async def start_websocket_server(self) -> None:\n        \"\"\"Start the WebSocket server for external clients.\"\"\"\n        self._running = True\n        \n        async def handle_client(websocket: WebSocketServerProtocol, path: str):\n            self.websocket_clients.add(websocket)\n            logger.info(f\"WebSocket client connected: {websocket.remote_address}\")\n            \n            try:\n                # Send initial connection message\n                await websocket.send(json.dumps({\n                    \"type\": \"connection_established\",\n                    \"timestamp\": now_iso(),\n                    \"message\": \"Connected to ArchE Nexus\"\n                }))\n                \n                # Keep connection alive\n                async for message in websocket:\n                    await self._handle_websocket_message(websocket, message)\n                    \n            except websockets.exceptions.ConnectionClosed:\n                pass\n            finally:\n                self.websocket_clients.discard(websocket)\n                logger.info(f\"WebSocket client disconnected: {websocket.remote_address}\")\n        \n        async with websockets.serve(handle_client, \"localhost\", self.websocket_port) as server:\n            logger.info(f\"WebSocket server started on port {self.websocket_port}\")\n            self.server_instance = server\n            await asyncio.Future()  # Run forever\n    \n    async def _broadcast_to_websockets(self, event: Dict[str, Any]) -> None:\n        \"\"\"Broadcast event to all connected WebSocket clients.\"\"\"\n        if not self.websocket_clients:\n            return\n        \n        message = json.dumps({\n            \"type\": \"nexus_event\",\n            \"event\": event\n        })\n        \n        # Send to all clients concurrently\n        disconnected_clients = set()\n        for client in self.websocket_clients:\n            try:\n                await client.send(message)\n            except websockets.exceptions.ConnectionClosed:\n                disconnected_clients.add(client)\n            except Exception as e:\n                logger.error(f\"Failed to send to WebSocket client: {e}\")\n                disconnected_clients.add(client)\n        \n        # Remove disconnected clients\n        with self._lock:\n            self.websocket_clients -= disconnected_clients\n    \n    async def _handle_websocket_message(self, websocket: WebSocketServerProtocol, message: str) -> None:\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        try:\n            data = json.loads(message)\n            message_type = data.get(\"type\")\n            \n            if message_type == \"subscribe\":\n                # Client wants to subscribe to a topic\n                topic = data.get(\"topic\")\n                if topic:\n                    # Create a callback that sends to this specific client\n                    async def client_callback(event_data):\n                        try:\n                            await websocket.send(json.dumps({\n                                \"type\": \"topic_event\",\n                                \"topic\": topic,\n                                \"data\": event_data,\n                                \"timestamp\": now_iso()\n                            }))\n                        except websockets.exceptions.ConnectionClosed:\n                            pass\n                    \n                    self.subscribe(topic, client_callback)\n                    \n                    await websocket.send(json.dumps({\n                        \"type\": \"subscription_confirmed\",\n                        \"topic\": topic,\n                        \"timestamp\": now_iso()\n                    }))\n            \n            elif message_type == \"query_history\":\n                # Client wants event history\n                topic = data.get(\"topic\")\n                limit = data.get(\"limit\", 100)\n                history = self.get_event_history(topic, limit)\n                \n                await websocket.send(json.dumps({\n                    \"type\": \"history_response\",\n                    \"history\": history,\n                    \"timestamp\": now_iso()\n                }))\n            \n            elif message_type == \"get_topics\":\n                # Client wants list of active topics\n                topics = self.get_topics()\n                await websocket.send(json.dumps({\n                    \"type\": \"topics_response\",\n                    \"topics\": topics,\n                    \"timestamp\": now_iso()\n                }))\n            \n            else:\n                await websocket.send(json.dumps({\n                    \"type\": \"error\",\n                    \"message\": f\"Unknown message type: {message_type}\",\n                    \"timestamp\": now_iso()\n                }))\n                \n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({\n                \"type\": \"error\",\n                \"message\": \"Invalid JSON\",\n                \"timestamp\": now_iso()\n            }))\n        except Exception as e:\n            logger.error(f\"Error handling WebSocket message: {e}\")\n            await websocket.send(json.dumps({\n                \"type\": \"error\",\n                \"message\": str(e),\n                \"timestamp\": now_iso()\n            }))\n    \n    def stop(self) -> None:\n        \"\"\"Stop the NexusInterface and its WebSocket server.\"\"\"\n        if not self._running:\n            return\n            \n        self._running = False\n        if self._loop:\n            self._loop.call_soon_threadsafe(self._loop.stop)\n        \n        if self._server_thread:\n            self._server_thread.join(timeout=5)\n\n        logger.info(\"NexusInterface and WebSocket server stopped\")\n\n# Global instance\nnexus_interface = NexusInterface()\n\n# Convenience functions\ndef publish_event(topic: str, data: Dict[str, Any]) -> None:\n    \"\"\"Publish an event to the global NexusInterface.\"\"\"\n    nexus_interface.publish(topic, data)\n\ndef subscribe_to_topic(topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n    \"\"\"Subscribe to a topic on the global NexusInterface.\"\"\"\n    nexus_interface.subscribe(topic, callback)\n\ndef get_nexus() -> NexusInterface:\n    \"\"\"Get the global NexusInterface instance.\"\"\"\n    return nexus_interface\n\n__all__ = [\n    'NexusInterface',\n    'nexus_interface',\n    'publish_event',\n    'subscribe_to_topic',\n    'get_nexus'\n]\n\n\n```\n\nEXAMPLE APPLICATION:\nCentral communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_interface.py; source_type: python_class",
    "compression_ratio": 1.0,
    "symbol_count": 14000,
    "timestamp": "2025-11-18T11:00:42.150578Z"
  },
  {
    "stage_name": "Concise",
    "content": "TERM: Class: NexusInterface\n\nDEFINITION:\nCentral communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_interface.py, type: python_class\n\nFULL IMPLEMENTATION CODE (nexus_interface.py):\n```python\n\"\"\"\nNexusInterface: ArchE's Central Nervous System\n==============================================\n\nThe NexusInterface serves as ArchE's central communication bus, implementing\na publisher-subscriber pattern for asynchronous, decoupled communication\nbetween all system components.\n\nThis implementation provides:\n- Event publishing and subscription\n- Real-time message routing\n- ThoughtTrail integration\n- WebSocket support for external clients\n- Event filtering and routing\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport threading\nimport time\nfrom collections import defaultdict\nfrom datetime import datetime\n\n# ============================================================================\n# TEMPORAL CORE INTEGRATION (CANONICAL DATETIME SYSTEM)\n# ============================================================================\nfrom .temporal_core import now_iso, format_filename, format_log, Timer\nfrom typing import Dict, List, Any, Callable, Optional, Set\nimport websockets\nfrom websockets.server import WebSocketServerProtocol\n\nlogger = logging.getLogger(__name__)\n\nclass NexusInterface:\n    \"\"\"\n    Central communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n    \"\"\"\n    \n    def __init__(self, websocket_port: int = 8765):\n        \"\"\"\n        Initialize the NexusInterface.\n        \n        Args:\n            websocket_port: Port for WebSocket server\n        \"\"\"\n        self.subscribers = defaultdict(list)  # topic -> list of callbacks\n        self.event_history = []  # Store recent events for debugging\n        self.max_history = 1000\n        self.websocket_port = websocket_port\n        self.websocket_clients: Set[WebSocketServerProtocol] = set()\n        self._thoughttrail = None\n        self._running = False\n        self._lock = threading.Lock()\n        self._server_thread = None\n        self._loop = None\n        \n        logger.info(f\"NexusInterface initialized with WebSocket port {websocket_port}\")\n    \n    def publish(self, topic: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Publish an event to a specific topic.\n        \n        Args:\n            topic: The topic/channel name\n            data: The event data to publish\n        \"\"\"\n        event = {\n            \"topic\": topic,\n            \"data\": data,\n            \"timestamp\": now_iso(),\n            \"event_id\": f\"{topic}_{int(time.time() * 1000)}\"\n        }\n        \n        with self._lock:\n            # Store in history\n            self.event_history.append(event)\n            if len(self.event_history) > self.max_history:\n                self.event_history.pop(0)\n            \n            # Notify subscribers\n            if topic in self.subscribers:\n                for callback in self.subscribers[topic]:\n                    try:\n                        callback(data)\n                    except Exception as e:\n                        logger.error(f\"Subscriber callback failed for topic {topic}: {e}\")\n        \n        # Broadcast to WebSocket clients\n        if self._loop:\n            asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop)\n        \n        logger.debug(f\"Published event to topic '{topic}': {event['event_id']}\")\n    \n    def subscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Subscribe to events from a specific topic.\n        \n        Args:\n            topic: The topic to subscribe to\n            callback: Function to call when events are published\n        \"\"\"\n        with self._lock:\n            self.subscribers[topic].append(callback)\n        \n        logger.info(f\"Subscribed to topic '{topic}'\")\n    \n    def unsubscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Unsubscribe from a specific topic.\n        \n        Args:\n            topic: The topic to unsubscribe from\n            callback: The callback function to remove\n        \"\"\"\n        with self._lock:\n            if topic in self.subscribers:\n                try:\n                    self.subscribers[topic].remove(callback)\n                except ValueError:\n                    logger.warning(f\"Callback not found in subscribers for topic '{topic}'\")\n        \n        logger.info(f\"Unsubscribed from topic '{topic}'\")\n    \n    def inject_thoughttrail(self, thoughttrail_instance) -> None:\n        \"\"\"\n        Inject ThoughtTrail instance for bidirectional communication.\n        \n        Args:\n            thoughttrail_instance: The ThoughtTrail instance\n        \"\"\"\n        self._thoughttrail = thoughttrail_instance\n        thoughttrail_instance.inject_nexus(self)\n        logger.info(\"ThoughtTrail injected into NexusInterface\")\n    \n    def get_event_history(self, topic: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get recent event history.\n        \n        Args:\n            topic: Filter by topic (None for all topics)\n            limit: Maximum number of events to return\n            \n        Returns:\n            List of recent events\n        \"\"\"\n        with self._lock:\n            events = self.event_history[-limit:] if limit else self.event_history\n            \n            if topic:\n                events = [e for e in events if e[\"topic\"] == topic]\n            \n            return events\n    \n    def get_subscriber_count(self, topic: str) -> int:\n        \"\"\"\n        Get the number of subscribers for a topic.\n        \n        Args:\n            topic: The topic to check\n            \n        Returns:\n            Number of subscribers\n        \"\"\"\n        with self._lock:\n            return len(self.subscribers.get(topic, []))\n    \n    def get_topics(self) -> List[str]:\n        \"\"\"\n        Get all active topics.\n        \n        Returns:\n            List of topic names\n        \"\"\"\n        with self._lock:\n            return list(self.subscribers.keys())\n    \n    def start_server_in_thread(self):\n        \"\"\"Starts the WebSocket server in a separate thread.\"\"\"\n        if self._running:\n            logger.warning(\"WebSocket server is already running.\")\n            return\n\n        self._server_thread = threading.Thread(target=self._run_server, daemon=True)\n        self._server_thread.start()\n        logger.info(\"WebSocket server thread started.\")\n\n    def _run_server(self):\n        \"\"\"The t",
    "compression_ratio": 2.0,
    "symbol_count": 7000,
    "timestamp": "2025-11-18T11:00:42.150602Z"
  },
  {
    "stage_name": "Nano",
    "content": "TERM: Class: NexusInterface D: Central communication hub Æ. Implements a publisher-subscriber pattern components : - Publish events to specific topics - Subscribe to events specific topics - Filter events based on criteria - Connect external clients via WebSocket BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/nexus_interface.py, type: python_class FULL I CODE (nexus_interface.py): ```python \"\"\" NexusInterface: Æ's Central Nervous S ============================================== NexusInterface serves as Æ's central communication bus, implementing a publisher-subscriber pattern asynchronous, decoupled communication between S components. I provides: - Event publishing subscription - Real-time message routing - Σ integration - WebSocket support external clients - Event filtering routing \"\"\" import asyncio import json import logging import threading import time collections import defaultdict datetime import datetime # ============================================================================ # TEMPORAL CORE INTEGRATION (CANONICAL DATETIME S) # ============================================================================ .temporal_core import now_iso, F_filename, F_log, Timer typing import Dict, List, Any, Callable, Optional, Set import websockets websockets.server import WebSocketServerP logger = logging.getLogger(__name__) class NexusInterface: \"\"\" Central communication hub Æ. Implements a publisher-subscriber pattern components : - Publish events to specific topics - Subscribe to events specific topics - Filter events based on criteria - Connect external clients via WebSocket \"\"\" def __init__(self, websocket_port: int = 8765): \"\"\" Initialize NexusInterface. Args: websocket_port: Port WebSocket server \"\"\" self.subscribers = defaultdict(list) # topic -> list of callbacks self.event_history = [] # Store recent events debugging self.max_history = 1000 self.websocket_port = websocket_port self.websocket_clients: Set[WebSocketServerP] = set() self._Σ = None self._running = False self._lock = threading.Lock() self._server_thread = None self._loop = None logger.info(f\"NexusInterface initialized WebSocket port {websocket_port}\") def publish(self, topic: str, data: Dict[str, Any]) -> None: \"\"\" Publish an event to a specific topic. Args: topic: topic/channel name data: event data to publish \"\"\" event = { \"topic\": topic, \"data\": data, \"timestamp\": now_iso(), \"event_id\": f\"{topic}_{int(time.time() * 1000)}\" } self._lock: # Store in history self.event_history.append(event) if len(self.event_history) > self.max_history: self.event_history.pop(0) # Notify subscribers if topic in self.subscribers: callback in self.subscribers[topic]: try: callback(data) except Exception as e: logger.error(f\"Subscriber callback failed topic {topic}: {e}\") # Broadcast to WebSocket clients if self._loop: asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop) logger.debug(f\"Published event to topic '{topic}': {event['event_id']}\") def subscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None: \"\"\" Subscribe to events a specific topic. Args: topic: topic to subscribe to callback: Function to call events published \"\"\" self._lock: self.subscribers[topic].append(callback) logger.info(f\"Subscribed to topic '{topic}'\") def unsubscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None: \"\"\" Unsubscribe a specific topic. Args: topic: topic to unsubscribe callback: callback function to remove \"\"\" self._lock: if topic in self.subscribers: try: self.subscribers[topic].remove(callback) except ValueError: logger.warning(f\"Callback found in subscribers topic '{topic}'\") logger.info(f\"Unsubscribed topic '{topic}'\") def inject_Σ(self, Σ_instance) -> None: \"\"\" Inject Σ instance bidirectional communication. Args: Σ_instance: Σ instance \"\"\" self._Σ = Σ_instance Σ_instance.inject_nexus(self) logger.info(\"Σ injected into NexusInterface\") def get_event_history(self, topic: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]: \"\"\" Get recent event history. Args: topic: Filter by topic (None topics) limit: Maximum number of events to return Returns: List of recent events \"\"\" self._lock: events = self.event_history[-limit:] if limit else self.event_history if topic: events = [e e in events if e[\"topic\"] == topic] return events def get_subscriber_count(self, topic: str) -> int: \"\"\" Get number of subscribers a topic. Args: topic: topic to check Returns: Number of subscribers \"\"\" self._lock: return len(self.subscribers.get(topic, [])) def get_topics(self) -> List[str]: \"\"\" Get active topics. Returns: List of topic names \"\"\" self._lock: return list(self.subscribers.keys()) def start_server_in_thread(self): \"\"\"Starts WebSocket server in a separate thread.\"\"\" if self._running: logger.warning(\"WebSocket server is already running.\") return self._server_thread = threading.Thread(target=self._run_server, daemon=True) self._server_thread.start() logger.info(\"WebSocket server thread started.\") def _run_server(self): \"\"\" t",
    "compression_ratio": 2.775574940523394,
    "symbol_count": 5044,
    "timestamp": "2025-11-18T11:00:42.257743Z"
  },
  {
    "stage_name": "Micro",
    "content": "TERM: Class: NexusInterface D: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/nexus_interface.py, type: python_class FULL I CODE (nexus_interface.py): ```python NexusInterface: Æ's Central Nervous S ============================================== NexusInterface serves Æ's central communication implementing publisher-subscriber Π asynchronous, decoupled communication between S components. I provides: Event publishing subscription Real-time message routing Σ integration WebSocket support external clients Event filtering routing import asyncio import import logging import threading import collections import defaultdict datetime import datetime ============================================================================ Δ CORE INTEGRATION (CANONICAL DATETIME S) ============================================================================ .temporal_core import now_iso, F_filename, F_log, Timer typing import Dict, List, Any, Callable, Optional, Set import websockets websockets.server import WebSocketServerP logger logging.getLogger(__name__) class NexusInterface: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket __init__(self, websocket_port: 8765): Initialize NexusInterface. Args: websocket_port: Port WebSocket server self.subscribers defaultdict(list) topic callbacks self.event_history Store recent events debugging self.max_history self.websocket_port websocket_port self.websocket_clients: Set[WebSocketServerP] set() self._Σ None self._running False self._lock threading.Lock() self._server_thread None self._loop None logger.info(f\"NexusInterface initialized WebSocket {websocket_port}\") publish(self, topic: data: Dict[str, Any]) None: Publish event specific topic. Args: topic: topic/channel data: event publish event \"topic\": topic, \"data\": data, \"timestamp\": now_iso(), \"event_id\": f\"{topic}_{int(time.time() 1000)}\" self._lock: Store history self.event_history.append(event) len(self.event_history) self.max_history: self.event_history.pop(0) Notify subscribers topic self.subscribers: callback self.subscribers[topic]: callback(data) except Exception logger.error(f\"Subscriber callback failed topic {topic}: {e}\") Broadcast WebSocket clients self._loop: asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop) logger.debug(f\"Published event topic '{topic}': {event['event_id']}\") subscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Subscribe events specific topic. Args: topic: topic subscribe callback: Function events published self._lock: self.subscribers[topic].append(callback) logger.info(f\"Subscribed topic '{topic}'\") unsubscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Unsubscribe specific topic. Args: topic: topic unsubscribe callback: callback function remove self._lock: topic self.subscribers: self.subscribers[topic].remove(callback) except ValueError: logger.warning(f\"Callback found subscribers topic '{topic}'\") logger.info(f\"Unsubscribed topic '{topic}'\") inject_Σ(self, Σ_instance) None: Inject Σ instance bidirectional communication. Args: Σ_instance: Σ instance self._Σ Σ_instance Σ_instance.inject_nexus(self) logger.info(\"Σ injected NexusInterface\") get_event_history(self, topic: Optional[str] None, limit: List[Dict[str, Any]]: Get recent event history. Args: topic: Filter topic (None topics) limit: Maximum number events return Returns: List recent events self._lock: events self.event_history[-limit:] limit self.event_history topic: events events e[\"topic\"] topic] return events get_subscriber_count(self, topic: Get number subscribers topic. Args: topic: topic check Returns: Number subscribers self._lock: return len(self.subscribers.get(topic, get_topics(self) List[str]: Get active topics. Returns: List topic names self._lock: return list(self.subscribers.keys()) start_server_in_thread(self): \"\"\"Starts WebSocket server separate thread.\"\"\" self._running: logger.warning(\"WebSocket server already running.\") return self._server_thread threading.Thread(target=self._run_server, daemon=True) self._server_thread.start() logger.info(\"WebSocket server thread started.\") _run_server(self):",
    "compression_ratio": 3.1222123104371096,
    "symbol_count": 4484,
    "timestamp": "2025-11-18T11:00:42.412019Z"
  },
  {
    "stage_name": "Pico",
    "content": "TERM: Class: NexusInterface D: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/nexus_interface.py, type: python_class FULL I CODE (nexus_interface.py): ```python NexusInterface: Æ's Central Nervous S ============================================== NexusInterface serves Æ's central communication implementing publisher-subscriber Π asynchronous, decoupled communication between S components. I provides: Event publishing subscription Real-time message routing Σ integration WebSocket support external clients Event filtering routing import asyncio import import logging import threading import collections import defaultdict datetime import datetime ============================================================================ Δ CORE INTEGRATION (CANONICAL DATETIME S) ============================================================================ .temporal_core import now_iso, F_filename, F_log, Timer typing import Dict, List, Any, Callable, Optional, Set import websockets websockets.server import WebSocketServerP logger logging.getLogger(__name__) class NexusInterface: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket __init__(self, websocket_port: 8765): Initialize NexusInterface. Args: websocket_port: Port WebSocket server self.subscribers defaultdict(list) topic callbacks self.event_history Store recent events debugging self.max_history self.websocket_port websocket_port self.websocket_clients: Set[WebSocketServerP] set() self._Σ None self._running False self._lock threading.Lock() self._server_thread None self._loop None logger.info(f\"NexusInterface initialized WebSocket {websocket_port}\") publish(self, topic: data: Dict[str, Any]) None: Publish event specific topic. Args: topic: topic/channel data: event publish event \"topic\": topic, \"data\": data, \"timestamp\": now_iso(), \"event_id\": f\"{topic}_{int(time.time() 1000)}\" self._lock: Store history self.event_history.append(event) len(self.event_history) self.max_history: self.event_history.pop(0) Notify subscribers topic self.subscribers: callback self.subscribers[topic]: callback(data) except Exception logger.error(f\"Subscriber callback failed topic {topic}: {e}\") Broadcast WebSocket clients self._loop: asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop) logger.debug(f\"Published event topic '{topic}': {event['event_id']}\") subscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Subscribe events specific topic. Args: topic: topic subscribe callback: Function events published self._lock: self.subscribers[topic].append(callback) logger.info(f\"Subscribed topic '{topic}'\") unsubscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Unsubscribe specific topic. Args: topic: topic unsubscribe callback: callback function remove self._lock: topic self.subscribers: self.subscribers[topic].remove(callback) except ValueError: logger.warning(f\"Callback found subscribers topic '{topic}'\") logger.info(f\"Unsubscribed topic '{topic}'\") inject_Σ(self, Σ_instance) None: Inject Σ instance bidirectional communication. Args: Σ_instance: Σ instance self._Σ Σ_instance Σ_instance.inject_nexus(self) logger.info(\"Σ injected NexusInterface\") get_event_history(self, topic: Optional[str] None, limit: List[Dict[str, Any]]: Get recent event history. Args: topic: Filter topic (None topics) limit: Maximum number events return Returns: List recent events self._lock: events self.event_history[-limit:] limit self.event_history topic: events events e[\"topic\"] topic] return events get_subscriber_count(self, topic: Get number subscribers topic. Args: topic: topic check Returns: Number subscribers self._lock: return len(self.subscribers.get(topic, get_topics(self) List[str]: Get active topics. Returns: List topic names self._lock: return list(self.subscribers.keys()) start_server_in_thread(self): \"\"\"Starts WebSocket server separate thread.\"\"\" self._running: logger.warning(\"WebSocket server already running.\") return self._server_thread threading.Thread(target=self._run_server, daemon=True) self._server_thread.start() logger.info(\"WebSocket server thread started.\") _run_server(self):",
    "compression_ratio": 3.1222123104371096,
    "symbol_count": 4484,
    "timestamp": "2025-11-18T11:00:42.556200Z"
  },
  {
    "stage_name": "Femto",
    "content": "TERM: Class: NexusInterface D: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/nexus_interface.py, type: python_class FULL I CODE (nexus_interface.py): ```python NexusInterface: Æ's Central Nervous S ============================================== NexusInterface serves Æ's central communication implementing publisher-subscriber Π asynchronous, decoupled communication between S components. I provides: Event publishing subscription Real-time message routing Σ integration WebSocket support external clients Event filtering routing import asyncio import import logging import threading import collections import defaultdict datetime import datetime ============================================================================ Δ CORE INTEGRATION (CANONICAL DATETIME S) ============================================================================ .temporal_core import now_iso, F_filename, F_log, Timer typing import Dict, List, Any, Callable, Optional, Set import websockets websockets.server import WebSocketServerP logger logging.getLogger(__name__) class NexusInterface: Central communication Æ. Implements publisher-subscriber Π components Publish events specific topics Subscribe events specific topics Filter events ABM criteria Connect external clients WebSocket __init__(self, websocket_port: 8765): Initialize NexusInterface. Args: websocket_port: Port WebSocket server self.subscribers defaultdict(list) topic callbacks self.event_history Store recent events debugging self.max_history self.websocket_port websocket_port self.websocket_clients: Set[WebSocketServerP] set() self._Σ None self._running False self._lock threading.Lock() self._server_thread None self._loop None logger.info(f\"NexusInterface initialized WebSocket {websocket_port}\") publish(self, topic: data: Dict[str, Any]) None: Publish event specific topic. Args: topic: topic/channel data: event publish event \"topic\": topic, \"data\": data, \"timestamp\": now_iso(), \"event_id\": f\"{topic}_{int(time.time() 1000)}\" self._lock: Store history self.event_history.append(event) len(self.event_history) self.max_history: self.event_history.pop(0) Notify subscribers topic self.subscribers: callback self.subscribers[topic]: callback(data) except Exception logger.error(f\"Subscriber callback failed topic {topic}: {e}\") Broadcast WebSocket clients self._loop: asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop) logger.debug(f\"Published event topic '{topic}': {event['event_id']}\") subscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Subscribe events specific topic. Args: topic: topic subscribe callback: Function events published self._lock: self.subscribers[topic].append(callback) logger.info(f\"Subscribed topic '{topic}'\") unsubscribe(self, topic: callback: Callable[[Dict[str, Any]], None]) None: Unsubscribe specific topic. Args: topic: topic unsubscribe callback: callback function remove self._lock: topic self.subscribers: self.subscribers[topic].remove(callback) except ValueError: logger.warning(f\"Callback found subscribers topic '{topic}'\") logger.info(f\"Unsubscribed topic '{topic}'\") inject_Σ(self, Σ_instance) None: Inject Σ instance bidirectional communication. Args: Σ_instance: Σ instance self._Σ Σ_instance Σ_instance.inject_nexus(self) logger.info(\"Σ injected NexusInterface\") get_event_history(self, topic: Optional[str] None, limit: List[Dict[str, Any]]: Get recent event history. Args: topic: Filter topic (None topics) limit: Maximum number events return Returns: List recent events self._lock: events self.event_history[-limit:] limit self.event_history topic: events events e[\"topic\"] topic] return events get_subscriber_count(self, topic: Get number subscribers topic. Args: topic: topic check Returns: Number subscribers self._lock: return len(self.subscribers.get(topic, get_topics(self) List[str]: Get active topics. Returns: List topic names self._lock: return list(self.subscribers.keys()) start_server_in_thread(self): \"\"\"Starts WebSocket server separate thread.\"\"\" self._running: logger.warning(\"WebSocket server already running.\") return self._server_thread threading.Thread(target=self._run_server, daemon=True) self._server_thread.start() logger.info(\"WebSocket server thread started.\") _run_server(self):",
    "compression_ratio": 3.1222123104371096,
    "symbol_count": 4484,
    "timestamp": "2025-11-18T11:00:42.745356Z"
  },
  {
    "stage_name": "Atto",
    "content": "TERM: Class: NexusInterface D: Central Æ. Implements Π Publish Subscribe Filter ABM Connect WebSocket BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/nexus_interface.py, FULL I CODE NexusInterface: Æ's Central Nervous S NexusInterface Æ's Π S I Event Real-time Σ WebSocket Event Δ CORE INTEGRATION (CANONICAL DATETIME S) F_filename, F_log, Timer Dict, List, Any, Callable, Optional, Set WebSocketServerP NexusInterface: Central Æ. Implements Π Publish Subscribe Filter ABM Connect WebSocket Initialize NexusInterface. Args: Port WebSocket Store Set[WebSocketServerP] self._Σ None False None None WebSocket Dict[str, Any]) None: Publish Args: Store Notify Exception Broadcast WebSocket Callable[[Dict[str, Any]], None]) None: Subscribe Args: Function Callable[[Dict[str, Any]], None]) None: Unsubscribe Args: ValueError: inject_Σ(self, Σ_instance) None: Inject Σ Args: Σ_instance: Σ self._Σ Σ_instance Σ_instance.inject_nexus(self) logger.info(\"Σ NexusInterface\") Optional[str] None, List[Dict[str, Any]]: Get Args: Filter Maximum Returns: List Get Args: Returns: Number List[str]: Get Returns: List WebSocket",
    "compression_ratio": 12.345679012345679,
    "symbol_count": 1134,
    "timestamp": "2025-11-18T11:00:42.886045Z"
  },
  {
    "stage_name": "Zepto",
    "content": "Æ|Π|Æ|Æ|Æ",
    "compression_ratio": 1555.5555555555557,
    "symbol_count": 9,
    "timestamp": "2025-11-18T11:00:42.894377Z"
  }
]