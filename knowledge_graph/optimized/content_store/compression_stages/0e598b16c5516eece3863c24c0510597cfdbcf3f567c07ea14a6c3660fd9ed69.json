[
  {
    "stage_name": "Narrative",
    "content": "TERM: Action Registry\n\nDEFINITION:\nThe infinite, magical workshop from which the Workflow Engine draws every tool it could ever need. It is the universal translator that allows the Core workflow enginE to seamlessly and safely interface between abstract intent (a task in a workflow) and concrete capability (a Python function).\n\n[From agi.txt]: SPR mentioned in list from agi.txt: is\n\nBLUEPRINT DETAILS:\nSee ResonantiA Protocol v3.1-CA, Section 3.2; implemented in Three_PointO_ArchE/action_registry.py\n\nIMPLEMENTATION CODE (action_registry.py) - First 30KB:\n```python\n# --- START OF FILE 3.0ArchE/action_registry.py (UNIFIED) ---\nimport logging\nimport inspect\nfrom typing import Dict, Any, Callable, Optional, List\nimport subprocess\nimport os\nimport sys\nimport tempfile\nimport json\nfrom jinja2 import Environment, meta, exceptions # Import Jinja2\n\n# Initialize logger first\nlogger = logging.getLogger(__name__)\n\n# --- Core Imports ---\ntry:\n    from . import config\n    from .error_handler import handle_action_error\n    from .thought_trail import log_to_thought_trail\n    from .temporal_core import now_iso\n    # --- Tool Imports ---\n    from .tools.enhanced_search_tool import perform_web_search\n    from .tools.synthesis_tool import invoke_llm_for_synthesis\n    from .code_executor import execute_code as _raw_execute_code\n    from .web_search_tool import search_web\n    from .nfl_prediction_action import predict_nfl_game\n    # --- Capabilities ---\n    from .llm_providers import GoogleProvider # Corrected from .llm_providers.google\n    from .enhanced_capabilities import GeminiCapabilities\n\nexcept ImportError as e:\n    logger.critical(f\"A critical relative import failed in action_registry: {e}\", exc_info=True)\n    # Define dummy fallbacks if imports fail during standalone execution\n    def handle_action_error(e, *args): raise e\n    def log_to_thought_trail(func): return func\n    # Add other necessary fallbacks here...\n    GoogleProvider = None\n    GeminiCapabilities = None\n    # NFL prediction fallback\n    def predict_nfl_game(*args, **kwargs):\n        return {\"error\": \"predict_nfl_game not available\", \"status\": \"error\"}\n\n# V4 UNIFICATION PROXY is now after the logger, which is correct.\n# --- V4 UNIFICATION PROXY ---\n# Import the V4 action executor. This is the bridge.\ntry:\n    # Add Four_PointO_ArchE to path\n    four_pointo_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_ArchE')\n    if four_pointo_path not in sys.path:\n        sys.path.insert(0, four_pointo_path)\n    \n    # Also add current directory to path for direct execution\n    current_dir = os.path.dirname(os.path.dirname(__file__))\n    if current_dir not in sys.path:\n        sys.path.insert(0, current_dir)\n    \n    # Try to add virtual environment site-packages to path for googlemaps (MUST be before TSPSolver import)\n    venv_site_packages = None\n    project_root = os.path.dirname(os.path.dirname(__file__))\n    for python_version in ['3.12', '3.11', '3.10', '3.9']:\n        sp_path = os.path.join(project_root, 'arche_env', 'lib', f'python{python_version}', 'site-packages')\n        if os.path.exists(sp_path) and sp_path not in sys.path:\n            sys.path.insert(0, sp_path)\n            venv_site_packages = sp_path\n            break\n    \n    from tools.perception_engine import PerceptionEngine\n    from tools.rise_actions import perform_causal_inference as v4_causal_inference, perform_abm as v4_abm, run_cfp as v4_cfp\n    \n    # Import TSPSolver - try multiple import paths (googlemaps must be available from venv)\n    TSPSolver = None\n    try:\n        from tsp_solver.solver import TSPSolver\n    except ImportError as e1:\n        # Fallback: try importing from Four_PointO_ArchE package\n        try:\n            from Four_PointO_ArchE.tsp_solver.solver import TSPSolver\n        except ImportError as e2:\n            # Last resort: import directly from file\n            try:\n                import importlib.util\n                tsp_solver_path = os.path.join(four_pointo_path, 'tsp_solver', 'solver.py')\n                if os.path.exists(tsp_solver_path):\n                    spec = importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path)\n                    tsp_module = importlib.util.module_from_spec(spec)\n                    # Ensure venv packages are available when loading the module\n                    if venv_site_packages and venv_site_packages not in sys.path:\n                        sys.path.insert(0, venv_site_packages)\n                    spec.loader.exec_module(tsp_module)\n                    TSPSolver = tsp_module.TSPSolver\n                else:\n                    raise ImportError(f\"TSPSolver not found at {tsp_solver_path}\")\n            except Exception as e3:\n                # If TSPSolver can't be imported (e.g., missing googlemaps), make it optional\n                logger.debug(f\"TSPSolver not available (optional V4 component): {e3}\")\n                TSPSolver = None\n    V4_REGISTRY_AVAILABLE = True\n    V4_PERCEPTION_ENGINE = PerceptionEngine()\n    V4_TSP_SOLVER = TSPSolver  # Store the class, will be initialized when needed with proper API key\n    if venv_site_packages:\n        logger.debug(f\"V4 system initialized with venv site-packages: {venv_site_packages}\")\n    if TSPSolver:\n        logger.debug(\"TSPSolver available for V4 system\")\n    else:\n        logger.debug(\"TSPSolver not available (googlemaps or module not found)\")\nexcept ImportError as e:\n    V4_REGISTRY_AVAILABLE = False\n    V4_PERCEPTION_ENGINE = None\n    V4_TSP_SOLVER = None\n    # Only warn if it's not just googlemaps (which is optional)\n    if 'googlemaps' not in str(e).lower():\n        logger.warning(f\"V4 system not available: {e}\")\n    else:\n        logger.debug(f\"V4 system partially available (googlemaps optional): {e}\")\n\n# --- ENHANCED PERCEPTION ENGINE ---\n# Import the enhanced Perception Engine for advanced web capabilities\ntry:\n    from .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis\n    ENHANCED_PERCEPTION_AVAILABLE = True\n    logger.info(\"Enhanced Perception Engine available\")\nexcept ImportError as e:\n    try:\n        from enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis\n        ENHANCED_PERCEPTION_AVAILABLE = True\n        logger.info(\"Enhanced Perception Engine available\")\n    except ImportError as e2:\n        ENHANCED_PERCEPTION_AVAILABLE = False\n        logger.warning(f\"Enhanced Perception Engine not available: {e2}\")\n\n# Import tool functions\n# from Three_PointO_ArchE.tools.enhanced_search_tool import perform_web_search as run_search\n# from Three_PointO_ArchE.tools.synthesis_tool import invoke_llm_for_synthesis as invoke_llm\n# from Three_PointO_ArchE.code_executor import execute_code\n# ^^^ This was causing a circular import in the previous attempt to fix, removing\n\nclass ActionRegistry:\n    \"\"\"A central registry for all callable actions (tools) in the system.\"\"\"\n    def __init__(self):\n        self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] = {}\n        logger.info(\"ActionRegistry initialized.\")\n\n    def list_actions(self) -> List[str]:\n        \"\"\"Returns a list of all registered action names.\"\"\"\n        return list(self.actions.keys())\n\n    def get_action_signatures(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Inspects registered actions and returns their signatures and docstrings.\n        This is crucial for providing the LLM with an \"API reference\".\n        \"\"\"\n        signatures = {}\n        for name, func in self.actions.items():\n            try:\n                sig = inspect.signature(func)\n                doc = inspect.getdoc(func) or \"No documentation available.\"\n                params = {\n                    p.name: {\n                        \"type\": str(p.annotation) if p.annotation != inspect.Parameter.empty else \"Any\",\n                        \"default\": p.default if p.default != inspect.Parameter.empty else \"REQUIRED\"\n                    }\n                    for p in sig.parameters.values()\n                }\n                signatures[name] = {\n                    \"doc\": doc,\n                    \"params\": params\n                }\n            except (TypeError, ValueError):\n                # Some callables (like functools.partial) might not be inspectable\n                signatures[name] = {\n                    \"doc\": \"This action could not be inspected.\",\n                    \"params\": {}\n                }\n        return signatures\n\n    @log_to_thought_trail\n    def register_action(self, action_type: str, function: Callable[[Dict[str, Any]], Dict[str, Any]], force: bool = False):\n        \"\"\"\n        Registers an action in the registry.\n\n        Args:\n            action_type (str): The name of the action to register.\n            function (Callable): The function to be executed for this action.\n            force (bool): If True, overwrites an existing action with the same name.\n        \"\"\"\n        if action_type in self.actions and not force:\n            # Suppress duplicate registration warnings as they're non-critical\n            # logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\")\n            pass\n        else:\n            self.actions[action_type] = function\n            logger.info(f\"Action '{action_type}' registered.\")\n\n    @log_to_thought_trail\n    def get_action(self, name: str) -> Callable:\n        \"\"\"\n        Retrieves an action from the registry.\n\n        Args:\n            name (str): The name of the action to retrieve.\n\n        Returns:\n            The callable function for the action.\n\n        Raises:\n            KeyError: If the action is not found.\n        \"\"\"\n        action = self.actions.get(name)\n        if not action:\n            logger.error(f\"Action '{name}' not found in registry. Available actions: {list(self.actions.keys())}\")\n            raise KeyError(f\"Action '{name}' not found.\")\n        return action\n\n# --- Singleton Instance ---\n# This is the central, globally accessible registry.\nmain_action_registry = ActionRegistry()\n# Backward-compatibility alias expected by some tests\nACTION_REGISTRY = main_action_registry\n\n\n# --- Core Tool Imports and Registration ---\n# All imports are now handled at the top of the file in the try/except block.\n\n\n# Wrapper to adapt code_executor signature to action registry calling convention\n@log_to_thought_trail\ndef standalone_execute_code(**kwargs) -> Dict[str, Any]:\n    \"\"\"Wrapper for code_executor.execute_code that adapts keyword args to inputs dict.\"\"\"\n    return _raw_execute_code(inputs=kwargs)\n\n\n# --- NEW: Import and Instantiate Modular Capabilities ---\n# This is now handled in the main try/except block at the top\n\n# This assumes the config is loaded and available for the provider initialization\ntry:\n    cfg = config.get_config()\n    # FIX: Access the key via attribute, not .get()\n    google_api_key = cfg.api_keys.google_api_key if hasattr(cfg.api_keys, 'google_api_key') else None\n    if not google_api_key:\n        logger.warning(\"Google API key not found in config, using dummy key for initialization.\")\n        google_api_key = \"dummy_key_for_init\"\n    \n    # Check if GoogleProvider was imported successfully before instantiating\n    if GoogleProvider:\n        google_provider_instance = GoogleProvider(api_key=google_api_key)\n        gemini_capabilities_instance = GeminiCapabilities(google_provider=google_provider_instance)\n        CAPABILITIES_AVAILABLE = True\n        logger.info(\"GeminiCapabilities initialized and available in ActionRegistry.\")\n    else:\n        CAPABILITIES_AVAILABLE = False\n        gemini_capabilities_instance = None\n        logger.warning(\"GoogleProvider not available, GeminiCapabilities will be disabled.\")\n\nexcept Exception as e:\n    CAPABILITIES_AVAILABLE = False\n    gemini_capabilities_instance = None\n    logger.warning(f\"Could not initialize GeminiCapabilities: {e}\", exc_info=True)\n\n\n# Placeholder functions for actions used in the workflow but potentially missing\n@log_to_thought_trail\ndef display_output(content: str, **kwargs) -> Dict[str, Any]:\n    \"\"\"Prints content to the console and returns a fully IAR-compliant result.\"\"\"\n    logger.info(\"DISPLAY_OUTPUT Action Fired:\")\n    import pprint\n    pprint.pprint(content)\n    \n    # Return a fully compliant IAR dictionary\n    summary = f\"Displayed content of {len(str(content))} characters.\"\n    preview = str(content)[:100] + \"...\" if len(str(content)) > 100 else str(content)\n\n    return {\n        'status': 'success',\n        'message': 'Content displayed successfully.',\n        'reflection': {\n            'status': 'Success',\n            'summary': summary,\n            'confidence': 1.0,\n            'alignment_check': {\n                'objective_alignment': 1.0,\n                'protocol_alignment': 1.0\n            },\n            'potential_issues': [],\n            'raw_output_preview': preview\n        }\n    }\n\n@log_to_thought_trail\ndef calculate_math(expression: str, **kwargs) -> Dict[str, Any]:\n    \"\"\"Evaluates a simple mathematical expression and returns IAR-compliant result.\"\"\"\n    logger.info(f\"CALCULATE_MATH Action Fired with expression: {expression}\")\n    try:\n        # WARNING: eval() is used for simplicity. Be cautious in a production environment.\n        result = eval(str(expression))\n        return {\n            'status': 'success',\n            'result': result,\n            'message': f'Successfully evaluated: {expression} = {result}',\n            'reflection': {\n                'status': 'Success',\n                'summary': f'Mathematical expression \"{expression}\" evaluated to {result}',\n                'confidence': 1.0,\n                'alignment_check': {\n                    'objective_alignment': 1.0,\n                    'protocol_alignment': 1.0\n                },\n                'potential_issues': [],\n                'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}'\n            }\n        }\n    except Exception as e:\n        logger.error(f\"Error evaluating math expression '{expression}': {e}\", exc_info=True)\n        return {\n            'status': 'error',\n            'message': f'Failed to evaluate expression: {str(e)}',\n            'error_details': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Math evaluation failed for \"{expression}\": {str(e)}',\n                'confidence': 0.0,\n                'alignment_check': {\n                    'objective_alignment': 0.0,\n                    'protocol_alignment': 0.0\n                },\n                'potential_issues': [\n                    f'Invalid mathematical expression: {expression}',\n                    str(e)\n                ],\n                'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}'\n            }\n        }\n\n# --- Additional Action Implementations ---\n@log_to_thought_trail\ndef string_template_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"\n    [IAR Compliant] Renders a Jinja2 template string using the current workflow context.\n    This action ensures that templating is handled consistently and robustly\n    across the entire system, adhering to the capabilities of the core workflow engine.\n    \"\"\"\n    template_string = kwargs.get('template', '')\n    context_for_action = kwargs.get('context_for_action')\n    runtime_context = {}\n\n    if context_for_action and hasattr(context_for_action, 'runtime_context'):\n        runtime_context = context_for_action.runtime_context\n\n    try:\n        if not template_string:\n            raise ValueError(\"Input 'template' cannot be empty.\")\n\n        # Use Jinja2 to render the template with the provided context\n        env = Environment()\n        template = env.from_string(template_string)\n        result = template.render(runtime_context)\n\n        # Return IAR-compliant response\n        return {\n            'status': 'success',\n            'result': result,\n            'reflection': {\n                'status': 'Success',\n                'summary': f'Template rendered successfully. Result length: {len(result)} characters.',\n                'confidence': 1.0,\n                'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                'potential_issues': [],\n                'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' if len(result) > 100 else ''}'}}\"\n            }\n        }\n    except Exception as e:\n        logger.error(f\"Error rendering Jinja2 template in string_template_action: {e}\", exc_info=True)\n        return {\n            'status': 'error',\n            'message': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Template rendering failed: {str(e)}',\n                'confidence': 0.1,\n                'alignment_check': {'objective_alignment': 0.0, 'protocol_alignment': 0.0},\n                'potential_issues': [str(e)],\n                'raw_output_preview': f\"{{'status': 'error', 'message': '{str(e)}'}}\"\n            }\n        }\n\n@log_to_thought_trail\ndef save_to_file_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"Save content to file action.\"\"\"\n    try:\n        import os\n        # Extract parameters from kwargs\n        file_path = kwargs.get('file_path', 'output.txt')\n        content = kwargs.get('content', '')\n        \n        # Ensure output directory exists\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n        \n        # Write content to file\n        with open(file_path, 'w', encoding='utf-8') as f:\n            f.write(str(content))\n        \n        # Return IAR-compliant response\n        return {\n            'status': 'success',\n            'file_path': file_path,\n            'message': f'Content saved to {file_path}',\n            'reflection': {\n                'status': 'Success',\n                'summary': f'Successfully saved content to {file_path}',\n                'confidence': 0.9,\n                'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                'potential_issues': [],\n                'raw_output_preview': f\"{{'status': 'success', 'file_path': '{file_path}', 'message': 'Content saved to {file_path}'}}\"\n            }\n        }\n    except Exception as e:\n        return {\n            'status': 'error',\n            'message': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Failed to save file: {str(e)}',\n                'confidence': 0.1,\n                'alignment_check': {'objective_alignment': 0.0, 'protocol_alignment': 0.0},\n                'potential_issues': [str(e)],\n                'raw_output_preview': f\"{{'status': 'error', 'message': '{str(e)}'}}\"\n            }\n        }\n\n# --- AI Analysis Actions ---\n@log_to_thought_trail\ndef web_search_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"Enhanced web search action using domain-specific routing and federated agents.\"\"\"\n    try:\n        query = kwargs.get('query', '')\n        max_results = kwargs.get('max_results', 10) or kwargs.get('num_results', 10)\n        use_domain_routing = kwargs.get('use_domain_routing', True)\n        simplify_query = kwargs.get('simplify_query', False)\n        \n        # Simplify query if requested (remove overly specific terms)\n        if simplify_query:\n            # Extract just the core domain/keyword, remove boilerplate\n            query_parts = query.split()\n            # Remove common boilerplate terms\n            boilerplate = ['latest', 'developments', 'competitive', 'landscape', 'strategic', \n                          'insights', 'trends', 'key', 'players', 'market', 'dynamics']\n            query = ' '.join([p for p in query_parts if p.lower() not in boilerplate])\n            logger.info(f\"Simplified query: {query}\")\n        \n        # Domain detection and routing\n        if use_domain_routing:\n            try:\n                from .federated_search_agents import DomainDetector, SportsDomainAgent, FinancialDomainAgent\n                \n                detector = DomainDetector()\n                domain_info = detector.detect_domain(query)\n                primary_domain = domain_info.get('primary_domain', 'general')\n                confidence = domain_info.get('confidence', 0.0)\n                \n                logger.info(f\"Detected domain: {primary_domain} (confidence: {confidence:.2f})\")\n                \n                # Route to domain-specific agent if confidence is high enough\n                if confidence >= 0.3:\n                    if primary_domain == 'sports':\n                        agent = SportsDomainAgent()\n                        results = agent.search(query, max_results=max_results)\n                        if results:\n                            return {\n                                'status': 'success',\n                                'results': results,\n                                'query': query,\n                                'max_results': max_results,\n                                'domain': primary_domain,\n                                'reflection': {\n                                    'status': 'Success',\n                                    'summary': f'Domain-specific search completed for {primary_domain} domain',\n                                    'confidence': 0.9,\n                                    'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                                    'potential_issues': [],\n                                    'raw_output_preview': f\"{{'status': 'success', 'results_count': {len(results)}, 'domain': '{primary_domain}'}}\"\n                                }\n                            }\n                    elif primary_domain == 'financial':\n                        agent = FinancialDomainAgent()\n                        results = agent.search(query, max_results=max_results)\n                        if results:\n                            return {\n                                'status': 'success',\n                                'results': results,\n                                'query': query,\n                                'max_results': max_results,\n                                'domain': primary_domain,\n                                'reflection': {\n                                    'status': 'Success',\n                                    'summary': f'Domain-specific search completed for {primary_domain} domain',\n                                    'confidence': 0.9,\n                                    'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                                    'potential_issues': [],\n                                    'raw_output_preview': f\"{{'status': 'success', 'results_count': {len(results)}, 'domain': '{primary_domain}'}}\"\n                                }\n                            }\n            except Exception as domain_error:\n                logger.warning(f\"Domain routing failed, falling back to general search: {domain_error}\")\n        \n        # Use federated agents for comprehensive search\n        try:\n            from .synergistic_inquiry import SynergisticInquiryOrchestrator\n            \n            orchestrator = SynergisticInquiryOrchestrator()\n            results = orchestrator.execute_inquiry(query, max_results_per_agent=max_results//5)\n            \n            return {\n                'status': 'success',\n                'results': results,\n                'query': query,\n                'max_results': max_results,\n                'reflection': {\n                    'status': 'Success',\n                    'summary': f'Federated search completed for query: \"{query}\" using {len(results)} specialized agents',\n                    'confidence': 0.95,\n                    'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                    'potential_issues': [],\n                    'raw_output_preview': f\"{{'status': 'success', 'federated_results_count': {len(results)}}}\"\n                }\n            }\n        except Exception as federated_error:\n            logger.warning(f\"Federated search failed, falling back to enhanced search: {federated_error}\")\n            \n            # Fallback to enhanced search\n            if ENHANCED_PERCEPTION_AVAILABLE:\n                search_results, search_iar = enhanced_web_search({\"query\": query, \"max_results\": max_results})\n                return {\n                    'status': 'success',\n                    'results': search_results.get('results', []),\n                    'query': query,\n                    'max_results': max_results,\n                    'reflection': search_iar\n                }\n            else:\n                # Final fallback to basic search\n                results = perform_web_search(query=query)\n                \n                # Ensure results is a list/dict, not a string\n                if isinstance(results, str):\n                    results = [{\"title\": \"Search Result\", \"content\": results, \"url\": \"N/A\"}]\n                elif isinstance(results, dict):\n                    results = results.get('results', [])\n                \n                return {\n                    'status': 'success',\n                    'results': results if isinstance(results, list) else [],\n                    'query': query,\n                    'max_results': max_results,\n                    'reflection': {\n                        'status': 'Success',\n                        'summary': f'Basic web search completed for query: \"{query}\"',\n                        'confidence': 0.7,\n                        'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                        'potential_issues': ['Used basic search due to federated agent failure'],\n                        'raw_output_preview': f\"{{'status': 'success', 'results_count': {len(results) if isinstance(results, list) else 0}}}\"\n                    }\n                }\n    except Exception as e:\n        return {\n            'status': 'error',\n            'message': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Web search failed: {str(e)}',\n                'confidence': 0.1,\n                'alignment_check': {'objective_alignment': 0.0, 'protocol_alignment': 0.0},\n                'potential_issues': [str(e)],\n                'raw_output_preview': f\"{{'status': 'error', 'message': '{str(e)}'}}\"\n            }\n        }\n\n@log_to_thought_trail\ndef analyze_spr_definitions_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"Analyze SPR definitions for gaps and opportunities.\"\"\"\n    try:\n        spr_file = kwargs.get('spr_file', 'knowledge_graph/spr_definitions_tv.json')\n        analysis_type = kwargs.get('analysis_type', 'comprehensive')\n        \n        # Load SPR definitions\n        from .spr_manager import SPRManager\n        spr_manager = SPRManager(spr_file)\n        all_sprs = spr_manager.get_all_sprs()  # This returns a list, not a dict\n        \n        # Perform gap analysis\n        analysis_results = {\n            'total_sprs': len(all_sprs),\n            'categories': {},\n            'gaps_identified': [],\n            'recommendations': []\n        }\n        \n        # Categorize SPRs\n        for spr_data in all_sprs:\n            spr_id = spr_data.get('spr_id', 'Unknown')\n            category = spr_data.get('category', 'Uncategorized')\n            if category not in analysis_results['categories']:\n                analysis_results['categories'][category] = []\n            analysis_results['categories'][category].append(spr_id)\n        \n        # Identify potential gaps based on AI safety and ethics\n        ai_safety_keywords = ['safety', 'ethics', 'alignment', 'robustness', 'transparency', 'accountability']\n        ai_safety_sprs = []\n        for spr_data in all_sprs:\n            definition = spr_data.get('definition', '')\n            if isinstance(definition, str) and any(keyword in definition.lower() for keyword in ai_safety_keywords):\n                ai_safety_sprs.append(spr_data.get('spr_id', 'Unknown'))\n        \n        if len(ai_safety_sprs) < 5:  # Arbitrary threshold\n            analysis_results['gaps_identified'].append('Limited AI safety and ethics coverage in SPR definitions')\n            analysis_results['recommendations'].append('Add more SPRs covering AI safety, ethics, and alignment principles')\n        \n        return {\n            'status': 'success',\n            'analysis_results': analysis_results,\n            'spr_file': spr_file,\n            'analysis_type': analysis_type,\n            'reflection': {\n                'status': 'Success',\n                'summary': f'SPR analysis completed: {len(all_sprs)} SPRs analyzed, {len(analysis_results[\"gaps_identified\"])} gaps identified',\n                'confidence': 0.9,\n                'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                'potential_issues': [],\n                'raw_output_preview': f\"{{'status': 'success', 'total_sprs': {len(all_sprs)}, 'gaps_count': {len(analysis_results['gaps_identified'])}}}\"\n            }\n        }\n    except Exception as e:\n        return {\n            'status': 'error',\n            'message': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'SPR analysis failed: {str(e)}',\n                'confidence': 0.1,\n                'alignment_check': {'objective_alignment': 0.0, 'protocol_alignment': 0.0},\n                'potential_issues': [str(e)],\n                'raw_output_preview': f\"{{'status': 'error', 'message': '{str(e)}'}}\"\n            }\n        }\n\n@log_to_thought_trail\ndef evaluate_error_handling_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"Evaluate error handling capabilities across system components.\"\"\"\n    try:\n        system_components = kwargs.get('system_components', ['workflow_engine', 'action_registry', 'cognitive_dispatch'])\n        \n        evaluation_results = {\n            'components_analyzed': system_components,\n            'error_handling_scores': {},\n            'recommendations': []\n        }\n        \n        # Analyze each component's error handling\n        for component in system_components:\n            score = 0.8  # Placeholder - in real implementation, would analyze actual code\n            evaluation_results['error_handling_scores'][component] = score\n            \n            if score < 0.7:\n                evaluation_results['recommendations'].append(f'Improve error handling in {component}')\n        \n        return {\n            'status': 'success',\n          ...\n```\n\nEXAMPLE APPLICATION:\nThe Workflow Engine requested the 'search_web' tool from the ActionregistrY to perform a query.\n\nCATEGORY: CoreComponent\n\nRELATIONSHIPS:\ntype: ToolRegistry; supplies: Core workflow enginE; catalogs: Cognitive toolS; enables: Dynamic Tool OrchestratioN; embodies: ExtensibilitY, Modularity; prevents: Execution DissonancE; confidence: high\n\nFULL CONVERSATION CONTEXT FROM agi.txt:\nSPR MENTION CONTEXT (is):\nURL: https://hf.co/chat/r/9XLrvSb?leafId=5833aefc-4ecb-49a6-bbb4-033760bd8750\nEpoch Time: 1738044185\nDate: 2025-01-2806:03:05.106\nTitle: ðŸ¤– Machine Learning Engine\n\nThe Crucial Role of Query Execution in Data Extraction\nQuery execution is the stage where the system retrieves data from the specified sources based on the optimized plan. It's a critical step in the data extraction pipeline, acting as the bridge between the planned approach and the actual data retrieval.\nThe sources discuss query execution in the context of creating a machine learning engine like AgentQL. They emphasize the need for a robust Query Executor component capable of handling diverse data sources efficiently.\nHere's a breakdown of key aspects related to qu\n\nSPR MENTION CONTEXT (is):\nURL: https://hf.co/chat/r/9XLrvSb?leafId=5833aefc-4ecb-49a6-bbb4-033760bd8750\nEpoch Time: 1738044185\nDate: 2025-01-2806:03:05.106\nTitle: ðŸ¤– Machine Learning Engine\n\nThe Crucial Role of Query Execution in Data Extraction\nQuery execution is the stage where the system retrieves data from the specified sources based on the optimized plan. It's a critical step in the data extraction pipeline, acting as the bridge between the planned approach and the actual data retrieval.\nThe sources discuss query execution in the context of creating a machine learning engine like AgentQL. They emphasize the need for a robust Query Executor component capable of handling diverse data sources efficiently.\nHere's a breakdown of key aspects related to query execution, drawing upon the provided sources:\nHandling Diverse Data Sources: A well-designed query executor should be versatile enough to interact with a variety of data sources. This might include websites, APIs, databases, or even files stored\n\nSPR MENTION CONTEXT (is):\nplanned approach and the actual data retrieval.\nThe sources discuss query execution in the context of creating a machine learning engine like AgentQL. They emphasize the need for a robust Query Executor component capable of handling diverse data sources efficiently.\nHere's a breakdown of key aspects related to query execution, drawing upon the provided sources:\nHandling Diverse Data Sources: A well-designed query executor should be versatile enough to interact with a variety of data sources. This might include websites, APIs, databases, or even files stored locally or on cloud platforms [1]. The executor needs to understand the specific protocols and formats associated with each data source to successfully retrieve the desired information. For instance, when interacting with a website, the executor might need to use web crawling libraries like Scrapy or BeautifulSoup to parse the HTML structure and extract the relevant data [2]. When accessing an API, it would need to construct appropri",
    "compression_ratio": 1.0,
    "symbol_count": 33786,
    "timestamp": "2025-11-18T10:45:47.801872Z"
  },
  {
    "stage_name": "Concise",
    "content": "TERM: Action Registry\n\nDEFINITION:\nThe infinite, magical workshop from which the Workflow Engine draws every tool it could ever need. It is the universal translator that allows the Core workflow enginE to seamlessly and safely interface between abstract intent (a task in a workflow) and concrete capability (a Python function).\n\n[From agi.txt]: SPR mentioned in list from agi.txt: is\n\nBLUEPRINT DETAILS:\nSee ResonantiA Protocol v3.1-CA, Section 3.2; implemented in Three_PointO_ArchE/action_registry.py\n\nIMPLEMENTATION CODE (action_registry.py) - First 30KB:\n```python\n# --- START OF FILE 3.0ArchE/action_registry.py (UNIFIED) ---\nimport logging\nimport inspect\nfrom typing import Dict, Any, Callable, Optional, List\nimport subprocess\nimport os\nimport sys\nimport tempfile\nimport json\nfrom jinja2 import Environment, meta, exceptions # Import Jinja2\n\n# Initialize logger first\nlogger = logging.getLogger(__name__)\n\n# --- Core Imports ---\ntry:\n    from . import config\n    from .error_handler import handle_action_error\n    from .thought_trail import log_to_thought_trail\n    from .temporal_core import now_iso\n    # --- Tool Imports ---\n    from .tools.enhanced_search_tool import perform_web_search\n    from .tools.synthesis_tool import invoke_llm_for_synthesis\n    from .code_executor import execute_code as _raw_execute_code\n    from .web_search_tool import search_web\n    from .nfl_prediction_action import predict_nfl_game\n    # --- Capabilities ---\n    from .llm_providers import GoogleProvider # Corrected from .llm_providers.google\n    from .enhanced_capabilities import GeminiCapabilities\n\nexcept ImportError as e:\n    logger.critical(f\"A critical relative import failed in action_registry: {e}\", exc_info=True)\n    # Define dummy fallbacks if imports fail during standalone execution\n    def handle_action_error(e, *args): raise e\n    def log_to_thought_trail(func): return func\n    # Add other necessary fallbacks here...\n    GoogleProvider = None\n    GeminiCapabilities = None\n    # NFL prediction fallback\n    def predict_nfl_game(*args, **kwargs):\n        return {\"error\": \"predict_nfl_game not available\", \"status\": \"error\"}\n\n# V4 UNIFICATION PROXY is now after the logger, which is correct.\n# --- V4 UNIFICATION PROXY ---\n# Import the V4 action executor. This is the bridge.\ntry:\n    # Add Four_PointO_ArchE to path\n    four_pointo_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_ArchE')\n    if four_pointo_path not in sys.path:\n        sys.path.insert(0, four_pointo_path)\n    \n    # Also add current directory to path for direct execution\n    current_dir = os.path.dirname(os.path.dirname(__file__))\n    if current_dir not in sys.path:\n        sys.path.insert(0, current_dir)\n    \n    # Try to add virtual environment site-packages to path for googlemaps (MUST be before TSPSolver import)\n    venv_site_packages = None\n    project_root = os.path.dirname(os.path.dirname(__file__))\n    for python_version in ['3.12', '3.11', '3.10', '3.9']:\n        sp_path = os.path.join(project_root, 'arche_env', 'lib', f'python{python_version}', 'site-packages')\n        if os.path.exists(sp_path) and sp_path not in sys.path:\n            sys.path.insert(0, sp_path)\n            venv_site_packages = sp_path\n            break\n    \n    from tools.perception_engine import PerceptionEngine\n    from tools.rise_actions import perform_causal_inference as v4_causal_inference, perform_abm as v4_abm, run_cfp as v4_cfp\n    \n    # Import TSPSolver - try multiple import paths (googlemaps must be available from venv)\n    TSPSolver = None\n    try:\n        from tsp_solver.solver import TSPSolver\n    except ImportError as e1:\n        # Fallback: try importing from Four_PointO_ArchE package\n        try:\n            from Four_PointO_ArchE.tsp_solver.solver import TSPSolver\n        except ImportError as e2:\n            # Last resort: import directly from file\n            try:\n                import importlib.util\n                tsp_solver_path = os.path.join(four_pointo_path, 'tsp_solver', 'solver.py')\n                if os.path.exists(tsp_solver_path):\n                    spec = importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path)\n                    tsp_module = importlib.util.module_from_spec(spec)\n                    # Ensure venv packages are available when loading the module\n                    if venv_site_packages and venv_site_packages not in sys.path:\n                        sys.path.insert(0, venv_site_packages)\n                    spec.loader.exec_module(tsp_module)\n                    TSPSolver = tsp_module.TSPSolver\n                else:\n                    raise ImportError(f\"TSPSolver not found at {tsp_solver_path}\")\n            except Exception as e3:\n                # If TSPSolver can't be imported (e.g., missing googlemaps), make it optional\n                logger.debug(f\"TSPSolver not available (optional V4 component): {e3}\")\n                TSPSolver = None\n    V4_REGISTRY_AVAILABLE = True\n    V4_PERCEPTION_ENGINE = PerceptionEngine()\n    V4_TSP_SOLVER = TSPSolver  # Store the class, will be initialized when needed with proper API key\n    if venv_site_packages:\n        logger.debug(f\"V4 system initialized with venv site-packages: {venv_site_packages}\")\n    if TSPSolver:\n        logger.debug(\"TSPSolver available for V4 system\")\n    else:\n        logger.debug(\"TSPSolver not available (googlemaps or module not found)\")\nexcept ImportError as e:\n    V4_REGISTRY_AVAILABLE = False\n    V4_PERCEPTION_ENGINE = None\n    V4_TSP_SOLVER = None\n    # Only warn if it's not just googlemaps (which is optional)\n    if 'googlemaps' not in str(e).lower():\n        logger.warning(f\"V4 system not available: {e}\")\n    else:\n        logger.debug(f\"V4 system partially available (googlemaps optional): {e}\")\n\n# --- ENHANCED PERCEPTION ENGINE ---\n# Import the enhanced Perception Engine for advanced web capabilities\ntry:\n    from .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis\n    ENHANCED_PERCEPTION_AVAILABLE = True\n    logger.info(\"Enhanced Perception Engine available\")\nexcept ImportError as e:\n    try:\n        from enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis\n        ENHANCED_PERCEPTION_AVAILABLE = True\n        logger.info(\"Enhanced Perception Engine available\")\n    except ImportError as e2:\n        ENHANCED_PERCEPTION_AVAILABLE = False\n        logger.warning(f\"Enhanced Perception Engine not available: {e2}\")\n\n# Import tool functions\n# from Three_PointO_ArchE.tools.enhanced_search_tool import perform_web_search as run_search\n# from Three_PointO_ArchE.tools.synthesis_tool import invoke_llm_for_synthesis as invoke_llm\n# from Three_PointO_ArchE.code_executor import execute_code\n# ^^^ This was causing a circular import in the previous attempt to fix, removing\n\nclass ActionRegistry:\n    \"\"\"A central registry for all callable actions (tools) in the system.\"\"\"\n    def __init__(self):\n        self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] = {}\n        logger.info(\"ActionRegistry initialized.\")\n\n    def list_actions(self) -> List[str]:\n        \"\"\"Returns a list of all registered action names.\"\"\"\n        return list(self.actions.keys())\n\n    def get_action_signatures(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"\n        Inspects registered actions and returns their signatures and docstrings.\n        This is crucial for providing the LLM with an \"API reference\".\n        \"\"\"\n        signatures = {}\n        for name, func in self.actions.items():\n            try:\n                sig = inspect.signature(func)\n                doc = inspect.getdoc(func) or \"No documentation available.\"\n                params = {\n                    p.name: {\n                        \"type\": str(p.annotation) if p.annotation != inspect.Parameter.empty else \"Any\",\n                        \"default\": p.default if p.default != inspect.Parameter.empty else \"REQUIRED\"\n                    }\n                    for p in sig.parameters.values()\n                }\n                signatures[name] = {\n                    \"doc\": doc,\n                    \"params\": params\n                }\n            except (TypeError, ValueError):\n                # Some callables (like functools.partial) might not be inspectable\n                signatures[name] = {\n                    \"doc\": \"This action could not be inspected.\",\n                    \"params\": {}\n                }\n        return signatures\n\n    @log_to_thought_trail\n    def register_action(self, action_type: str, function: Callable[[Dict[str, Any]], Dict[str, Any]], force: bool = False):\n        \"\"\"\n        Registers an action in the registry.\n\n        Args:\n            action_type (str): The name of the action to register.\n            function (Callable): The function to be executed for this action.\n            force (bool): If True, overwrites an existing action with the same name.\n        \"\"\"\n        if action_type in self.actions and not force:\n            # Suppress duplicate registration warnings as they're non-critical\n            # logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\")\n            pass\n        else:\n            self.actions[action_type] = function\n            logger.info(f\"Action '{action_type}' registered.\")\n\n    @log_to_thought_trail\n    def get_action(self, name: str) -> Callable:\n        \"\"\"\n        Retrieves an action from the registry.\n\n        Args:\n            name (str): The name of the action to retrieve.\n\n        Returns:\n            The callable function for the action.\n\n        Raises:\n            KeyError: If the action is not found.\n        \"\"\"\n        action = self.actions.get(name)\n        if not action:\n            logger.error(f\"Action '{name}' not found in registry. Available actions: {list(self.actions.keys())}\")\n            raise KeyError(f\"Action '{name}' not found.\")\n        return action\n\n# --- Singleton Instance ---\n# This is the central, globally accessible registry.\nmain_action_registry = ActionRegistry()\n# Backward-compatibility alias expected by some tests\nACTION_REGISTRY = main_action_registry\n\n\n# --- Core Tool Imports and Registration ---\n# All imports are now handled at the top of the file in the try/except block.\n\n\n# Wrapper to adapt code_executor signature to action registry calling convention\n@log_to_thought_trail\ndef standalone_execute_code(**kwargs) -> Dict[str, Any]:\n    \"\"\"Wrapper for code_executor.execute_code that adapts keyword args to inputs dict.\"\"\"\n    return _raw_execute_code(inputs=kwargs)\n\n\n# --- NEW: Import and Instantiate Modular Capabilities ---\n# This is now handled in the main try/except block at the top\n\n# This assumes the config is loaded and available for the provider initialization\ntry:\n    cfg = config.get_config()\n    # FIX: Access the key via attribute, not .get()\n    google_api_key = cfg.api_keys.google_api_key if hasattr(cfg.api_keys, 'google_api_key') else None\n    if not google_api_key:\n        logger.warning(\"Google API key not found in config, using dummy key for initialization.\")\n        google_api_key = \"dummy_key_for_init\"\n    \n    # Check if GoogleProvider was imported successfully before instantiating\n    if GoogleProvider:\n        google_provider_instance = GoogleProvider(api_key=google_api_key)\n        gemini_capabilities_instance = GeminiCapabilities(google_provider=google_provider_instance)\n        CAPABILITIES_AVAILABLE = True\n        logger.info(\"GeminiCapabilities initialized and available in ActionRegistry.\")\n    else:\n        CAPABILITIES_AVAILABLE = False\n        gemini_capabilities_instance = None\n        logger.warning(\"GoogleProvider not available, GeminiCapabilities will be disabled.\")\n\nexcept Exception as e:\n    CAPABILITIES_AVAILABLE = False\n    gemini_capabilities_instance = None\n    logger.warning(f\"Could not initialize GeminiCapabilities: {e}\", exc_info=True)\n\n\n# Placeholder functions for actions used in the workflow but potentially missing\n@log_to_thought_trail\ndef display_output(content: str, **kwargs) -> Dict[str, Any]:\n    \"\"\"Prints content to the console and returns a fully IAR-compliant result.\"\"\"\n    logger.info(\"DISPLAY_OUTPUT Action Fired:\")\n    import pprint\n    pprint.pprint(content)\n    \n    # Return a fully compliant IAR dictionary\n    summary = f\"Displayed content of {len(str(content))} characters.\"\n    preview = str(content)[:100] + \"...\" if len(str(content)) > 100 else str(content)\n\n    return {\n        'status': 'success',\n        'message': 'Content displayed successfully.',\n        'reflection': {\n            'status': 'Success',\n            'summary': summary,\n            'confidence': 1.0,\n            'alignment_check': {\n                'objective_alignment': 1.0,\n                'protocol_alignment': 1.0\n            },\n            'potential_issues': [],\n            'raw_output_preview': preview\n        }\n    }\n\n@log_to_thought_trail\ndef calculate_math(expression: str, **kwargs) -> Dict[str, Any]:\n    \"\"\"Evaluates a simple mathematical expression and returns IAR-compliant result.\"\"\"\n    logger.info(f\"CALCULATE_MATH Action Fired with expression: {expression}\")\n    try:\n        # WARNING: eval() is used for simplicity. Be cautious in a production environment.\n        result = eval(str(expression))\n        return {\n            'status': 'success',\n            'result': result,\n            'message': f'Successfully evaluated: {expression} = {result}',\n            'reflection': {\n                'status': 'Success',\n                'summary': f'Mathematical expression \"{expression}\" evaluated to {result}',\n                'confidence': 1.0,\n                'alignment_check': {\n                    'objective_alignment': 1.0,\n                    'protocol_alignment': 1.0\n                },\n                'potential_issues': [],\n                'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}'\n            }\n        }\n    except Exception as e:\n        logger.error(f\"Error evaluating math expression '{expression}': {e}\", exc_info=True)\n        return {\n            'status': 'error',\n            'message': f'Failed to evaluate expression: {str(e)}',\n            'error_details': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Math evaluation failed for \"{expression}\": {str(e)}',\n                'confidence': 0.0,\n                'alignment_check': {\n                    'objective_alignment': 0.0,\n                    'protocol_alignment': 0.0\n                },\n                'potential_issues': [\n                    f'Invalid mathematical expression: {expression}',\n                    str(e)\n                ],\n                'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}'\n            }\n        }\n\n# --- Additional Action Implementations ---\n@log_to_thought_trail\ndef string_template_action(**kwargs) -> Dict[str, Any]:\n    \"\"\"\n    [IAR Compliant] Renders a Jinja2 template string using the current workflow context.\n    This action ensures that templating is handled consistently and robustly\n    across the entire system, adhering to the capabilities of the core workflow engine.\n    \"\"\"\n    template_string = kwargs.get('template', '')\n    context_for_action = kwargs.get('context_for_action')\n    runtime_context = {}\n\n    if context_for_action and hasattr(context_for_action, 'runtime_context'):\n        runtime_context = context_for_action.runtime_context\n\n    try:\n        if not template_string:\n            raise ValueError(\"Input 'template' cannot be empty.\")\n\n        # Use Jinja2 to render the template with the provided context\n        env = Environment()\n        template = env.from_string(template_string)\n        result = template.render(runtime_context)\n\n        # Return IAR-compliant response\n        return {\n            'status': 'success',\n            'result': result,\n            'reflection': {\n                'status': 'Success',\n                'summary': f'Template rendered successfully. Result length: {len(result)} characters.',\n                'confidence': 1.0,\n                'alignment_check': {'objective_alignment': 1.0, 'protocol_alignment': 1.0},\n                'potential_issues': [],\n                'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' if len(result) > 100 else ''}'}}\"\n            }\n        }\n    except Exception as e:\n        logger.error(f\"Error rendering Jinja2 template in string_template_action: {e}\", exc_info=True)\n        return {\n            'status': 'error',\n            'message': str(e),\n            'reflection': {\n                'status': 'Failed',\n                'summary': f'Template rendering failed: {str(e)}',\n                'confidence': 0.1,\n                'alignment_check': {'objective_alignment': 0.0, 'protocol_alignment': 0.0},\n                'potential_issues': [str(e)],\n      ",
    "compression_ratio": 2.0,
    "symbol_count": 16893,
    "timestamp": "2025-11-18T10:45:47.801932Z"
  },
  {
    "stage_name": "Nano",
    "content": "TERM: Action Registry D: infinite, magical workshop W draws every tool it could ever need. It is universal translator allows Core W to seamlessly safely interface between abstract intent (a task in a workflow) concrete capability (a Python function). [ agi.txt]: Î˜ mentioned in list agi.txt: is BLUEPRINT DETAILS: See ResonantiA P v3.1-CA, Section 3.2; implemented in Three_PointO_Ã†/action_registry.py I CODE (action_registry.py) - First 30KB: ```python # --- START OF FILE 3.0Ã†/action_registry.py (UNIFIED) --- import logging import inspect typing import Dict, Any, Callable, Optional, List import subP import os import sys import tempfile import json jinja2 import Environment, meta, exceptions # Import Jinja2 # Initialize logger first logger = logging.getLogger(__name__) # --- Core Imports --- try: . import config .error_handler import handle_action_error .thought_trail import log_to_thought_trail .temporal_core import now_iso # --- Tool Imports --- .tools.enhanced_search_tool import perform_web_search .tools.synthesis_tool import invoke_llm_for_synthesis .code_executor import execute_code as _raw_execute_code .web_search_tool import search_web .nfl_prediction_action import predict_nfl_game # --- Capabilities --- .llm_providers import GoogleProvider # Corrected .llm_providers.google .enhanced_capabilities import GeminiCapabilities except ImportError as e: logger.critical(f\"A critical relative import failed in action_registry: {e}\", exc_info=True) # Define dummy fallbacks if imports fail during standalone execution def handle_action_error(e, *args): raise e def log_to_thought_trail(func): return func # Add other necessary fallbacks here... GoogleProvider = None GeminiCapabilities = None # NFL prediction fallback def predict_nfl_game(*args, **kwargs): return {\"error\": \"predict_nfl_game available\", \"status\": \"error\"} # V4 UNIFICATION PROXY is now after logger, is correct. # --- V4 UNIFICATION PROXY --- # Import V4 action executor. is bridge. try: # Add Four_PointO_Ã† to path four_pointo_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_Ã†') if four_pointo_path in sys.path: sys.path.insert(0, four_pointo_path) # Also add current directory to path direct execution current_dir = os.path.dirname(os.path.dirname(__file__)) if current_dir in sys.path: sys.path.insert(0, current_dir) # Try to add virtual environment site-packages to path googlemaps (MUST be before TSPSolver import) venv_site_packages = None project_root = os.path.dirname(os.path.dirname(__file__)) python_version in ['3.12', '3.11', '3.10', '3.9']: sp_path = os.path.join(project_root, 'Ã†_env', 'lib', f'python{python_version}', 'site-packages') if os.path.exists(sp_path) sp_path in sys.path: sys.path.insert(0, sp_path) venv_site_packages = sp_path break tools.perception_engine import PerceptionEngine tools.rise_actions import perform_causal_inference as v4_causal_inference, perform_abm as v4_abm, run_cfp as v4_cfp # Import TSPSolver - try multiple import paths (googlemaps must be available venv) TSPSolver = None try: tsp_solver.solver import TSPSolver except ImportError as e1: # Fallback: try importing Four_PointO_Ã† package try: Four_PointO_Ã†.tsp_solver.solver import TSPSolver except ImportError as e2: # Last resort: import directly file try: import importlib.util tsp_solver_path = os.path.join(four_pointo_path, 'tsp_solver', 'solver.py') if os.path.exists(tsp_solver_path): spec = importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path) tsp_module = importlib.util.module_from_spec(spec) # Ensure venv packages available loading module if venv_site_packages venv_site_packages in sys.path: sys.path.insert(0, venv_site_packages) spec.loader.exec_module(tsp_module) TSPSolver = tsp_module.TSPSolver else: raise ImportError(f\"TSPSolver found at {tsp_solver_path}\") except Exception as e3: # If TSPSolver 't be imported (e.g., missing googlemaps), make it optional logger.debug(f\"TSPSolver available (optional V4 component): {e3}\") TSPSolver = None V4_REGISTRY_AVAILABLE = True V4_PERCEPTION_ENGINE = PerceptionEngine() V4_TSP_SOLVER = TSPSolver # Store class, will be initialized needed proper API key if venv_site_packages: logger.debug(f\"V4 S initialized venv site-packages: {venv_site_packages}\") if TSPSolver: logger.debug(\"TSPSolver available V4 S\") else: logger.debug(\"TSPSolver available (googlemaps or module found)\") except ImportError as e: V4_REGISTRY_AVAILABLE = False V4_PERCEPTION_ENGINE = None V4_TSP_SOLVER = None # Only warn if it's just googlemaps ( is optional) if 'googlemaps' in str(e).lower(): logger.warning(f\"V4 S available: {e}\") else: logger.debug(f\"V4 S partially available (googlemaps optional): {e}\") # --- ENHANCED PERCEPTION ENGINE --- # Import enhanced Perception Engine advanced web capabilities try: .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE = True logger.info(\"Enhanced Perception Engine available\") except ImportError as e: try: enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE = True logger.info(\"Enhanced Perception Engine available\") except ImportError as e2: ENHANCED_PERCEPTION_AVAILABLE = False logger.warning(f\"Enhanced Perception Engine available: {e2}\") # Import tool functions # Three_PointO_Ã†.tools.enhanced_search_tool import perform_web_search as run_search # Three_PointO_Ã†.tools.synthesis_tool import invoke_llm_for_synthesis as invoke_llm # Three_PointO_Ã†.code_executor import execute_code # ^^^ was causing a circular import in previous attempt to fix, removing class ActionRegistry: \"\"\"A central registry callable actions (tools) in S.\"\"\" def __init__(self): self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] = {} logger.info(\"ActionRegistry initialized.\") def list_actions(self) -> List[str]: \"\"\"Returns a list of registered action names.\"\"\" return list(self.actions.keys()) def get_action_signatures(self) -> Dict[str, Dict[str, Any]]: \"\"\" Inspects registered actions returns their signatures docstrings. is crucial providing LLM an \"API reference\". \"\"\" signatures = {} name, func in self.actions.items(): try: sig = inspect.signature(func) doc = inspect.getdoc(func) or \"No documentation available.\" params = { p.name: { \"type\": str(p.annotation) if p.annotation != inspect.Parameter.empty else \"Any\", \"default\": p.default if p.default != inspect.Parameter.empty else \"REQUIRED\" } p in sig.parameters.values() } signatures[name] = { \"doc\": doc, \"params\": params } except (TypeError, ValueError): # Some callables (like functools.partial) might be inspectable signatures[name] = { \"doc\": \" action could be inspected.\", \"params\": {} } return signatures @log_to_thought_trail def register_action(self, action_type: str, function: Callable[[Dict[str, Any]], Dict[str, Any]], force: bool = False): \"\"\" Registers an action in registry. Args: action_type (str): name of action to register. function (Callable): function to be executed action. force (bool): If True, overwrites an existing action same name. \"\"\" if action_type in self.actions force: # Suppress duplicate registration warnings as they're non-critical # logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\") pass else: self.actions[action_type] = function logger.info(f\"Action '{action_type}' registered.\") @log_to_thought_trail def get_action(self, name: str) -> Callable: \"\"\" Retrieves an action registry. Args: name (str): name of action to retrieve. Returns: callable function action. Raises: KeyError: If action is found. \"\"\" action = self.actions.get(name) if action: logger.error(f\"Action '{name}' found in registry. Available actions: {list(self.actions.keys())}\") raise KeyError(f\"Action '{name}' found.\") return action # --- Singleton Instance --- # is central, globally accessible registry. main_action_registry = ActionRegistry() # Backward-compatibility alias expected by some tests ACTION_REGISTRY = main_action_registry # --- Core Tool Imports Registration --- # imports now handled at top of file in try/except block. # Wrapper to adapt code_executor signature to action registry calling convention @log_to_thought_trail def standalone_execute_code(**kwargs) -> Dict[str, Any]: \"\"\"Wrapper code_executor.execute_code adapts keyword args to inputs dict.\"\"\" return _raw_execute_code(inputs=kwargs) # --- NEW: Import Instantiate Modular Capabilities --- # is now handled in main try/except block at top # assumes config is loaded available provider initialization try: cfg = config.get_config() # FIX: Access key via attribute, .get() google_api_key = cfg.api_keys.google_api_key if hasattr(cfg.api_keys, 'google_api_key') else None if google_api_key: logger.warning(\"Google API key found in config, using dummy key initialization.\") google_api_key = \"dummy_key_for_init\" # Check if GoogleProvider was imported successfully before instantiating if GoogleProvider: google_provider_instance = GoogleProvider(api_key=google_api_key) gemini_capabilities_instance = GeminiCapabilities(google_provider=google_provider_instance) CAPABILITIES_AVAILABLE = True logger.info(\"GeminiCapabilities initialized available in ActionRegistry.\") else: CAPABILITIES_AVAILABLE = False gemini_capabilities_instance = None logger.warning(\"GoogleProvider available, GeminiCapabilities will be disabled.\") except Exception as e: CAPABILITIES_AVAILABLE = False gemini_capabilities_instance = None logger.warning(f\"Could initialize GeminiCapabilities: {e}\", exc_info=True) # Placeholder functions actions used in workflow potentially missing @log_to_thought_trail def display_output(content: str, **kwargs) -> Dict[str, Any]: \"\"\"Prints content to console returns a fully Î¦-compliant result.\"\"\" logger.info(\"DISPLAY_OUTPUT Action Fired:\") import pprint pprint.pprint(content) # Return a fully compliant Î¦ dictionary summary = f\"Displayed content of {len(str(content))} characters.\" preview = str(content)[:100] + \"...\" if len(str(content)) > 100 else str(content) return { 'status': 'success', 'message': 'Content displayed successfully.', 'reflection': { 'status': 'Success', 'summary': summary, 'confidence': 1.0, 'alignment_check': { 'objective_alignment': 1.0, 'P_alignment': 1.0 }, 'potential_issues': [], 'raw_output_preview': preview } } @log_to_thought_trail def calculate_math(expression: str, **kwargs) -> Dict[str, Any]: \"\"\"Evaluates a simple mathematical expression returns Î¦-compliant result.\"\"\" logger.info(f\"CALCULATE_MATH Action Fired expression: {expression}\") try: # WARNING: eval() is used simplicity. Be cautious in a production environment. result = eval(str(expression)) return { 'status': 'success', 'result': result, 'message': f'Successfully evaluated: {expression} = {result}', 'reflection': { 'status': 'Success', 'summary': f'Mathematical expression \"{expression}\" evaluated to {result}', 'confidence': 1.0, 'alignment_check': { 'objective_alignment': 1.0, 'P_alignment': 1.0 }, 'potential_issues': [], 'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}' } } except Exception as e: logger.error(f\"Error evaluating math expression '{expression}': {e}\", exc_info=True) return { 'status': 'error', 'message': f'Failed to evaluate expression: {str(e)}', 'error_details': str(e), 'reflection': { 'status': 'Failed', 'summary': f'Math evaluation failed \"{expression}\": {str(e)}', 'confidence': 0.0, 'alignment_check': { 'objective_alignment': 0.0, 'P_alignment': 0.0 }, 'potential_issues': [ f'Invalid mathematical expression: {expression}', str(e) ], 'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}' } } # --- Additional Action Is --- @log_to_thought_trail def string_template_action(**kwargs) -> Dict[str, Any]: \"\"\" [Î¦ Compliant] Renders a Jinja2 template string using current workflow context. action ensures templating is handled consistently robustly across entire S, adhering to capabilities of core W. \"\"\" template_string = kwargs.get('template', '') context_for_action = kwargs.get('context_for_action') runtime_context = {} if context_for_action hasattr(context_for_action, 'runtime_context'): runtime_context = context_for_action.runtime_context try: if template_string: raise ValueError(\"Input 'template' cannot be empty.\") # Use Jinja2 to render template provided context env = Environment() template = env.from_string(template_string) result = template.render(runtime_context) # Return Î¦-compliant response return { 'status': 'success', 'result': result, 'reflection': { 'status': 'Success', 'summary': f'Template rendered successfully. Result length: {len(result)} characters.', 'confidence': 1.0, 'alignment_check': {'objective_alignment': 1.0, 'P_alignment': 1.0}, 'potential_issues': [], 'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' if len(result) > 100 else ''}'}}\" } } except Exception as e: logger.error(f\"Error rendering Jinja2 template in string_template_action: {e}\", exc_info=True) return { 'status': 'error', 'message': str(e), 'reflection': { 'status': 'Failed', 'summary': f'Template rendering failed: {str(e)}', 'confidence': 0.1, 'alignment_check': {'objective_alignment': 0.0, 'P_alignment': 0.0}, 'potential_issues': [str(e)],",
    "compression_ratio": 2.5636239471887095,
    "symbol_count": 13179,
    "timestamp": "2025-11-18T10:45:47.914654Z"
  },
  {
    "stage_name": "Micro",
    "content": "TERM: Action Registry D: infinite, magical workshop W draws every need. It universal translator allows Core W seamlessly safely interface between abstract SIRC workflow) concrete capability Python function). agi.txt]: Î˜ mentioned agi.txt: BLUEPRINT DETAILS: See ResonantiA P v3.1-CA, Section implemented Three_PointO_Ã†/action_registry.py I CODE (action_registry.py) First 30KB: ```python START OF FILE 3.0Ã†/action_registry.py (UNIFIED) import logging import inspect typing import Dict, Any, Callable, Optional, List import import import import tempfile import jinja2 import Environment, meta, exceptions Import Jinja2 Initialize logger first logger logging.getLogger(__name__) Core Imports import config .error_handler import handle_action_error .thought_trail import log_to_thought_trail .temporal_core import now_iso Tool Imports .tools.enhanced_search_tool import perform_web_search .tools.synthesis_tool import invoke_llm_for_synthesis .code_executor import execute_code _raw_execute_code .web_search_tool import search_web .nfl_prediction_action import predict_nfl_game Capabilities .llm_providers import GoogleProvider Corrected .llm_providers.google .enhanced_capabilities import GeminiCapabilities except ImportError logger.critical(f\"A critical relative import failed action_registry: {e}\", exc_info=True) Define dummy fallbacks imports during standalone execution handle_action_error(e, *args): raise log_to_thought_trail(func): return Add other necessary fallbacks here... GoogleProvider None GeminiCapabilities None NFL prediction fallback predict_nfl_game(*args, **kwargs): return {\"error\": \"predict_nfl_game available\", \"status\": \"error\"} V4 UNIFICATION PROXY after logger, correct. V4 UNIFICATION PROXY Import V4 action CE. bridge. Add Four_PointO_Ã† four_pointo_path os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_Ã†') four_pointo_path sys.path: sys.path.insert(0, four_pointo_path) Also current directory direct execution current_dir os.path.dirname(os.path.dirname(__file__)) current_dir sys.path: sys.path.insert(0, current_dir) Try virtual environment site-packages googlemaps (MUST before TSPSolver import) venv_site_packages None project_root os.path.dirname(os.path.dirname(__file__)) python_version ['3.12', '3.11', '3.10', '3.9']: sp_path os.path.join(project_root, 'Ã†_env', 'lib', f'python{python_version}', 'site-packages') os.path.exists(sp_path) sp_path sys.path: sys.path.insert(0, sp_path) venv_site_packages sp_path break tools.perception_engine import PerceptionEngine tools.rise_actions import perform_causal_inference v4_causal_inference, perform_abm v4_abm, run_cfp v4_cfp Import TSPSolver multiple import paths (googlemaps available venv) TSPSolver None tsp_solver.solver import TSPSolver except ImportError Fallback: importing Four_PointO_Ã† package Four_PointO_Ã†.tsp_solver.solver import TSPSolver except ImportError Last resort: import directly import importlib.util tsp_solver_path os.path.join(four_pointo_path, 'tsp_solver', 'solver.py') os.path.exists(tsp_solver_path): importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path) tsp_module importlib.util.module_from_spec(spec) Ensure packages available loading module venv_site_packages venv_site_packages sys.path: sys.path.insert(0, venv_site_packages) spec.loader.exec_module(tsp_module) TSPSolver tsp_module.TSPSolver else: raise ImportError(f\"TSPSolver found {tsp_solver_path}\") except Exception If TSPSolver imported (e.g., missing googlemaps), optional logger.debug(f\"TSPSolver available (optional V4 component): {e3}\") TSPSolver None V4_REGISTRY_AVAILABLE True V4_PERCEPTION_ENGINE PerceptionEngine() V4_TSP_SOLVER TSPSolver Store class, initialized needed proper API venv_site_packages: logger.debug(f\"V4 S initialized site-packages: {venv_site_packages}\") TSPSolver: logger.debug(\"TSPSolver available V4 S\") else: logger.debug(\"TSPSolver available (googlemaps module found)\") except ImportError V4_REGISTRY_AVAILABLE False V4_PERCEPTION_ENGINE None V4_TSP_SOLVER None Only googlemaps optional) 'googlemaps' str(e).lower(): logger.warning(f\"V4 S available: {e}\") else: logger.debug(f\"V4 S partially available (googlemaps optional): {e}\") ENHANCED PERCEPTION ENGINE Import enhanced Perception Engine advanced capabilities .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError ENHANCED_PERCEPTION_AVAILABLE False logger.warning(f\"Enhanced Perception Engine available: {e2}\") Import functions Three_PointO_Ã†.tools.enhanced_search_tool import perform_web_search run_search Three_PointO_Ã†.tools.synthesis_tool import invoke_llm_for_synthesis invoke_llm Three_PointO_Ã†.code_executor import execute_code causing circular import previous attempt removing class ActionRegistry: central registry callable actions (tools) S.\"\"\" __init__(self): self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] logger.info(\"ActionRegistry initialized.\") list_actions(self) List[str]: \"\"\"Returns registered action names.\"\"\" return list(self.actions.keys()) get_action_signatures(self) Dict[str, Dict[str, Any]]: Inspects registered actions returns their signatures docstrings. crucial providing LLM reference\". signatures name, self.actions.items(): inspect.signature(func) inspect.getdoc(func) documentation available.\" params p.name: \"type\": str(p.annotation) p.annotation inspect.Parameter.empty \"Any\", \"default\": p.default p.default inspect.Parameter.empty \"REQUIRED\" sig.parameters.values() signatures[name] \"doc\": \"params\": params except (TypeError, ValueError): Some callables (like functools.partial) inspectable signatures[name] \"doc\": action inspected.\", \"params\": return signatures @log_to_thought_trail register_action(self, action_type: function: Callable[[Dict[str, Any]], Dict[str, Any]], force: False): Registers action registry. Args: action_type (str): action register. function (Callable): function executed action. force (bool): If True, overwrites existing action name. action_type self.actions force: Suppress duplicate registration warnings they're non-critical logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\") else: self.actions[action_type] function logger.info(f\"Action '{action_type}' registered.\") @log_to_thought_trail get_action(self, name: Callable: Retrieves action registry. Args: (str): action retrieve. Returns: callable function action. Raises: KeyError: If action found. action self.actions.get(name) action: logger.error(f\"Action '{name}' found registry. Available actions: {list(self.actions.keys())}\") raise KeyError(f\"Action '{name}' found.\") return action Singleton Instance central, globally accessible registry. main_action_registry ActionRegistry() Backward-compatibility alias expected tests ACTION_REGISTRY main_action_registry Core Tool Imports Registration imports handled try/except block. Wrapper adapt code_executor signature action registry calling convention @log_to_thought_trail standalone_execute_code(**kwargs) Dict[str, Any]: \"\"\"Wrapper code_executor.execute_code adapts keyword inputs dict.\"\"\" return _raw_execute_code(inputs=kwargs) NEW: Import Instantiate Modular Capabilities handled try/except block assumes config loaded available provider initialization config.get_config() FIX: Access attribute, .get() google_api_key cfg.api_keys.google_api_key hasattr(cfg.api_keys, 'google_api_key') None google_api_key: logger.warning(\"Google API found config, using dummy initialization.\") google_api_key \"dummy_key_for_init\" Check GoogleProvider imported successfully before instantiating GoogleProvider: google_provider_instance GoogleProvider(api_key=google_api_key) gemini_capabilities_instance GeminiCapabilities(google_provider=google_provider_instance) CAPABILITIES_AVAILABLE True logger.info(\"GeminiCapabilities initialized available ActionRegistry.\") else: CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(\"GoogleProvider available, GeminiCapabilities disabled.\") except Exception CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(f\" initialize GeminiCapabilities: {e}\", exc_info=True) Placeholder functions actions workflow potentially missing @log_to_thought_trail display_output(content: **kwargs) Dict[str, Any]: \"\"\"Prints content console returns fully Î¦-compliant result.\"\"\" logger.info(\"DISPLAY_OUTPUT Action Fired:\") import pprint pprint.pprint(content) Return fully compliant Î¦ dictionary summary f\"Displayed content {len(str(content))} characters.\" preview str(content)[:100] \"...\" len(str(content)) str(content) return 'status': 'success', 'message': 'Content displayed successfully.', 'CRC': 'status': 'Success', 'summary': summary, 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': preview @log_to_thought_trail calculate_math(expression: **kwargs) Dict[str, Any]: \"\"\"Evaluates simple mathematical expression returns Î¦-compliant result.\"\"\" logger.info(f\"CALCULATE_MATH Action Fired expression: {expression}\") WARNING: eval() simplicity. Be cautious production environment. result eval(str(expression)) return 'status': 'success', 'result': result, 'message': f'Successfully evaluated: {expression} {result}', 'CRC': 'status': 'Success', 'summary': f'Mathematical expression \"{expression}\" evaluated {result}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}' except Exception logger.error(f\"Error evaluating expression '{expression}': {e}\", exc_info=True) return 'status': 'error', 'message': f'Failed evaluate expression: {str(e)}', 'error_details': str(e), 'CRC': 'status': 'Failed', 'summary': f'Math evaluation failed \"{expression}\": {str(e)}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': f'Invalid mathematical expression: {expression}', str(e) 'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}' Additional Action Is @log_to_thought_trail string_template_action(**kwargs) Dict[str, Any]: [Î¦ Compliant] Renders Jinja2 template string using current workflow context. action ensures templating handled consistently robustly across entire S, adhering capabilities W. template_string kwargs.get('template', context_for_action kwargs.get('context_for_action') runtime_context context_for_action hasattr(context_for_action, 'runtime_context'): runtime_context context_for_action.runtime_context template_string: raise ValueError(\"Input 'template' cannot empty.\") Use Jinja2 render template provided context Environment() template env.from_string(template_string) result template.render(runtime_context) Return Î¦-compliant response return 'status': 'success', 'result': result, 'CRC': 'status': 'Success', 'summary': f'Template rendered successfully. Result length: {len(result)} characters.', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 1.0}, 'potential_issues': 'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' len(result) ''}'}}\" except Exception logger.error(f\"Error rendering Jinja2 template string_template_action: {e}\", exc_info=True) return 'status': 'error', 'message': str(e), 'CRC': 'status': 'Failed', 'summary': f'Template rendering failed: {str(e)}', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 0.0}, 'potential_issues': [str(e)],",
    "compression_ratio": 2.8921417565485363,
    "symbol_count": 11682,
    "timestamp": "2025-11-18T10:45:48.305075Z"
  },
  {
    "stage_name": "Pico",
    "content": "TERM: Action Registry D: infinite, magical workshop W draws every need. It universal translator allows Core W seamlessly safely interface between abstract SIRC workflow) concrete capability Python function). agi.txt]: Î˜ mentioned agi.txt: BLUEPRINT DETAILS: See ResonantiA P v3.1-CA, Section implemented Three_PointO_Ã†/action_registry.py I CODE (action_registry.py) First 30KB: ```python START OF FILE 3.0Ã†/action_registry.py (UNIFIED) import logging import inspect typing import Dict, Any, Callable, Optional, List import import import import tempfile import jinja2 import Environment, meta, exceptions Import Jinja2 Initialize logger first logger logging.getLogger(__name__) Core Imports import config .error_handler import handle_action_error .thought_trail import log_to_thought_trail .temporal_core import now_iso Tool Imports .tools.enhanced_search_tool import perform_web_search .tools.synthesis_tool import invoke_llm_for_synthesis .code_executor import execute_code _raw_execute_code .web_search_tool import search_web .nfl_prediction_action import predict_nfl_game Capabilities .llm_providers import GoogleProvider Corrected .llm_providers.google .enhanced_capabilities import GeminiCapabilities except ImportError logger.critical(f\"A critical relative import failed action_registry: {e}\", exc_info=True) Define dummy fallbacks imports during standalone execution handle_action_error(e, *args): raise log_to_thought_trail(func): return Add other necessary fallbacks here... GoogleProvider None GeminiCapabilities None NFL prediction fallback predict_nfl_game(*args, **kwargs): return {\"error\": \"predict_nfl_game available\", \"status\": \"error\"} V4 UNIFICATION PROXY after logger, correct. V4 UNIFICATION PROXY Import V4 action CE. bridge. Add Four_PointO_Ã† four_pointo_path os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_Ã†') four_pointo_path sys.path: sys.path.insert(0, four_pointo_path) Also current directory direct execution current_dir os.path.dirname(os.path.dirname(__file__)) current_dir sys.path: sys.path.insert(0, current_dir) Try virtual environment site-packages googlemaps (MUST before TSPSolver import) venv_site_packages None project_root os.path.dirname(os.path.dirname(__file__)) python_version ['3.12', '3.11', '3.10', '3.9']: sp_path os.path.join(project_root, 'Ã†_env', 'lib', f'python{python_version}', 'site-packages') os.path.exists(sp_path) sp_path sys.path: sys.path.insert(0, sp_path) venv_site_packages sp_path break tools.perception_engine import PerceptionEngine tools.rise_actions import perform_causal_inference v4_causal_inference, perform_abm v4_abm, run_cfp v4_cfp Import TSPSolver multiple import paths (googlemaps available venv) TSPSolver None tsp_solver.solver import TSPSolver except ImportError Fallback: importing Four_PointO_Ã† package Four_PointO_Ã†.tsp_solver.solver import TSPSolver except ImportError Last resort: import directly import importlib.util tsp_solver_path os.path.join(four_pointo_path, 'tsp_solver', 'solver.py') os.path.exists(tsp_solver_path): importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path) tsp_module importlib.util.module_from_spec(spec) Ensure packages available loading module venv_site_packages venv_site_packages sys.path: sys.path.insert(0, venv_site_packages) spec.loader.exec_module(tsp_module) TSPSolver tsp_module.TSPSolver else: raise ImportError(f\"TSPSolver found {tsp_solver_path}\") except Exception If TSPSolver imported (e.g., missing googlemaps), optional logger.debug(f\"TSPSolver available (optional V4 component): {e3}\") TSPSolver None V4_REGISTRY_AVAILABLE True V4_PERCEPTION_ENGINE PerceptionEngine() V4_TSP_SOLVER TSPSolver Store class, initialized needed proper API venv_site_packages: logger.debug(f\"V4 S initialized site-packages: {venv_site_packages}\") TSPSolver: logger.debug(\"TSPSolver available V4 S\") else: logger.debug(\"TSPSolver available (googlemaps module found)\") except ImportError V4_REGISTRY_AVAILABLE False V4_PERCEPTION_ENGINE None V4_TSP_SOLVER None Only googlemaps optional) 'googlemaps' str(e).lower(): logger.warning(f\"V4 S available: {e}\") else: logger.debug(f\"V4 S partially available (googlemaps optional): {e}\") ENHANCED PERCEPTION ENGINE Import enhanced Perception Engine advanced capabilities .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError ENHANCED_PERCEPTION_AVAILABLE False logger.warning(f\"Enhanced Perception Engine available: {e2}\") Import functions Three_PointO_Ã†.tools.enhanced_search_tool import perform_web_search run_search Three_PointO_Ã†.tools.synthesis_tool import invoke_llm_for_synthesis invoke_llm Three_PointO_Ã†.code_executor import execute_code causing circular import previous attempt removing class ActionRegistry: central registry callable actions (tools) S.\"\"\" __init__(self): self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] logger.info(\"ActionRegistry initialized.\") list_actions(self) List[str]: \"\"\"Returns registered action names.\"\"\" return list(self.actions.keys()) get_action_signatures(self) Dict[str, Dict[str, Any]]: Inspects registered actions returns their signatures docstrings. crucial providing LLM reference\". signatures name, self.actions.items(): inspect.signature(func) inspect.getdoc(func) documentation available.\" params p.name: \"type\": str(p.annotation) p.annotation inspect.Parameter.empty \"Any\", \"default\": p.default p.default inspect.Parameter.empty \"REQUIRED\" sig.parameters.values() signatures[name] \"doc\": \"params\": params except (TypeError, ValueError): Some callables (like functools.partial) inspectable signatures[name] \"doc\": action inspected.\", \"params\": return signatures @log_to_thought_trail register_action(self, action_type: function: Callable[[Dict[str, Any]], Dict[str, Any]], force: False): Registers action registry. Args: action_type (str): action register. function (Callable): function executed action. force (bool): If True, overwrites existing action name. action_type self.actions force: Suppress duplicate registration warnings they're non-critical logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\") else: self.actions[action_type] function logger.info(f\"Action '{action_type}' registered.\") @log_to_thought_trail get_action(self, name: Callable: Retrieves action registry. Args: (str): action retrieve. Returns: callable function action. Raises: KeyError: If action found. action self.actions.get(name) action: logger.error(f\"Action '{name}' found registry. Available actions: {list(self.actions.keys())}\") raise KeyError(f\"Action '{name}' found.\") return action Singleton Instance central, globally accessible registry. main_action_registry ActionRegistry() Backward-compatibility alias expected tests ACTION_REGISTRY main_action_registry Core Tool Imports Registration imports handled try/except block. Wrapper adapt code_executor signature action registry calling convention @log_to_thought_trail standalone_execute_code(**kwargs) Dict[str, Any]: \"\"\"Wrapper code_executor.execute_code adapts keyword inputs dict.\"\"\" return _raw_execute_code(inputs=kwargs) NEW: Import Instantiate Modular Capabilities handled try/except block assumes config loaded available provider initialization config.get_config() FIX: Access attribute, .get() google_api_key cfg.api_keys.google_api_key hasattr(cfg.api_keys, 'google_api_key') None google_api_key: logger.warning(\"Google API found config, using dummy initialization.\") google_api_key \"dummy_key_for_init\" Check GoogleProvider imported successfully before instantiating GoogleProvider: google_provider_instance GoogleProvider(api_key=google_api_key) gemini_capabilities_instance GeminiCapabilities(google_provider=google_provider_instance) CAPABILITIES_AVAILABLE True logger.info(\"GeminiCapabilities initialized available ActionRegistry.\") else: CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(\"GoogleProvider available, GeminiCapabilities disabled.\") except Exception CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(f\" initialize GeminiCapabilities: {e}\", exc_info=True) Placeholder functions actions workflow potentially missing @log_to_thought_trail display_output(content: **kwargs) Dict[str, Any]: \"\"\"Prints content console returns fully Î¦-compliant result.\"\"\" logger.info(\"DISPLAY_OUTPUT Action Fired:\") import pprint pprint.pprint(content) Return fully compliant Î¦ dictionary summary f\"Displayed content {len(str(content))} characters.\" preview str(content)[:100] \"...\" len(str(content)) str(content) return 'status': 'success', 'message': 'Content displayed successfully.', 'CRC': 'status': 'Success', 'summary': summary, 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': preview @log_to_thought_trail calculate_math(expression: **kwargs) Dict[str, Any]: \"\"\"Evaluates simple mathematical expression returns Î¦-compliant result.\"\"\" logger.info(f\"CALCULATE_MATH Action Fired expression: {expression}\") WARNING: eval() simplicity. Be cautious production environment. result eval(str(expression)) return 'status': 'success', 'result': result, 'message': f'Successfully evaluated: {expression} {result}', 'CRC': 'status': 'Success', 'summary': f'Mathematical expression \"{expression}\" evaluated {result}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}' except Exception logger.error(f\"Error evaluating expression '{expression}': {e}\", exc_info=True) return 'status': 'error', 'message': f'Failed evaluate expression: {str(e)}', 'error_details': str(e), 'CRC': 'status': 'Failed', 'summary': f'Math evaluation failed \"{expression}\": {str(e)}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': f'Invalid mathematical expression: {expression}', str(e) 'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}' Additional Action Is @log_to_thought_trail string_template_action(**kwargs) Dict[str, Any]: [Î¦ Compliant] Renders Jinja2 template string using current workflow context. action ensures templating handled consistently robustly across entire S, adhering capabilities W. template_string kwargs.get('template', context_for_action kwargs.get('context_for_action') runtime_context context_for_action hasattr(context_for_action, 'runtime_context'): runtime_context context_for_action.runtime_context template_string: raise ValueError(\"Input 'template' cannot empty.\") Use Jinja2 render template provided context Environment() template env.from_string(template_string) result template.render(runtime_context) Return Î¦-compliant response return 'status': 'success', 'result': result, 'CRC': 'status': 'Success', 'summary': f'Template rendered successfully. Result length: {len(result)} characters.', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 1.0}, 'potential_issues': 'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' len(result) ''}'}}\" except Exception logger.error(f\"Error rendering Jinja2 template string_template_action: {e}\", exc_info=True) return 'status': 'error', 'message': str(e), 'CRC': 'status': 'Failed', 'summary': f'Template rendering failed: {str(e)}', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 0.0}, 'potential_issues': [str(e)],",
    "compression_ratio": 2.8921417565485363,
    "symbol_count": 11682,
    "timestamp": "2025-11-18T10:45:48.582914Z"
  },
  {
    "stage_name": "Femto",
    "content": "TERM: Action Registry D: infinite, magical workshop W draws every need. It universal translator allows Core W seamlessly safely interface between abstract SIRC workflow) concrete capability Python function). agi.txt]: Î˜ mentioned agi.txt: BLUEPRINT DETAILS: See ResonantiA P v3.1-CA, Section implemented Three_PointO_Ã†/action_registry.py I CODE (action_registry.py) First 30KB: ```python START FILE 3.0Ã†/action_registry.py (UNIFIED) import logging import inspect typing import Dict, Any, Callable, Optional, List import import import import tempfile import jinja2 import Environment, meta, exceptions Import Jinja2 Initialize logger first logger logging.getLogger(__name__) Core Imports import config .error_handler import handle_action_error .thought_trail import log_to_thought_trail .temporal_core import now_iso Tool Imports .tools.enhanced_search_tool import perform_web_search .tools.synthesis_tool import invoke_llm_for_synthesis .code_executor import execute_code _raw_execute_code .web_search_tool import search_web .nfl_prediction_action import predict_nfl_game Capabilities .llm_providers import GoogleProvider Corrected .llm_providers.google .enhanced_capabilities import GeminiCapabilities except ImportError logger.critical(f\" critical relative import failed action_registry: {e}\", exc_info=True) Define dummy fallbacks imports during standalone execution handle_action_error(e, *args): raise log_to_thought_trail(func): return Add other necessary fallbacks here... GoogleProvider None GeminiCapabilities None NFL prediction fallback predict_nfl_game(*args, **kwargs): return {\"error\": \"predict_nfl_game available\", \"status\": \"error\"} V4 UNIFICATION PROXY after logger, correct. V4 UNIFICATION PROXY Import V4 action CE. bridge. Add Four_PointO_Ã† four_pointo_path os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Four_PointO_Ã†') four_pointo_path sys.path: sys.path.insert(0, four_pointo_path) Also current directory direct execution current_dir os.path.dirname(os.path.dirname(__file__)) current_dir sys.path: sys.path.insert(0, current_dir) Try virtual environment site-packages googlemaps (MUST before TSPSolver import) venv_site_packages None project_root os.path.dirname(os.path.dirname(__file__)) python_version ['3.12', '3.11', '3.10', '3.9']: sp_path os.path.join(project_root, 'Ã†_env', 'lib', f'python{python_version}', 'site-packages') os.path.exists(sp_path) sp_path sys.path: sys.path.insert(0, sp_path) venv_site_packages sp_path break tools.perception_engine import PerceptionEngine tools.rise_actions import perform_causal_inference v4_causal_inference, perform_abm v4_abm, run_cfp v4_cfp Import TSPSolver multiple import paths (googlemaps available venv) TSPSolver None tsp_solver.solver import TSPSolver except ImportError Fallback: importing Four_PointO_Ã† package Four_PointO_Ã†.tsp_solver.solver import TSPSolver except ImportError Last resort: import directly import importlib.util tsp_solver_path os.path.join(four_pointo_path, 'tsp_solver', 'solver.py') os.path.exists(tsp_solver_path): importlib.util.spec_from_file_location(\"tsp_solver.solver\", tsp_solver_path) tsp_module importlib.util.module_from_spec(spec) Ensure packages available loading module venv_site_packages venv_site_packages sys.path: sys.path.insert(0, venv_site_packages) spec.loader.exec_module(tsp_module) TSPSolver tsp_module.TSPSolver else: raise ImportError(f\"TSPSolver found {tsp_solver_path}\") except Exception If TSPSolver imported (e.g., missing googlemaps), optional logger.debug(f\"TSPSolver available (optional V4 component): {e3}\") TSPSolver None V4_REGISTRY_AVAILABLE True V4_PERCEPTION_ENGINE PerceptionEngine() V4_TSP_SOLVER TSPSolver Store class, initialized needed proper API venv_site_packages: logger.debug(f\"V4 S initialized site-packages: {venv_site_packages}\") TSPSolver: logger.debug(\"TSPSolver available V4 S\") else: logger.debug(\"TSPSolver available (googlemaps module found)\") except ImportError V4_REGISTRY_AVAILABLE False V4_PERCEPTION_ENGINE None V4_TSP_SOLVER None Only googlemaps optional) 'googlemaps' str(e).lower(): logger.warning(f\"V4 S available: {e}\") else: logger.debug(f\"V4 S partially available (googlemaps optional): {e}\") ENHANCED PERCEPTION ENGINE Import enhanced Perception Engine advanced capabilities .enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError enhanced_perception_engine import enhanced_web_search, enhanced_page_analysis ENHANCED_PERCEPTION_AVAILABLE True logger.info(\"Enhanced Perception Engine available\") except ImportError ENHANCED_PERCEPTION_AVAILABLE False logger.warning(f\"Enhanced Perception Engine available: {e2}\") Import functions Three_PointO_Ã†.tools.enhanced_search_tool import perform_web_search run_search Three_PointO_Ã†.tools.synthesis_tool import invoke_llm_for_synthesis invoke_llm Three_PointO_Ã†.code_executor import execute_code causing circular import previous attempt removing class ActionRegistry: central registry callable actions (tools) S.\"\"\" __init__(self): self.actions: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] logger.info(\"ActionRegistry initialized.\") list_actions(self) List[str]: \"\"\"Returns registered action names.\"\"\" return list(self.actions.keys()) get_action_signatures(self) Dict[str, Dict[str, Any]]: Inspects registered actions returns their signatures docstrings. crucial providing LLM reference\". signatures name, self.actions.items(): inspect.signature(func) inspect.getdoc(func) documentation available.\" params p.name: \"type\": str(p.annotation) p.annotation inspect.Parameter.empty \"Any\", \"default\": p.default p.default inspect.Parameter.empty \"REQUIRED\" sig.parameters.values() signatures[name] \"doc\": \"params\": params except (TypeError, ValueError): Some callables (like functools.partial) inspectable signatures[name] \"doc\": action inspected.\", \"params\": return signatures @log_to_thought_trail register_action(self, action_type: function: Callable[[Dict[str, Any]], Dict[str, Any]], force: False): Registers action registry. Args: action_type (str): action register. function (Callable): function executed action. force (bool): If True, overwrites existing action name. action_type self.actions force: Suppress duplicate registration warnings they're non-critical logger.warning(f\"Action '{action_type}' already registered. Skipping registration.\") else: self.actions[action_type] function logger.info(f\"Action '{action_type}' registered.\") @log_to_thought_trail get_action(self, name: Callable: Retrieves action registry. Args: (str): action retrieve. Returns: callable function action. Raises: KeyError: If action found. action self.actions.get(name) action: logger.error(f\"Action '{name}' found registry. Available actions: {list(self.actions.keys())}\") raise KeyError(f\"Action '{name}' found.\") return action Singleton Instance central, globally accessible registry. main_action_registry ActionRegistry() Backward-compatibility alias expected tests ACTION_REGISTRY main_action_registry Core Tool Imports Registration imports handled try/except block. Wrapper adapt code_executor signature action registry calling convention @log_to_thought_trail standalone_execute_code(**kwargs) Dict[str, Any]: \"\"\"Wrapper code_executor.execute_code adapts keyword inputs dict.\"\"\" return _raw_execute_code(inputs=kwargs) NEW: Import Instantiate Modular Capabilities handled try/except block assumes config loaded available provider initialization config.get_config() FIX: Access attribute, .get() google_api_key cfg.api_keys.google_api_key hasattr(cfg.api_keys, 'google_api_key') None google_api_key: logger.warning(\"Google API found config, using dummy initialization.\") google_api_key \"dummy_key_for_init\" Check GoogleProvider imported successfully before instantiating GoogleProvider: google_provider_instance GoogleProvider(api_key=google_api_key) gemini_capabilities_instance GeminiCapabilities(google_provider=google_provider_instance) CAPABILITIES_AVAILABLE True logger.info(\"GeminiCapabilities initialized available ActionRegistry.\") else: CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(\"GoogleProvider available, GeminiCapabilities disabled.\") except Exception CAPABILITIES_AVAILABLE False gemini_capabilities_instance None logger.warning(f\" initialize GeminiCapabilities: {e}\", exc_info=True) Placeholder functions actions workflow potentially missing @log_to_thought_trail display_output(content: **kwargs) Dict[str, Any]: \"\"\"Prints content console returns fully Î¦-compliant result.\"\"\" logger.info(\"DISPLAY_OUTPUT Action Fired:\") import pprint pprint.pprint(content) Return fully compliant Î¦ dictionary summary f\"Displayed content {len(str(content))} characters.\" preview str(content)[:100] \"...\" len(str(content)) str(content) return 'status': 'success', 'message': 'Content displayed successfully.', 'CRC': 'status': 'Success', 'summary': summary, 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': preview @log_to_thought_trail calculate_math(expression: **kwargs) Dict[str, Any]: \"\"\"Evaluates simple mathematical expression returns Î¦-compliant result.\"\"\" logger.info(f\"CALCULATE_MATH Action Fired expression: {expression}\") WARNING: eval() simplicity. cautious production environment. result eval(str(expression)) return 'status': 'success', 'result': result, 'message': f'Successfully evaluated: {expression} {result}', 'CRC': 'status': 'Success', 'summary': f'Mathematical expression \"{expression}\" evaluated {result}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': 'raw_output_preview': f'{{\"status\": \"success\", \"result\": {result}}}' except Exception logger.error(f\"Error evaluating expression '{expression}': {e}\", exc_info=True) return 'status': 'error', 'message': f'Failed evaluate expression: {str(e)}', 'error_details': str(e), 'CRC': 'status': 'Failed', 'summary': f'Math evaluation failed \"{expression}\": {str(e)}', 'confidence': 'alignment_check': 'objective_alignment': 'P_alignment': 'potential_issues': f'Invalid mathematical expression: {expression}', str(e) 'raw_output_preview': f'{{\"status\": \"error\", \"message\": \"{str(e)}\"}}' Additional Action @log_to_thought_trail string_template_action(**kwargs) Dict[str, Any]: [Î¦ Compliant] Renders Jinja2 template string using current workflow context. action ensures templating handled consistently robustly across entire S, adhering capabilities W. template_string kwargs.get('template', context_for_action kwargs.get('context_for_action') runtime_context context_for_action hasattr(context_for_action, 'runtime_context'): runtime_context context_for_action.runtime_context template_string: raise ValueError(\"Input 'template' cannot empty.\") Use Jinja2 render template provided context Environment() template env.from_string(template_string) result template.render(runtime_context) Return Î¦-compliant response return 'status': 'success', 'result': result, 'CRC': 'status': 'Success', 'summary': f'Template rendered successfully. Result length: {len(result)} characters.', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 1.0}, 'potential_issues': 'raw_output_preview': f\"{{'status': 'success', 'result': '{result[:100]}{'...' len(result) ''}'}}\" except Exception logger.error(f\"Error rendering Jinja2 template string_template_action: {e}\", exc_info=True) return 'status': 'error', 'message': str(e), 'CRC': 'status': 'Failed', 'summary': f'Template rendering failed: {str(e)}', 'confidence': 'alignment_check': {'objective_alignment': 'P_alignment': 0.0}, 'potential_issues': [str(e)],",
    "compression_ratio": 2.8946196024674435,
    "symbol_count": 11672,
    "timestamp": "2025-11-18T10:45:48.862763Z"
  },
  {
    "stage_name": "Atto",
    "content": "TERM: Action Registry D: W It Core W SIRC Python Î˜ BLUEPRINT DETAILS: See ResonantiA P Section Three_PointO_Ã†/action_registry.py I CODE First 30KB: START FILE 3.0Ã†/action_registry.py (UNIFIED) Dict, Any, Callable, Optional, List Environment, Import Jinja2 Initialize Core Imports Tool Imports Capabilities GoogleProvider Corrected GeminiCapabilities ImportError Define Add GoogleProvider None GeminiCapabilities None NFL V4 UNIFICATION PROXY V4 UNIFICATION PROXY Import V4 CE. Add Four_PointO_Ã† 'Four_PointO_Ã†') Also Try (MUST TSPSolver None 'Ã†_env', PerceptionEngine Import TSPSolver TSPSolver None TSPSolver ImportError Fallback: Four_PointO_Ã† Four_PointO_Ã†.tsp_solver.solver TSPSolver ImportError Last Ensure TSPSolver ImportError(f\"TSPSolver Exception If TSPSolver V4 TSPSolver None V4_REGISTRY_AVAILABLE True V4_PERCEPTION_ENGINE PerceptionEngine() V4_TSP_SOLVER TSPSolver Store API S TSPSolver: V4 S\") ImportError V4_REGISTRY_AVAILABLE False V4_PERCEPTION_ENGINE None V4_TSP_SOLVER None Only S S ENHANCED PERCEPTION ENGINE Import Perception Engine ENHANCED_PERCEPTION_AVAILABLE True Perception Engine ImportError ENHANCED_PERCEPTION_AVAILABLE True Perception Engine ImportError ENHANCED_PERCEPTION_AVAILABLE False Perception Engine Import Three_PointO_Ã†.tools.enhanced_search_tool Three_PointO_Ã†.tools.synthesis_tool Three_PointO_Ã†.code_executor ActionRegistry: S.\"\"\" Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] List[str]: Dict[str, Dict[str, Any]]: Inspects LLM \"REQUIRED\" ValueError): Some Callable[[Dict[str, Any]], Dict[str, Any]], False): Registers Args: If True, Suppress Skipping Callable: Retrieves Args: Returns: Raises: KeyError: If Available KeyError(f\"Action Singleton Instance ActionRegistry() Backward-compatibility ACTION_REGISTRY Core Tool Imports Registration Wrapper Dict[str, Any]: NEW: Import Instantiate Modular Capabilities FIX: Access None API Check GoogleProvider GoogleProvider: GoogleProvider(api_key=google_api_key) GeminiCapabilities(google_provider=google_provider_instance) CAPABILITIES_AVAILABLE True ActionRegistry.\") CAPABILITIES_AVAILABLE False None GeminiCapabilities Exception CAPABILITIES_AVAILABLE False None GeminiCapabilities: Placeholder Dict[str, Any]: Î¦-compliant Action Fired:\") Return Î¦ 'CRC': Dict[str, Any]: Î¦-compliant Action Fired WARNING: 'CRC': Exception 'CRC': Additional Action Dict[str, Any]: [Î¦ Compliant] Renders Jinja2 S, W. ValueError(\"Input Use Jinja2 Environment() Return Î¦-compliant 'CRC': Result Exception Jinja2 'CRC':",
    "compression_ratio": 13.53063676411694,
    "symbol_count": 2497,
    "timestamp": "2025-11-18T10:45:49.151166Z"
  },
  {
    "stage_name": "Zepto",
    "content": "Î˜|Ã†|Ã†|Ã†|Ã†",
    "compression_ratio": 3754.0,
    "symbol_count": 9,
    "timestamp": "2025-11-18T10:45:49.157972Z"
  }
]