[
  {
    "stage_name": "Narrative",
    "content": "TERM: Class: WebSocketTimeoutWrapper\n\nDEFINITION:\nClass: WebSocketTimeoutWrapper\n\nWebSocket timeout wrapper for VCD Bridge compatibility\nHandles timeout parameter compatibility issues with different websockets library versions\n\nMethods: __init__\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/websocket_timeout_wrapper.py, type: python_class\n\nFULL IMPLEMENTATION CODE (websocket_timeout_wrapper.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nWebSocket Timeout Wrapper - VCD Bridge Compatibility Fix\nProvides timeout-compatible WebSocket connection handling for VCD Bridge\n\"\"\"\n\nimport asyncio\nimport websockets\nimport logging\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nclass WebSocketTimeoutWrapper:\n    \"\"\"\n    WebSocket timeout wrapper for VCD Bridge compatibility\n    Handles timeout parameter compatibility issues with different websockets library versions\n    \"\"\"\n    \n    def __init__(self, timeout: float = 5.0):\n        self.timeout = timeout\n        self.logger = logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\")\n    \n    async def connect_with_timeout(self, uri: str, **kwargs) -> websockets.WebSocketServerProtocol:\n        \"\"\"\n        Connect to WebSocket with timeout handling\n        \n        Args:\n            uri: WebSocket URI\n            **kwargs: Additional connection parameters\n            \n        Returns:\n            WebSocket connection\n            \n        Raises:\n            ConnectionRefusedError: If connection is refused\n            asyncio.TimeoutError: If connection times out\n            Exception: For other connection errors\n        \"\"\"\n        try:\n            # Remove timeout from kwargs if present (for compatibility)\n            kwargs.pop('timeout', None)\n            \n            # Use asyncio.wait_for for timeout handling\n            connection = await asyncio.wait_for(\n                websockets.connect(uri, **kwargs),\n                timeout=self.timeout\n            )\n            \n            self.logger.info(f\"Successfully connected to {uri}\")\n            return connection\n            \n        except asyncio.TimeoutError:\n            self.logger.error(f\"Connection to {uri} timed out after {self.timeout}s\")\n            raise\n        except ConnectionRefusedError:\n            self.logger.error(f\"Connection to {uri} refused\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Connection to {uri} failed: {e}\")\n            raise\n    \n    async def send_with_timeout(self, websocket: websockets.WebSocketServerProtocol, \n                              message: str, timeout: Optional[float] = None) -> None:\n        \"\"\"\n        Send message with timeout handling\n        \n        Args:\n            websocket: WebSocket connection\n            message: Message to send\n            timeout: Optional timeout override\n        \"\"\"\n        timeout = timeout or self.timeout\n        \n        try:\n            await asyncio.wait_for(\n                websocket.send(message),\n                timeout=timeout\n            )\n            self.logger.debug(f\"Message sent successfully\")\n        except asyncio.TimeoutError:\n            self.logger.error(f\"Send operation timed out after {timeout}s\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Send operation failed: {e}\")\n            raise\n    \n    async def recv_with_timeout(self, websocket: websockets.WebSocketServerProtocol,\n                              timeout: Optional[float] = None) -> str:\n        \"\"\"\n        Receive message with timeout handling\n        \n        Args:\n            websocket: WebSocket connection\n            timeout: Optional timeout override\n            \n        Returns:\n            Received message\n        \"\"\"\n        timeout = timeout or self.timeout\n        \n        try:\n            message = await asyncio.wait_for(\n                websocket.recv(),\n                timeout=timeout\n            )\n            self.logger.debug(f\"Message received successfully\")\n            return message\n        except asyncio.TimeoutError:\n            self.logger.error(f\"Receive operation timed out after {timeout}s\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Receive operation failed: {e}\")\n            raise\n\nasync def test_vcd_bridge_connection(uri: str = \"ws://localhost:8765\", \n                                   timeout: float = 5.0) -> Dict[str, Any]:\n    \"\"\"\n    Test VCD Bridge connection with timeout wrapper\n    \n    Args:\n        uri: WebSocket URI\n        timeout: Connection timeout\n        \n    Returns:\n        Connection test results\n    \"\"\"\n    wrapper = WebSocketTimeoutWrapper(timeout)\n    \n    try:\n        async with wrapper.connect_with_timeout(uri) as websocket:\n            # Send test message\n            test_message = {\n                \"type\": \"test_connection\",\n                \"timestamp\": datetime.now().isoformat(),\n                \"client\": \"websocket_timeout_wrapper\"\n            }\n            \n            import json\n            await wrapper.send_with_timeout(websocket, json.dumps(test_message))\n            \n            # Wait for response\n            response = await wrapper.recv_with_timeout(websocket)\n            data = json.loads(response)\n            \n            return {\n                \"status\": \"connected\",\n                \"response_received\": True,\n                \"response_data\": data,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n    except asyncio.TimeoutError:\n        return {\n            \"status\": \"timeout\",\n            \"response_received\": False,\n            \"error\": f\"Connection timed out after {timeout}s\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n    except ConnectionRefusedError:\n        return {\n            \"status\": \"connection_refused\",\n            \"response_received\": False,\n            \"error\": \"Connection refused - VCD Bridge server not running\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"response_received\": False,\n            \"error\": str(e),\n            \"timestamp\": datetime.now().isoformat()\n        }\n\n# Convenience function for VCD Analysis Agent\nasync def test_vcd_bridge_connection_simple() -> Dict[str, Any]:\n    \"\"\"Simple VCD Bridge connection test for VCD Analysis Agent\"\"\"\n    return await test_vcd_bridge_connection()\n\nif __name__ == \"__main__\":\n    # Test the wrapper\n    import asyncio\n    \n    async def main():\n        print(\"Testing WebSocket Timeout Wrapper...\")\n        result = await test_vcd_bridge_connection()\n        print(f\"Test result: {result}\")\n    \n    asyncio.run(main())\n\n\n\n\n\n\n\n\n```\n\nEXAMPLE APPLICATION:\nClass: WebSocketTimeoutWrapper\n\nWebSocket timeout wrapper for VCD Bridge compatibility\nHandles timeout parameter compatibility issues with different websockets library versions\n\nMethods: __init__\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/websocket_timeout_wrapper.py; source_type: python_class",
    "compression_ratio": 1.0,
    "symbol_count": 7173,
    "timestamp": "2025-11-18T10:59:56.168116Z"
  },
  {
    "stage_name": "Concise",
    "content": "TERM: Class: WebSocketTimeoutWrapper\n\nDEFINITION:\nClass: WebSocketTimeoutWrapper\n\nWebSocket timeout wrapper for VCD Bridge compatibility\nHandles timeout parameter compatibility issues with different websockets library versions\n\nMethods: __init__\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/websocket_timeout_wrapper.py, type: python_class\n\nFULL IMPLEMENTATION CODE (websocket_timeout_wrapper.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nWebSocket Timeout Wrapper - VCD Bridge Compatibility Fix\nProvides timeout-compatible WebSocket connection handling for VCD Bridge\n\"\"\"\n\nimport asyncio\nimport websockets\nimport logging\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nclass WebSocketTimeoutWrapper:\n    \"\"\"\n    WebSocket timeout wrapper for VCD Bridge compatibility\n    Handles timeout parameter compatibility issues with different websockets library versions\n    \"\"\"\n    \n    def __init__(self, timeout: float = 5.0):\n        self.timeout = timeout\n        self.logger = logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\")\n    \n    async def connect_with_timeout(self, uri: str, **kwargs) -> websockets.WebSocketServerProtocol:\n        \"\"\"\n        Connect to WebSocket with timeout handling\n        \n        Args:\n            uri: WebSocket URI\n            **kwargs: Additional connection parameters\n            \n        Returns:\n            WebSocket connection\n            \n        Raises:\n            ConnectionRefusedError: If connection is refused\n            asyncio.TimeoutError: If connection times out\n            Exception: For other connection errors\n        \"\"\"\n        try:\n            # Remove timeout from kwargs if present (for compatibility)\n            kwargs.pop('timeout', None)\n            \n            # Use asyncio.wait_for for timeout handling\n            connection = await asyncio.wait_for(\n                websockets.connect(uri, **kwargs),\n                timeout=self.timeout\n            )\n            \n            self.logger.info(f\"Successfully connected to {uri}\")\n            return connection\n            \n        except asyncio.TimeoutError:\n            self.logger.error(f\"Connection to {uri} timed out after {self.timeout}s\")\n            raise\n        except ConnectionRefusedError:\n            self.logger.error(f\"Connection to {uri} refused\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Connection to {uri} failed: {e}\")\n            raise\n    \n    async def send_with_timeout(self, websocket: websockets.WebSocketServerProtocol, \n                              message: str, timeout: Optional[float] = None) -> None:\n        \"\"\"\n        Send message with timeout handling\n        \n        Args:\n            websocket: WebSocket connection\n            message: Message to send\n            timeout: Optional timeout override\n        \"\"\"\n        timeout = timeout or self.timeout\n        \n        try:\n            await asyncio.wait_for(\n                websocket.send(message),\n                timeout=timeout\n            )\n            self.logger.debug(f\"Message sent successfully\")\n        except asyncio.TimeoutError:\n            self.logger.error(f\"Send operation timed out after {timeout}s\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Send operation failed: {e}\")\n            raise\n    \n    async def recv_with_timeout(self, websocket: websockets.WebSocketServerProtocol,\n                              timeout: Optional[float] = None) -> str:\n        \"\"\"\n        Rece",
    "compression_ratio": 2.0002788622420526,
    "symbol_count": 3586,
    "timestamp": "2025-11-18T10:59:56.168140Z"
  },
  {
    "stage_name": "Nano",
    "content": "TERM: Class: WebSocketTimeoutWrapper D: Class: WebSocketTimeoutWrapper WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions Methods: __init__ BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/websocket_timeout_wrapper.py, type: python_class FULL I CODE (websocket_timeout_wrapper.py): ```python #!/usr/bin/env python3 \"\"\" WebSocket Timeout Wrapper - VCD Bridge Compatibility Fix Provides timeout-compatible WebSocket connection handling VCD Bridge \"\"\" import asyncio import websockets import logging typing import Optional, Dict, Any datetime import datetime logger = logging.getLogger(__name__) class WebSocketTimeoutWrapper: \"\"\" WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions \"\"\" def __init__(self, timeout: float = 5.0): self.timeout = timeout self.logger = logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\") async def connect_with_timeout(self, uri: str, **kwargs) -> websockets.WebSocketServerP: \"\"\" Connect to WebSocket timeout handling Args: uri: WebSocket URI **kwargs: Additional connection parameters Returns: WebSocket connection Raises: ConnectionRefusedError: If connection is refused asyncio.TimeoutError: If connection times out Exception: other connection errors \"\"\" try: # Remove timeout kwargs if present ( compatibility) kwargs.pop('timeout', None) # Use asyncio.wait_for timeout handling connection = await asyncio.wait_for( websockets.connect(uri, **kwargs), timeout=self.timeout ) self.logger.info(f\"Successfully connected to {uri}\") return connection except asyncio.TimeoutError: self.logger.error(f\"Connection to {uri} timed out after {self.timeout}s\") raise except ConnectionRefusedError: self.logger.error(f\"Connection to {uri} refused\") raise except Exception as e: self.logger.error(f\"Connection to {uri} failed: {e}\") raise async def send_with_timeout(self, websocket: websockets.WebSocketServerP, message: str, timeout: Optional[float] = None) -> None: \"\"\" Send message timeout handling Args: websocket: WebSocket connection message: Message to send timeout: Optional timeout override \"\"\" timeout = timeout or self.timeout try: await asyncio.wait_for( websocket.send(message), timeout=timeout ) self.logger.debug(f\"Message sent successfully\") except asyncio.TimeoutError: self.logger.error(f\"Send operation timed out after {timeout}s\") raise except Exception as e: self.logger.error(f\"Send operation failed: {e}\") raise async def recv_with_timeout(self, websocket: websockets.WebSocketServerP, timeout: Optional[float] = None) -> str: \"\"\" Rece",
    "compression_ratio": 2.681495327102804,
    "symbol_count": 2675,
    "timestamp": "2025-11-18T10:59:56.179023Z"
  },
  {
    "stage_name": "Micro",
    "content": "TERM: Class: WebSocketTimeoutWrapper D: Class: WebSocketTimeoutWrapper WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions Methods: __init__ BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/websocket_timeout_wrapper.py, type: python_class FULL I CODE (websocket_timeout_wrapper.py): ```python #!/usr/bin/env python3 WebSocket Timeout Wrapper VCD Bridge Compatibility Fix Provides timeout-compatible WebSocket connection handling VCD Bridge import asyncio import websockets import logging typing import Optional, Dict, Any datetime import datetime logger logging.getLogger(__name__) class WebSocketTimeoutWrapper: WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions __init__(self, timeout: float 5.0): self.timeout timeout self.logger logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\") async connect_with_timeout(self, **kwargs) websockets.WebSocketServerP: Connect WebSocket timeout handling Args: WebSocket URI **kwargs: Additional connection parameters Returns: WebSocket connection Raises: ConnectionRefusedError: If connection refused asyncio.TimeoutError: If connection times Exception: other connection errors Remove timeout kwargs present compatibility) kwargs.pop('timeout', None) Use asyncio.wait_for timeout handling connection await asyncio.wait_for( websockets.connect(uri, **kwargs), timeout=self.timeout self.logger.info(f\"Successfully connected {uri}\") return connection except asyncio.TimeoutError: self.logger.error(f\"Connection {uri} timed after {self.timeout}s\") raise except ConnectionRefusedError: self.logger.error(f\"Connection {uri} refused\") raise except Exception self.logger.error(f\"Connection {uri} failed: {e}\") raise async send_with_timeout(self, websocket: websockets.WebSocketServerP, message: timeout: Optional[float] None) None: Send message timeout handling Args: websocket: WebSocket connection message: Message timeout: Optional timeout override timeout timeout self.timeout await asyncio.wait_for( websocket.send(message), timeout=timeout self.logger.debug(f\"Message successfully\") except asyncio.TimeoutError: self.logger.error(f\"Send operation timed after {timeout}s\") raise except Exception self.logger.error(f\"Send operation failed: {e}\") raise async recv_with_timeout(self, websocket: websockets.WebSocketServerP, timeout: Optional[float] None) Rece",
    "compression_ratio": 2.8807228915662653,
    "symbol_count": 2490,
    "timestamp": "2025-11-18T10:59:56.218583Z"
  },
  {
    "stage_name": "Pico",
    "content": "TERM: Class: WebSocketTimeoutWrapper D: Class: WebSocketTimeoutWrapper WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions Methods: __init__ BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/websocket_timeout_wrapper.py, type: python_class FULL I CODE (websocket_timeout_wrapper.py): ```python #!/usr/bin/env python3 WebSocket Timeout Wrapper VCD Bridge Compatibility Fix Provides timeout-compatible WebSocket connection handling VCD Bridge import asyncio import websockets import logging typing import Optional, Dict, Any datetime import datetime logger logging.getLogger(__name__) class WebSocketTimeoutWrapper: WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions __init__(self, timeout: float 5.0): self.timeout timeout self.logger logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\") async connect_with_timeout(self, **kwargs) websockets.WebSocketServerP: Connect WebSocket timeout handling Args: WebSocket URI **kwargs: Additional connection parameters Returns: WebSocket connection Raises: ConnectionRefusedError: If connection refused asyncio.TimeoutError: If connection times Exception: other connection errors Remove timeout kwargs present compatibility) kwargs.pop('timeout', None) Use asyncio.wait_for timeout handling connection await asyncio.wait_for( websockets.connect(uri, **kwargs), timeout=self.timeout self.logger.info(f\"Successfully connected {uri}\") return connection except asyncio.TimeoutError: self.logger.error(f\"Connection {uri} timed after {self.timeout}s\") raise except ConnectionRefusedError: self.logger.error(f\"Connection {uri} refused\") raise except Exception self.logger.error(f\"Connection {uri} failed: {e}\") raise async send_with_timeout(self, websocket: websockets.WebSocketServerP, message: timeout: Optional[float] None) None: Send message timeout handling Args: websocket: WebSocket connection message: Message timeout: Optional timeout override timeout timeout self.timeout await asyncio.wait_for( websocket.send(message), timeout=timeout self.logger.debug(f\"Message successfully\") except asyncio.TimeoutError: self.logger.error(f\"Send operation timed after {timeout}s\") raise except Exception self.logger.error(f\"Send operation failed: {e}\") raise async recv_with_timeout(self, websocket: websockets.WebSocketServerP, timeout: Optional[float] None) Rece",
    "compression_ratio": 2.8807228915662653,
    "symbol_count": 2490,
    "timestamp": "2025-11-18T10:59:56.240027Z"
  },
  {
    "stage_name": "Femto",
    "content": "TERM: Class: WebSocketTimeoutWrapper D: Class: WebSocketTimeoutWrapper WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions Methods: __init__ BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/websocket_timeout_wrapper.py, type: python_class FULL I CODE (websocket_timeout_wrapper.py): ```python #!/usr/bin/env python3 WebSocket Timeout Wrapper VCD Bridge Compatibility Fix Provides timeout-compatible WebSocket connection handling VCD Bridge import asyncio import websockets import logging typing import Optional, Dict, Any datetime import datetime logger logging.getLogger(__name__) class WebSocketTimeoutWrapper: WebSocket timeout wrapper VCD Bridge compatibility Handles timeout parameter compatibility issues different websockets library versions __init__(self, timeout: float 5.0): self.timeout timeout self.logger logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\") async connect_with_timeout(self, **kwargs) websockets.WebSocketServerP: Connect WebSocket timeout handling Args: WebSocket URI **kwargs: Additional connection parameters Returns: WebSocket connection Raises: ConnectionRefusedError: If connection refused asyncio.TimeoutError: If connection times Exception: other connection errors Remove timeout kwargs present compatibility) kwargs.pop('timeout', None) Use asyncio.wait_for timeout handling connection await asyncio.wait_for( websockets.connect(uri, **kwargs), timeout=self.timeout self.logger.info(f\"Successfully connected {uri}\") return connection except asyncio.TimeoutError: self.logger.error(f\"Connection {uri} timed after {self.timeout}s\") raise except ConnectionRefusedError: self.logger.error(f\"Connection {uri} refused\") raise except Exception self.logger.error(f\"Connection {uri} failed: {e}\") raise async send_with_timeout(self, websocket: websockets.WebSocketServerP, message: timeout: Optional[float] None) None: Send message timeout handling Args: websocket: WebSocket connection message: Message timeout: Optional timeout override timeout timeout self.timeout await asyncio.wait_for( websocket.send(message), timeout=timeout self.logger.debug(f\"Message successfully\") except asyncio.TimeoutError: self.logger.error(f\"Send operation timed after {timeout}s\") raise except Exception self.logger.error(f\"Send operation failed: {e}\") raise async recv_with_timeout(self, websocket: websockets.WebSocketServerP, timeout: Optional[float] None) Rece",
    "compression_ratio": 2.8807228915662653,
    "symbol_count": 2490,
    "timestamp": "2025-11-18T10:59:56.263454Z"
  },
  {
    "stage_name": "Atto",
    "content": "TERM: Class: WebSocketTimeoutWrapper D: Class: WebSocketTimeoutWrapper WebSocket VCD Bridge Handles Methods: BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/websocket_timeout_wrapper.py, FULL I CODE WebSocket Timeout Wrapper VCD Bridge Compatibility Fix Provides WebSocket VCD Bridge Optional, Dict, Any WebSocketTimeoutWrapper: WebSocket VCD Bridge Handles Connect WebSocket Args: WebSocket URI Additional Returns: WebSocket Raises: ConnectionRefusedError: If If Exception: Remove None) Use ConnectionRefusedError: Exception Optional[float] None) None: Send Args: WebSocket Message Optional Exception Optional[float] None) Rece",
    "compression_ratio": 10.96788990825688,
    "symbol_count": 654,
    "timestamp": "2025-11-18T10:59:56.281897Z"
  },
  {
    "stage_name": "Zepto",
    "content": "Æ",
    "compression_ratio": 7173.0,
    "symbol_count": 1,
    "timestamp": "2025-11-18T10:59:56.283617Z"
  }
]