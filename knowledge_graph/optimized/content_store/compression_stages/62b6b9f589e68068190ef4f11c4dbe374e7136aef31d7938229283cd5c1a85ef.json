[
  {
    "stage_name": "Narrative",
    "content": "TERM: Class: FallbackConfig\n\nDEFINITION:\nExecute code in the specified language and return results with IAR reflection.\n    This action is now compliant with ResonantiA Protocol v3.1-CA IAR standards.\n\n    Args:\n        inputs (Dict): A dictionary containing:\n            - code (str): The code to execute.\n            - language (str): Programming language (default: python).\n            - timeout (int): Execution timeout in seconds.\n            - environment (Dict[str, str]): Optional environment variables.\n            - code_path (str): Path to a file containing the code.\n            - input_data (str): Optional string to pass to the script's stdin.\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/code_executor.py, type: python_class\n\nFULL IMPLEMENTATION CODE (code_executor.py):\n```python\n# --- START OF FILE 3.0ArchE/code_executor.py ---\n# ResonantiA Protocol v3.0 - code_executor.py\n# Executes code snippets securely using sandboxing (Docker recommended).\n# Includes mandatory Integrated Action Reflection (IAR) output.\n# WARNING: Improper configuration or use (especially disabling sandbox) is a MAJOR security risk.\n\nimport logging\nimport subprocess # For running external processes (docker, interpreters)\nimport tempfile # For creating temporary files/directories for code\nimport os\nimport json\nimport platform # Potentially useful for platform-specific commands/paths\nimport sys # To find python executable for subprocess fallback\nimport time # For timeouts and potentially timestamps\nimport shutil # Added for script copying\nfrom typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING # Expanded type hints\nimport asyncio\nfrom dataclasses import dataclass\nfrom .iar_components import IARValidator, ResonanceTracker\nfrom .utils.reflection_utils import create_reflection, ExecutionStatus\n\nif TYPE_CHECKING:\n    from .action_context import ActionContext\n\n# Use relative imports for configuration\ntry:\n    from . import config\nexcept ImportError:\n    # Fallback config if running standalone or package structure differs\n    class FallbackConfig:\n        CODE_EXECUTOR_SANDBOX_METHOD='subprocess'; CODE_EXECUTOR_USE_SANDBOX=True;\n        CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30;\n        CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\"\n    config = FallbackConfig(); logging.warning(\"config.py not found for code_executor, using fallback configuration.\")\n\nlogger = logging.getLogger(__name__)\n\n# --- IAR Helper Function (DEPRECATED) ---\n# The local _create_reflection is now deprecated in favor of the centralized utility.\n\n# --- Sandboxing Configuration & Checks ---\n# Read configuration settings, providing defaults if missing\nSANDBOX_METHOD_CONFIG = getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subprocess').lower()\nUSE_SANDBOX_CONFIG = getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True)\nDOCKER_IMAGE = getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\")\nTIMEOUT_SECONDS = int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', 60)) # Use integer timeout\nDOCKER_MEM_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\")\nDOCKER_CPU_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\")\n\n# Determine the actual sandbox method to use based on config\nsandbox_method_resolved: str\nif not USE_SANDBOX_CONFIG:\n    sandbox_method_resolved = 'none'\n    if SANDBOX_METHOD_CONFIG != 'none':\n        logger.warning(\"CODE_EXECUTOR_USE_SANDBOX is False in config. Overriding method to 'none'. SIGNIFICANT SECURITY RISK.\")\nelif SANDBOX_METHOD_CONFIG in ['docker', 'subprocess', 'none']:\n    sandbox_method_resolved = SANDBOX_METHOD_CONFIG\nelse:\n    logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' in config. Defaulting to 'subprocess'.\")\n    sandbox_method_resolved = 'subprocess' # Default to subprocess if config value is invalid\n\n# Check Docker availability if 'docker' method is resolved\nDOCKER_AVAILABLE = False\nif sandbox_method_resolved == 'docker':\n    try:\n        # Run 'docker info' to check daemon connectivity. Capture output to suppress it.\n        docker_info_cmd = [\"docker\", \"info\"]\n        process = subprocess.run(docker_info_cmd, check=True, capture_output=True, timeout=5)\n        DOCKER_AVAILABLE = True\n        logger.info(\"Docker runtime detected and appears responsive.\")\n    except FileNotFoundError:\n        logger.warning(\"Docker command not found. Docker sandbox unavailable. Will fallback if possible.\")\n    except subprocess.CalledProcessError as e:\n        logger.warning(f\"Docker daemon check failed (command {' '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\")\n    except subprocess.TimeoutExpired:\n        logger.warning(\"Docker daemon check timed out. Docker sandbox likely unavailable.\")\n    except Exception as e_docker_check:\n        logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\")\n\n# --- Main Execution Function ---\ndef execute_code(\n    inputs: Dict[str, Any]\n) -> Dict[str, Any]:\n    \"\"\"\n    Execute code in the specified language and return results with IAR reflection.\n    This action is now compliant with ResonantiA Protocol v3.1-CA IAR standards.\n\n    Args:\n        inputs (Dict): A dictionary containing:\n            - code (str): The code to execute.\n            - language (str): Programming language (default: python).\n            - timeout (int): Execution timeout in seconds.\n            - environment (Dict[str, str]): Optional environment variables.\n            - code_path (str): Path to a file containing the code.\n            - input_data (str): Optional string to pass to the script's stdin.\n    \"\"\"\n    start_time = time.time()\n    action_name = \"execute_code\"\n    \n    code = inputs.get(\"code\")\n    code_path = inputs.get(\"code_path\")\n    language = inputs.get(\"language\", \"python\")\n    timeout = inputs.get(\"timeout\", 30)\n    environment = inputs.get(\"environment\")\n    input_data = inputs.get(\"input_data\")\n\n    if code is None and code_path is None:\n        return {\n            \"error\": \"Either 'code' or 'code_path' must be provided.\",\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.FAILURE,\n                message=\"Input validation failed: 'code' or 'code_path' must be provided.\",\n                inputs=inputs,\n                execution_time=time.time() - start_time\n            )\n        }\n    \n    temp_file = None\n    try:\n        if code_path:\n            if not os.path.exists(code_path):\n                raise FileNotFoundError(f\"The specified code_path does not exist: {code_path}\")\n            exec_file = code_path\n        else:\n            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") as f:\n                f.write(code)\n                temp_file = f.name\n            exec_file = temp_file\n        \n        env = os.environ.copy()\n        if environment:\n            safe_env = {str(k): str(v) for k, v in environment.items()}\n            env.update(safe_env)\n        \n        if language != \"python\":\n             raise ValueError(f\"Unsupported language: {language}\")\n\n        result = subprocess.run(\n            [sys.executable, exec_file],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            env=env,\n            input=input_data\n        )\n        \n        execution_time = time.time() - start_time\n        \n        if result.returncode == 0:\n            outputs = {\"output\": result.stdout, \"stderr\": result.stderr}\n            return {\n                \"result\": outputs,\n                \"reflection\": create_reflection(\n                    action_name=action_name,\n                    status=ExecutionStatus.SUCCESS,\n                    message=\"Code executed successfully.\",\n                    inputs=inputs,\n                    outputs=outputs,\n                    confidence=1.0,\n                    execution_time=execution_time\n                )\n            }\n        else:\n            outputs = {\"output\": result.stdout, \"error\": result.stderr}\n            return {\n                \"result\": outputs,\n                \"reflection\": create_reflection(\n                    action_name=action_name,\n                    status=ExecutionStatus.FAILURE,\n                    message=f\"Code execution failed with return code {result.returncode}.\",\n                    inputs=inputs,\n                    outputs=outputs,\n                    confidence=0.1,\n                    potential_issues=[f\"Return Code: {result.returncode}\", result.stderr],\n                    execution_time=execution_time\n                )\n            }\n            \n    except subprocess.TimeoutExpired:\n        execution_time = time.time() - start_time\n        error_msg = f\"Execution timed out after {timeout} seconds\"\n        return {\n            \"error\": error_msg,\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.FAILURE,\n                message=error_msg,\n                inputs=inputs,\n                potential_issues=[\"TimeoutExpired\"],\n                execution_time=execution_time\n            )\n        }\n    except Exception as e:\n        execution_time = time.time() - start_time\n        error_msg = f\"An unexpected error occurred: {str(e)}\"\n        logger.error(f\"Error executing code for action '{action_name}': {error_msg}\", exc_info=True)\n        return {\n            \"error\": error_msg,\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.CRITICAL_FAILURE,\n                message=error_msg,\n                inputs=inputs,\n                potential_issues=[str(e)],\n                execution_time=execution_time\n            )\n        }\n    finally:\n        if temp_file and os.path.exists(temp_file):\n            os.remove(temp_file)\n\n# --- Internal Helper: Docker Execution ---\ndef _execute_with_docker(language: str, code: str, input_data: str, env_vars: Optional[Dict[str, str]] = None) -> Dict[str, Any]:\n    \"\"\"Executes code inside a Docker container. Returns partial result dict.\"\"\"\n    # Define language-specific interpreters and script filenames within the container\n    exec_details: Dict[str, Tuple[str, str]] = {\n        'python': ('python', 'script.py'),         # For executing Python code strings\n        'python_script': ('python', 'script.py'),  # For executing Python script files\n        'javascript': ('node', 'script.js'),\n        # Future: 'bash': ('bash', 'script.sh')\n    }\n\n    if language not in exec_details:\n        return {\"error\": f\"Docker execution unsupported for language: '{language}'.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n\n    interpreter, script_filename_in_container = exec_details[language]\n    temp_dir_obj = None # For ensuring cleanup with try/finally\n\n    try:\n        temp_dir_obj = tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\")\n        temp_dir = temp_dir_obj.name\n        \n        code_filepath_in_temp = os.path.join(temp_dir, script_filename_in_container)\n\n        if language.endswith('_script'): # e.g. 'python_script'\n            host_script_path = code # 'code' parameter is the host path to the script\n            if not os.path.isfile(host_script_path):\n                logger.error(f\"Script file for Docker execution not found on host: {host_script_path}\")\n                return {\"error\": f\"Script file not found on host: {host_script_path}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n            try:\n                shutil.copy2(host_script_path, code_filepath_in_temp)\n                logger.debug(f\"Copied script '{host_script_path}' to temporary Docker mount target '{code_filepath_in_temp}'.\")\n            except Exception as e_copy:\n                logger.error(f\"Failed to copy script '{host_script_path}' to temp dir '{temp_dir}': {e_copy}\")\n                return {\"error\": f\"Failed to copy script to temp dir for Docker: {e_copy}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n        else: # For language == 'python', 'javascript' (code strings)\n            try:\n                with open(code_filepath_in_temp, 'w', encoding='utf-8') as f:\n                    f.write(code)\n            except IOError as e_write:\n                logger.error(f\"Failed to write temporary code file for Docker: {e_write}\")\n                return {\"error\": f\"Failed to write temporary code file: {e_write}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n\n        abs_temp_dir = os.path.abspath(temp_dir)\n        \n        docker_command = [\n            \"docker\", \"run\", \"--rm\", \"--network\", \"none\",\n            \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, # Enforce memory limits\n            \"--cpus\", DOCKER_CPU_LIMIT, # Enforce CPU limits\n            \"--security-opt=no-new-privileges\", # Prevent privilege escalation\n            \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", # Mount code read-only\n            \"-w\", \"/sandbox\", # Set working directory inside container\n        ]\n        \n        # Add environment variables from prompt_vars\n        if env_vars:\n            for key, value in env_vars.items():\n                docker_command.extend([\"-e\", f\"{key}={value}\"])\n\n        docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container])\n\n        logger.debug(f\"Executing Docker command: {' '.join(docker_command)}\")\n\n        # Run the Docker container process\n        try:\n            process = subprocess.run(\n                docker_command,\n                input=input_data.encode('utf-8'), # Pass input_data as stdin\n                capture_output=True, # Capture stdout/stderr\n                timeout=TIMEOUT_SECONDS, # Apply timeout\n                check=False # Do not raise exception on non-zero exit code\n            )\n\n            # Decode stdout/stderr, replacing errors\n            stdout = process.stdout.decode('utf-8', errors='replace').strip()\n            stderr = process.stderr.decode('utf-8', errors='replace').strip()\n            exit_code = process.returncode\n\n            if exit_code != 0:\n                logger.warning(f\"Docker execution finished with non-zero exit code {exit_code}. Stderr:\\n{stderr}\")\n            else:\n                logger.debug(f\"Docker execution successful (Exit Code: 0). Stdout:\\n{stdout}\")\n\n            return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None}\n\n        except subprocess.TimeoutExpired:\n            logger.error(f\"Docker execution timed out after {TIMEOUT_SECONDS}s.\")\n            # Try to cleanup container if possible (might fail if unresponsive)\n            # docker ps -q --filter \"ancestor=DOCKER_IMAGE\" | xargs -r docker stop | xargs -r docker rm\n            return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"Timeout Error\"}\n        except FileNotFoundError:\n            # Should be caught by earlier check, but safeguard\n            logger.error(\"Docker command not found during execution attempt.\")\n            return {\"error\": \"Docker command not found.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n        except Exception as e_docker_run:\n            logger.error(f\"Docker container execution failed unexpectedly: {e_docker_run}\", exc_info=True)\n            return {\"error\": f\"Docker execution failed: {e_docker_run}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": str(e_docker_run)}\n\n    except Exception as e_setup:\n        # Catch errors during temp directory creation etc.\n        logger.error(f\"Failed setup for Docker execution: {e_setup}\", exc_info=True)\n        return {\"error\": f\"Failed setup for Docker execution: {e_setup}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n    finally:\n        # Ensure temporary directory is always cleaned up\n        if temp_dir_obj:\n            try:\n                temp_dir_obj.cleanup()\n                logger.debug(\"Cleaned up temporary directory for Docker execution.\")\n            except Exception as cleanup_e:\n                # Log error but don't crash if cleanup fails\n                logger.error(f\"Error cleaning up temporary directory '{getattr(temp_dir_obj,'name','N/A')}': {cleanup_e}\")\n\n# --- Internal Helper: Subprocess Execution ---\ndef _execute_with_subprocess(language: str, code: str, input_data: str, env_vars: Optional[Dict[str, str]] = None, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n    \"\"\"Executes code using a local subprocess. Returns partial result dict.\"\"\"\n    # Determine interpreter path (sys.executable for Python, 'node' for JavaScript)\n    interpreter_path = \"\"\n    if language == 'python' or language == 'python_script': # For both python code strings and scripts\n        interpreter_path = sys.executable\n    elif language == 'javascript':\n        interpreter_path = \"node\"\n    else:\n        return {\"error\": f\"Unsupported language for subprocess execution: {language}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": f\"Unsupported language: {language}\"}\n\n    if not interpreter_path:\n        return {\"error\": \"Interpreter path could not be determined.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"Interpreter path missing.\"}\n\n    # Construct the command\n    command: List[str]\n    input_data_for_python_execution: Optional[str] = None # Specifically for piping python code\n\n    if language == 'python_script':\n        script_path = os.path.abspath(code) # Ensure absolute path for security/consistency\n        if not os.path.isfile(script_path):\n            return {\"error\": f\"Python script not found: {script_path}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": f\"Script not found: {script_path}\"}\n        command = [interpreter_path, script_path]\n        logger.debug(f\"Subprocess: Executing Python script. Command: {' '.join(command)}\")\n        input_data_for_python_execution = input_data # Regular input_data for scripts\n    elif language == 'python':\n        # For Python code strings, execute the interpreter and pipe the code to stdin\n        command = [interpreter_path]\n        \n        # If we have context and this is Python code, prepend context injection\n        if context and language == 'python':\n            try:\n                logger.debug(f\"Subprocess: Context available with keys: {list(context.keys()) if context else 'None'}\")\n                \n                # Serialize context without truncation - use ensure_ascii=False for better handling of unicode\n                # and separators for compact representation while maintaining readability\n                context_json = json.dumps(context, default=str, ensure_ascii=False, separators=(',', ':'))\n                \n                # Use base64 encoding to safely handle any special characters or large content\n                # This completely avoids any string escaping issues\n                import base64\n                context_b64 = base64.b64encode(context_json.encode('utf-8')).decode('ascii')\n                \n                # Use a robust context injection that handles large contexts and special characters\n                context_injection = f\"\"\"import json\nimport sys\nimport base64\n\n# Full workflow context - never truncated\n# Using base64 encoding to safely handle any special characters or large content\ntry:\n    # Decode the context from base64 encoding\n    context_b64 = \"{context_b64}\"\n    context_json_str = base64.b64decode(context_b64).decode('utf-8')\n    context = json.loads(context_json_str)\n    \n    # Verify context was loaded successfully\n    if not isinstance(context, dict):\n        raise ValueError(\"Context is not a dictionary\")\n        \n    # Make context available globally for any code that needs it\n    globals()['context'] = context\n    \n    # Also make it available in locals for immediate use\n    locals()['context'] = context\n    \nexcept (json.JSONDecodeError, ValueError, UnicodeDecodeError, Exception) as e:\n    print(f\"ERROR: Failed to parse workflow context: {{e}}\", file=sys.stderr)\n    print(f\"Context base64 length: {len(context_b64)}\", file=sys.stderr)\n    # Provide empty context as fallback but don't fail silently\n    context = {{}}\n    globals()['context'] = context\n    locals()['context'] = context\n\n\"\"\"\n                \n                code_with_context = context_injection + code\n                input_data_for_python_execution = code_with_context\n                \n                logger.debug(f\"Subprocess: Injected context into Python code. Context keys: {list(context.keys())}\")\n                logger.debug(f\"Subprocess: Context JSON size: {len(context_json)} characters\")\n                logger.debug(f\"Subprocess: Base64 encoded size: {len(context_b64)} characters\")\n                logger.debug(f\"Subprocess: Total injected code size: {len(code_with_context)} characters\")\n                \n                # Log a preview of the context structure without truncating sensitive data\n                context_preview = {k: f\"<{type(v).__name__}>\" for k, v in context.items()}\n                logger.debug(f\"Subprocess: Context structure preview: {context_preview}\")\n                \n                # Warn if context is very large (but don't truncate)\n                if len(context_json) > 1000000:  # 1MB\n                    logger.warning(f\"Very large context detected ({len(context_json)} chars). This may impact performance but will not be truncated.\")\n                \n            except Exception as e:\n                logger.error(f\"Failed to inject context into Python code: {e}. Running without context.\", exc_info=True)\n                input_data_for_python_execution = code\n        else:\n            logger.debug(f\"Subprocess: No context injection. Context available: {context is not None}, Language: {language}\")\n            input_data_for_python_execution = code # The code string itself will be piped to stdin\n            \n        logger.debug(f\"Subprocess: Executing Python code via stdin. Command: {interpreter_path}. Input code (first 100 chars): {input_data_for_python_execution[:100].replace(chr(10), '\\\\n')}\")\n    elif language == 'javascript':\n        command = [interpreter_path, \"-e\", code]\n    else:\n        # Explicitly prevent 'shell' due to original error context, though it should be caught by 'unsupported' anyway.\n        if language == 'shell':\n             logger.error(f\"Language 'shell' is not directly supported for security reasons via subprocess. Use 'bash' or a script language like 'python_script'.\")\n             return {\"error\": f\"Language 'shell' is not directly supported for security reasons via subprocess. Use 'bash' or script language.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n        logger.error(f\"Unsupported language for subprocess execution: {language}\")\n        return {\"error\": f\"Unsupported language for subprocess execution: {language}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n\n    # Actual execution\n    try:\n        logger.debug(f\"Executing subprocess command: {' '.join(command)} with env: {env_vars is not None}\")\n        process = subprocess.run(\n            command,\n            input=input_data_for_python_execution if language == 'python' else input_data, # Use specific input for python direct execution\n            capture_output=True,\n            text=True,\n            timeout=TIMEOUT_SECONDS,\n            check=False, # Do not raise CalledProcessError, handle exit code manually\n            env=env_vars # Pass the prepared environment variables\n        )\n        return {\"stdout\": process.stdout, \"stderr\": process.stderr, \"exit_code\": process.returncode}\n    except subprocess.TimeoutExpired:\n        logger.error(f\"Subprocess execution timed out after {TIMEOUT_SECONDS}s.\")\n        return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"Timeout Error\"}\n    except FileNotFoundError:\n        # Error if the interpreter itself wasn't found\n        logger.error(f\"Interpreter for '{language}' ('{interpreter_path if interpreter_path else language}') not found.\")\n        return {\"error\": f\"Interpreter not found: {interpreter_path if interpreter_path else language}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n    except OSError as e_os:\n        # Catch OS-level errors during process creation (e.g., permissions)\n        logger.error(f\"OS error during subprocess execution: {e_os}\", exc_info=True)\n        return {\"error\": f\"OS error during execution: {e_os}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": str(e_os)}\n    except Exception as e_subproc:\n        # Catch other unexpected errors\n        logger.error(f\"Subprocess execution failed unexpectedly: {e_subproc}\", exc_info=True)\n        return {\"error\": f\"Subprocess execution failed: {e_subproc}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": str(e_subproc)}\n\n# --- END OF FILE 3.0ArchE/code_executor.py --- \n\n@dataclass\nclass ExecutionResult:\n    \"\"\"Result of code execution.\"\"\"\n    output: str\n    error: Optional[str]\n    execution_time: float\n    sandbox_method: str\n    iar_data: Dict[str, Any]\n\nclass CodeExecutor:\n    \"\"\"Code executor with native Gemini API integration.\"\"\"\n    \n    def __init__(self):\n        self.iar_validator = IARValidator()\n        self.resonance_tracker = ResonanceTracker()\n    \n    async def execute_code(\n        self,\n        code: str,\n        context: Dict[str, Any],\n        provider: str = \"gemini_native\"\n    ) -> ExecutionResult:\n        \"\"\"Execute code using the specified provider.\"\"\"\n        if provider == \"gemini_native\":\n            return await self._execute_with_gemini_native(code, context)\n        else:\n            # Fallback to other providers (e.g., Docker)\n            return await self._execute_with_fallback(code, context, provider)\n    \n    async def _execute_with_gemini_native(\n        self,\n        code: str,\n        context: Dict[str, Any]\n    ) -> ExecutionResult:\n        \"\"\"Execute code using native Gemini API.\"\"\"\n        try:\n            # Prepare execution context\n            execution_context = {\n                \"code\": code,\n                \"context\": context,\n                \"sandbox_method\": \"gemini_native\"\n            }\n            \n            # Execute code using Gemini API\n            # Note: This is a placeholder for the actual Gemini API call\n            # The actual implementation would use the Gemini API's code execution feature\n            result = await self._call_gemini_code_execution(execution_context)\n            \n            # Generate IAR data\n            iar_data = {\n                \"status\": \"Success\" if not result.get(\"error\") else \"Error\",\n                \"confidence\": 0.9,  # High confidence for native execution\n                \"summary\": \"Code execution completed\",\n                \"potential_issues\": [],\n                \"alignment_check\": {\n                    \"code_safety\": 0.9,\n                    \"execution_success\": 0.9 if not result.get(\"error\") else 0.0\n                },\n                \"sandbox_method_used\": \"gemini_native\"\n            }\n            \n            # Track resonance\n            self.resonance_tracker.record_execution(\n                \"code_execution\",\n                iar_data,\n                execution_context\n            )\n            \n            return ExecutionResult(\n                output=result.get(\"output\", \"\"),\n                error=result.get(\"error\"),\n                execution_time=result.get(\"execution_time\", 0.0),\n                sandbox_method=\"gemini_native\",\n                iar_data=iar_data\n            )\n            \n        except Exception as e:\n            # Handle execution errors\n            error_iar = {\n                \"status\": \"Error\",\n                \"confidence\": 0.0,\n                \"summary\": f\"Code execution failed: {str(e)}\",\n                \"potential_issues\": [str(e)],\n                \"alignment_check\": {\n                    \"code_safety\": 0.0,\n                    \"execution_success\": 0.0\n                },\n                \"sandbox_method_used\": \"gemini_native\"\n            }\n            \n            return ExecutionResult(\n                output=\"\",\n                error=str(e),\n                execution_time=0.0,\n                sandbox_method=\"gemini_native\",\n                iar_data=error_iar\n            )\n    \n    async def _execute_with_fallback(\n        self,\n        code: str,\n        context: Dict[str, Any],\n        provider: str\n    ) -> ExecutionResult:\n        \"\"\"Execute code using fallback provider (e.g., Docker).\"\"\"\n        # Implementation for other providers\n        # This would be the existing Docker/subprocess implementation\n        pass\n    \n    async def _call_gemini_code_execution(\n        self,\n        execution_context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"Call Gemini API for code execution.\"\"\"\n        # Placeholder for actual Gemini API call\n        # This would be replaced with the actual API implementation\n        return {\n            \"output\": \"Execution result\",\n            \"error\": None,\n            \"execution_time\": 0.1\n        }\n    \n    def validate_execution(self, result: ExecutionResult) -> bool:\n        \"\"\"Validate execution result.\"\"\"\n        is_valid, _ = self.iar_validator.validate_content(result.iar_data)\n        return is_valid\n    \n    def get_execution_summary(self) -> Dict[str, Any]:\n        \"\"\"Get execution summary.\"\"\"\n        return self.resonance_tracker.get_execution_summary() \n```\n\nEXAMPLE APPLICATION:\nExecute code in the specified language and return results with IAR reflection.\n    This action is now compliant with ResonantiA Protocol v3.1-CA IAR standards.\n\n    Args:\n        inputs (Dict): A dictionary containing:\n            - code (str): The code to execute.\n            - language (str): Programming language (default: python).\n            - timeout (int): Execution timeout in seconds.\n            - environment (Dict[str, str]): Optional environment variables.\n            - code_path (str)\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/code_executor.py; source_type: python_class",
    "compression_ratio": 1.0,
    "symbol_count": 30156,
    "timestamp": "2025-11-18T11:00:52.294840Z"
  },
  {
    "stage_name": "Concise",
    "content": "TERM: Class: FallbackConfig\n\nDEFINITION:\nExecute code in the specified language and return results with IAR reflection.\n    This action is now compliant with ResonantiA Protocol v3.1-CA IAR standards.\n\n    Args:\n        inputs (Dict): A dictionary containing:\n            - code (str): The code to execute.\n            - language (str): Programming language (default: python).\n            - timeout (int): Execution timeout in seconds.\n            - environment (Dict[str, str]): Optional environment variables.\n            - code_path (str): Path to a file containing the code.\n            - input_data (str): Optional string to pass to the script's stdin.\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/code_executor.py, type: python_class\n\nFULL IMPLEMENTATION CODE (code_executor.py):\n```python\n# --- START OF FILE 3.0ArchE/code_executor.py ---\n# ResonantiA Protocol v3.0 - code_executor.py\n# Executes code snippets securely using sandboxing (Docker recommended).\n# Includes mandatory Integrated Action Reflection (IAR) output.\n# WARNING: Improper configuration or use (especially disabling sandbox) is a MAJOR security risk.\n\nimport logging\nimport subprocess # For running external processes (docker, interpreters)\nimport tempfile # For creating temporary files/directories for code\nimport os\nimport json\nimport platform # Potentially useful for platform-specific commands/paths\nimport sys # To find python executable for subprocess fallback\nimport time # For timeouts and potentially timestamps\nimport shutil # Added for script copying\nfrom typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING # Expanded type hints\nimport asyncio\nfrom dataclasses import dataclass\nfrom .iar_components import IARValidator, ResonanceTracker\nfrom .utils.reflection_utils import create_reflection, ExecutionStatus\n\nif TYPE_CHECKING:\n    from .action_context import ActionContext\n\n# Use relative imports for configuration\ntry:\n    from . import config\nexcept ImportError:\n    # Fallback config if running standalone or package structure differs\n    class FallbackConfig:\n        CODE_EXECUTOR_SANDBOX_METHOD='subprocess'; CODE_EXECUTOR_USE_SANDBOX=True;\n        CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30;\n        CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\"\n    config = FallbackConfig(); logging.warning(\"config.py not found for code_executor, using fallback configuration.\")\n\nlogger = logging.getLogger(__name__)\n\n# --- IAR Helper Function (DEPRECATED) ---\n# The local _create_reflection is now deprecated in favor of the centralized utility.\n\n# --- Sandboxing Configuration & Checks ---\n# Read configuration settings, providing defaults if missing\nSANDBOX_METHOD_CONFIG = getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subprocess').lower()\nUSE_SANDBOX_CONFIG = getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True)\nDOCKER_IMAGE = getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\")\nTIMEOUT_SECONDS = int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', 60)) # Use integer timeout\nDOCKER_MEM_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\")\nDOCKER_CPU_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\")\n\n# Determine the actual sandbox method to use based on config\nsandbox_method_resolved: str\nif not USE_SANDBOX_CONFIG:\n    sandbox_method_resolved = 'none'\n    if SANDBOX_METHOD_CONFIG != 'none':\n        logger.warning(\"CODE_EXECUTOR_USE_SANDBOX is False in config. Overriding method to 'none'. SIGNIFICANT SECURITY RISK.\")\nelif SANDBOX_METHOD_CONFIG in ['docker', 'subprocess', 'none']:\n    sandbox_method_resolved = SANDBOX_METHOD_CONFIG\nelse:\n    logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' in config. Defaulting to 'subprocess'.\")\n    sandbox_method_resolved = 'subprocess' # Default to subprocess if config value is invalid\n\n# Check Docker availability if 'docker' method is resolved\nDOCKER_AVAILABLE = False\nif sandbox_method_resolved == 'docker':\n    try:\n        # Run 'docker info' to check daemon connectivity. Capture output to suppress it.\n        docker_info_cmd = [\"docker\", \"info\"]\n        process = subprocess.run(docker_info_cmd, check=True, capture_output=True, timeout=5)\n        DOCKER_AVAILABLE = True\n        logger.info(\"Docker runtime detected and appears responsive.\")\n    except FileNotFoundError:\n        logger.warning(\"Docker command not found. Docker sandbox unavailable. Will fallback if possible.\")\n    except subprocess.CalledProcessError as e:\n        logger.warning(f\"Docker daemon check failed (command {' '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\")\n    except subprocess.TimeoutExpired:\n        logger.warning(\"Docker daemon check timed out. Docker sandbox likely unavailable.\")\n    except Exception as e_docker_check:\n        logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\")\n\n# --- Main Execution Function ---\ndef execute_code(\n    inputs: Dict[str, Any]\n) -> Dict[str, Any]:\n    \"\"\"\n    Execute code in the specified language and return results with IAR reflection.\n    This action is now compliant with ResonantiA Protocol v3.1-CA IAR standards.\n\n    Args:\n        inputs (Dict): A dictionary containing:\n            - code (str): The code to execute.\n            - language (str): Programming language (default: python).\n            - timeout (int): Execution timeout in seconds.\n            - environment (Dict[str, str]): Optional environment variables.\n            - code_path (str): Path to a file containing the code.\n            - input_data (str): Optional string to pass to the script's stdin.\n    \"\"\"\n    start_time = time.time()\n    action_name = \"execute_code\"\n    \n    code = inputs.get(\"code\")\n    code_path = inputs.get(\"code_path\")\n    language = inputs.get(\"language\", \"python\")\n    timeout = inputs.get(\"timeout\", 30)\n    environment = inputs.get(\"environment\")\n    input_data = inputs.get(\"input_data\")\n\n    if code is None and code_path is None:\n        return {\n            \"error\": \"Either 'code' or 'code_path' must be provided.\",\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.FAILURE,\n                message=\"Input validation failed: 'code' or 'code_path' must be provided.\",\n                inputs=inputs,\n                execution_time=time.time() - start_time\n            )\n        }\n    \n    temp_file = None\n    try:\n        if code_path:\n            if not os.path.exists(code_path):\n                raise FileNotFoundError(f\"The specified code_path does not exist: {code_path}\")\n            exec_file = code_path\n        else:\n            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") as f:\n                f.write(code)\n                temp_file = f.name\n            exec_file = temp_file\n        \n        env = os.environ.copy()\n        if environment:\n            safe_env = {str(k): str(v) for k, v in environment.items()}\n            env.update(safe_env)\n        \n        if language != \"python\":\n             raise ValueError(f\"Unsupported language: {language}\")\n\n        result = subprocess.run(\n            [sys.executable, exec_file],\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n            env=env,\n            input=input_data\n        )\n        \n        execution_time = time.time() - start_time\n        \n        if result.returncode == 0:\n            outputs = {\"output\": result.stdout, \"stderr\": result.stderr}\n            return {\n                \"result\": outputs,\n                \"reflection\": create_reflection(\n                    action_name=action_name,\n                    status=ExecutionStatus.SUCCESS,\n                    message=\"Code executed successfully.\",\n                    inputs=inputs,\n                    outputs=outputs,\n                    confidence=1.0,\n                    execution_time=execution_time\n                )\n            }\n        else:\n            outputs = {\"output\": result.stdout, \"error\": result.stderr}\n            return {\n                \"result\": outputs,\n                \"reflection\": create_reflection(\n                    action_name=action_name,\n                    status=ExecutionStatus.FAILURE,\n                    message=f\"Code execution failed with return code {result.returncode}.\",\n                    inputs=inputs,\n                    outputs=outputs,\n                    confidence=0.1,\n                    potential_issues=[f\"Return Code: {result.returncode}\", result.stderr],\n                    execution_time=execution_time\n                )\n            }\n            \n    except subprocess.TimeoutExpired:\n        execution_time = time.time() - start_time\n        error_msg = f\"Execution timed out after {timeout} seconds\"\n        return {\n            \"error\": error_msg,\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.FAILURE,\n                message=error_msg,\n                inputs=inputs,\n                potential_issues=[\"TimeoutExpired\"],\n                execution_time=execution_time\n            )\n        }\n    except Exception as e:\n        execution_time = time.time() - start_time\n        error_msg = f\"An unexpected error occurred: {str(e)}\"\n        logger.error(f\"Error executing code for action '{action_name}': {error_msg}\", exc_info=True)\n        return {\n            \"error\": error_msg,\n            \"reflection\": create_reflection(\n                action_name=action_name,\n                status=ExecutionStatus.CRITICAL_FAILURE,\n                message=error_msg,\n                inputs=inputs,\n                potential_issues=[str(e)],\n                execution_time=execution_time\n            )\n        }\n    finally:\n        if temp_file and os.path.exists(temp_file):\n            os.remove(temp_file)\n\n# --- Internal Helper: Docker Execution ---\ndef _execute_with_docker(language: str, code: str, input_data: str, env_vars: Optional[Dict[str, str]] = None) -> Dict[str, Any]:\n    \"\"\"Executes code inside a Docker container. Returns partial result dict.\"\"\"\n    # Define language-specific interpreters and script filenames within the container\n    exec_details: Dict[str, Tuple[str, str]] = {\n        'python': ('python', 'script.py'),         # For executing Python code strings\n        'python_script': ('python', 'script.py'),  # For executing Python script files\n        'javascript': ('node', 'script.js'),\n        # Future: 'bash': ('bash', 'script.sh')\n    }\n\n    if language not in exec_details:\n        return {\"error\": f\"Docker execution unsupported for language: '{language}'.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n\n    interpreter, script_filename_in_container = exec_details[language]\n    temp_dir_obj = None # For ensuring cleanup with try/finally\n\n    try:\n        temp_dir_obj = tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\")\n        temp_dir = temp_dir_obj.name\n        \n        code_filepath_in_temp = os.path.join(temp_dir, script_filename_in_container)\n\n        if language.endswith('_script'): # e.g. 'python_script'\n            host_script_path = code # 'code' parameter is the host path to the script\n            if not os.path.isfile(host_script_path):\n                logger.error(f\"Script file for Docker execution not found on host: {host_script_path}\")\n                return {\"error\": f\"Script file not found on host: {host_script_path}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n            try:\n                shutil.copy2(host_script_path, code_filepath_in_temp)\n                logger.debug(f\"Copied script '{host_script_path}' to temporary Docker mount target '{code_filepath_in_temp}'.\")\n            except Exception as e_copy:\n                logger.error(f\"Failed to copy script '{host_script_path}' to temp dir '{temp_dir}': {e_copy}\")\n                return {\"error\": f\"Failed to copy script to temp dir for Docker: {e_copy}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n        else: # For language == 'python', 'javascript' (code strings)\n            try:\n                with open(code_filepath_in_temp, 'w', encoding='utf-8') as f:\n                    f.write(code)\n            except IOError as e_write:\n                logger.error(f\"Failed to write temporary code file for Docker: {e_write}\")\n                return {\"error\": f\"Failed to write temporary code file: {e_write}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"}\n\n        abs_temp_dir = os.path.abspath(temp_dir)\n        \n        docker_command = [\n            \"docker\", \"run\", \"--rm\", \"--network\", \"none\",\n            \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, # Enforce memory limits\n            \"--cpus\", DOCKER_CPU_LIMIT, # Enforce CPU limits\n            \"--security-opt=no-new-privileges\", # Prevent privilege escalation\n            \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", # Mount code read-only\n            \"-w\", \"/sandbox\", # Set working directory inside container\n        ]\n        \n        # Add environment variables from prompt_vars\n        if env_vars:\n            for key, value in env_vars.items():\n                docker_command.extend([\"-e\", f\"{key}={value}\"])\n\n        docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container])\n\n        logger.debug(f\"Executing Docker command: {' '.join(docker_command)}\")\n\n        # Run the Docker container process\n        try:\n            process = subprocess.run(\n                docker_command,\n                input=input_data.encode('utf-8'), # Pass input_data as stdin\n                capture_output=True, # Capture stdout/stderr\n                timeout=TIMEOUT_SECONDS, # Apply timeout\n                check=False # Do not raise exception on non-zero exit code\n            )\n\n            # Decode stdout/stderr, replacing errors\n            stdout = process.stdout.decode('utf-8', errors='replace').strip()\n            stderr = process.stderr.decode('utf-8', errors='replace').strip()\n            exit_code = process.returncode\n\n            if exit_code != 0:\n                logger.warning(f\"Docker execution finished with non-zero exit code {exit_code}. Stderr:\\n{stderr}\")\n            else:\n                logger.debug(f\"Docker execution successful (Exit Code: 0). Stdout:\\n{stdout}\")\n\n            return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None}\n\n        except subprocess.TimeoutExpired:\n            logger.error(f\"Docker execution timed out after {TIMEOUT_SECONDS}s.\")\n            # Try to cleanup container if possible (might fail if unresponsive)\n            # docker ps -q --filter \"ancestor=DOCKER_IMAGE\" | xargs -r docker stop | xargs -r docker rm\n            return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"Timeout Error\"}\n        except FileNotFoundError:\n            # Should be caught by ea",
    "compression_ratio": 2.0,
    "symbol_count": 15078,
    "timestamp": "2025-11-18T11:00:52.294869Z"
  },
  {
    "stage_name": "Nano",
    "content": "TERM: Class: FallbackConfig D: Execute code in specified language return results Φ reflection. action is now compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: - code (str): code to execute. - language (str): Programming language (default: python). - timeout (int): Execution timeout in seconds. - environment (Dict[str, str]): Optional environment variables. - code_path (str): Path to a file containing code. - input_data (str): Optional string to pass to script's stdin. BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/code_executor.py, type: python_class FULL I CODE (code_executor.py): ```python # --- START OF FILE 3.0Æ/code_executor.py --- # ResonantiA P v3.0 - code_executor.py # Executes code snippets securely using sandboxing (Docker recommended). # Includes mandatory Φ (Φ) output. # WARNING: Improper configuration or use (especially disabling sandbox) is a MAJOR security risk. import logging import subP # running external Pes (docker, interpreters) import tempfile # creating temporary files/directories code import os import json import platform # Potentially useful platform-specific commands/paths import sys # To find python executable subP fallback import time # timeouts potentially timestamps import shutil # Added script copying typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING # Expanded type hints import asyncio dataclasses import dataclass .Φ_components import ΦValidator, ResonanceTracker .utils.reflection_utils import create_reflection, ExecutionStatus if TYPE_CHECKING: .action_context import ActionContext # Use relative imports configuration try: . import config except ImportError: # Fallback config if running standalone or package structure differs class FallbackConfig: CODE_EXECUTOR_SANDBOX_METHOD='subP'; CODE_EXECUTOR_USE_SANDBOX=True; CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30; CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\" config = FallbackConfig(); logging.warning(\"config.py found code_executor, using fallback configuration.\") logger = logging.getLogger(__name__) # --- Φ Helper Function (DEPRECATED) --- # local _create_reflection is now deprecated in favor of centralized utility. # --- Sandboxing Configuration & Checks --- # Read configuration settings, providing defaults if missing SANDBOX_METHOD_CONFIG = getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subP').lower() USE_SANDBOX_CONFIG = getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True) DOCKER_IMAGE = getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\") TIMEOUT_SECONDS = int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', 60)) # Use integer timeout DOCKER_MEM_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\") DOCKER_CPU_LIMIT = getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\") # Determine actual sandbox method to use based on config sandbox_method_resolved: str if USE_SANDBOX_CONFIG: sandbox_method_resolved = 'none' if SANDBOX_METHOD_CONFIG != 'none': logger.warning(\"CODE_EXECUTOR_USE_SANDBOX is False in config. Overriding method to 'none'. SIGNIFICANT SECURITY RISK.\") elif SANDBOX_METHOD_CONFIG in ['docker', 'subP', 'none']: sandbox_method_resolved = SANDBOX_METHOD_CONFIG else: logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' in config. Defaulting to 'subP'.\") sandbox_method_resolved = 'subP' # Default to subP if config value is invalid # Check Docker availability if 'docker' method is resolved DOCKER_AVAILABLE = False if sandbox_method_resolved == 'docker': try: # Run 'docker info' to check daemon connectivity. Capture output to suppress it. docker_info_cmd = [\"docker\", \"info\"] P = subP.run(docker_info_cmd, check=True, capture_output=True, timeout=5) DOCKER_AVAILABLE = True logger.info(\"Docker runtime detected appears responsive.\") except FileNotFoundError: logger.warning(\"Docker command found. Docker sandbox unavailable. Will fallback if possible.\") except subP.CalledPError as e: logger.warning(f\"Docker daemon check failed (command {' '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\") except subP.TimeoutExpired: logger.warning(\"Docker daemon check timed out. Docker sandbox likely unavailable.\") except Exception as e_docker_check: logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\") # --- Main Execution Function --- def execute_code( inputs: Dict[str, Any] ) -> Dict[str, Any]: \"\"\" Execute code in specified language return results Φ reflection. action is now compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: - code (str): code to execute. - language (str): Programming language (default: python). - timeout (int): Execution timeout in seconds. - environment (Dict[str, str]): Optional environment variables. - code_path (str): Path to a file containing code. - input_data (str): Optional string to pass to script's stdin. \"\"\" start_time = time.time() action_name = \"execute_code\" code = inputs.get(\"code\") code_path = inputs.get(\"code_path\") language = inputs.get(\"language\", \"python\") timeout = inputs.get(\"timeout\", 30) environment = inputs.get(\"environment\") input_data = inputs.get(\"input_data\") if code is None code_path is None: return { \"error\": \"Either 'code' or 'code_path' must be provided.\", \"reflection\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=\"Input validation failed: 'code' or 'code_path' must be provided.\", inputs=inputs, execution_time=time.time() - start_time ) } temp_file = None try: if code_path: if os.path.exists(code_path): raise FileNotFoundError(f\" specified code_path does exist: {code_path}\") exec_file = code_path else: tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") as f: f.write(code) temp_file = f.name exec_file = temp_file env = os.environ.copy() if environment: safe_env = {str(k): str(v) k, v in environment.items()} env.update(safe_env) if language != \"python\": raise ValueError(f\"Unsupported language: {language}\") result = subP.run( [sys.executable, exec_file], capture_output=True, text=True, timeout=timeout, env=env, input=input_data ) execution_time = time.time() - start_time if result.returncode == 0: outputs = {\"output\": result.stdout, \"stderr\": result.stderr} return { \"result\": outputs, \"reflection\": create_reflection( action_name=action_name, status=ExecutionStatus.SUCCESS, message=\"Code executed successfully.\", inputs=inputs, outputs=outputs, confidence=1.0, execution_time=execution_time ) } else: outputs = {\"output\": result.stdout, \"error\": result.stderr} return { \"result\": outputs, \"reflection\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=f\"Code execution failed return code {result.returncode}.\", inputs=inputs, outputs=outputs, confidence=0.1, potential_issues=[f\"Return Code: {result.returncode}\", result.stderr], execution_time=execution_time ) } except subP.TimeoutExpired: execution_time = time.time() - start_time error_msg = f\"Execution timed out after {timeout} seconds\" return { \"error\": error_msg, \"reflection\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=error_msg, inputs=inputs, potential_issues=[\"TimeoutExpired\"], execution_time=execution_time ) } except Exception as e: execution_time = time.time() - start_time error_msg = f\"An unexpected error occurred: {str(e)}\" logger.error(f\"Error executing code action '{action_name}': {error_msg}\", exc_info=True) return { \"error\": error_msg, \"reflection\": create_reflection( action_name=action_name, status=ExecutionStatus.CRITICAL_FAILURE, message=error_msg, inputs=inputs, potential_issues=[str(e)], execution_time=execution_time ) } finally: if temp_file os.path.exists(temp_file): os.remove(temp_file) # --- Internal Helper: Docker Execution --- def _execute_with_docker(language: str, code: str, input_data: str, env_vars: Optional[Dict[str, str]] = None) -> Dict[str, Any]: \"\"\"Executes code inside a Docker container. Returns partial result dict.\"\"\" # Define language-specific interpreters script filenames within container exec_details: Dict[str, Tuple[str, str]] = { 'python': ('python', 'script.py'), # executing Python code strings 'python_script': ('python', 'script.py'), # executing Python script files 'javascript': ('node', 'script.js'), # Future: 'bash': ('bash', 'script.sh') } if language in exec_details: return {\"error\": f\"Docker execution unsupported language: '{language}'.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"} interpreter, script_filename_in_container = exec_details[language] temp_dir_obj = None # ensuring cleanup try/finally try: temp_dir_obj = tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\") temp_dir = temp_dir_obj.name code_filepath_in_temp = os.path.join(temp_dir, script_filename_in_container) if language.endswith('_script'): # e.g. 'python_script' host_script_path = code # 'code' parameter is host path to script if os.path.isfile(host_script_path): logger.error(f\"Script file Docker execution found on host: {host_script_path}\") return {\"error\": f\"Script file found on host: {host_script_path}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"} try: shutil.copy2(host_script_path, code_filepath_in_temp) logger.debug(f\"Copied script '{host_script_path}' to temporary Docker mount target '{code_filepath_in_temp}'.\") except Exception as e_copy: logger.error(f\"Failed to copy script '{host_script_path}' to temp dir '{temp_dir}': {e_copy}\") return {\"error\": f\"Failed to copy script to temp dir Docker: {e_copy}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"} else: # language == 'python', 'javascript' (code strings) try: open(code_filepath_in_temp, 'w', encoding='utf-8') as f: f.write(code) except IOError as e_write: logger.error(f\"Failed to write temporary code file Docker: {e_write}\") return {\"error\": f\"Failed to write temporary code file: {e_write}\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"\"} abs_temp_dir = os.path.abspath(temp_dir) docker_command = [ \"docker\", \"run\", \"--rm\", \"--network\", \"none\", \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, # Enforce memory limits \"--cpus\", DOCKER_CPU_LIMIT, # Enforce CPU limits \"--security-opt=no-new-privileges\", # Prevent privilege escalation \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", # Mount code read-only \"-w\", \"/sandbox\", # Set working directory inside container ] # Add environment variables prompt_vars if env_vars: key, value in env_vars.items(): docker_command.extend([\"-e\", f\"{key}={value}\"]) docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container]) logger.debug(f\"Executing Docker command: {' '.join(docker_command)}\") # Run Docker container P try: P = subP.run( docker_command, input=input_data.encode('utf-8'), # Pass input_data as stdin capture_output=True, # Capture stdout/stderr timeout=TIMEOUT_SECONDS, # Apply timeout check=False # Do raise exception on non-zero exit code ) # Decode stdout/stderr, replacing errors stdout = P.stdout.decode('utf-8', errors='replace').strip() stderr = P.stderr.decode('utf-8', errors='replace').strip() exit_code = P.returncode if exit_code != 0: logger.warning(f\"Docker execution finished non-zero exit code {exit_code}. Stderr:\\n{stderr}\") else: logger.debug(f\"Docker execution successful (Exit Code: 0). Stdout:\\n{stdout}\") return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None} except subP.TimeoutExpired: logger.error(f\"Docker execution timed out after {TIMEOUT_SECONDS}s.\") # Try to cleanup container if possible (might fail if unresponsive) # docker ps -q --filter \"ancestor=DOCKER_IMAGE\" | xargs -r docker stop | xargs -r docker rm return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": -1, \"stdout\": \"\", \"stderr\": \"Timeout Error\"} except FileNotFoundError: # Should be caught by ea",
    "compression_ratio": 2.5241483217544154,
    "symbol_count": 11947,
    "timestamp": "2025-11-18T11:00:52.353873Z"
  },
  {
    "stage_name": "Micro",
    "content": "TERM: Class: FallbackConfig D: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/code_executor.py, type: python_class FULL I CODE (code_executor.py): ```python START OF FILE 3.0Æ/code_executor.py ResonantiA P code_executor.py Executes snippets securely using sandboxing (Docker recommended). Includes mandatory Φ (Φ) output. WARNING: Improper configuration (especially disabling sandbox) MAJOR security risk. import logging import running external Pes (docker, interpreters) import tempfile creating temporary files/directories import import import platform Potentially useful platform-specific commands/paths import To python executable fallback import timeouts potentially timestamps import shutil Added script copying typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING Expanded hints import asyncio dataclasses import dataclass .Φ_components import ΦValidator, ResonanceTracker .utils.reflection_utils import create_reflection, ExecutionStatus TYPE_CHECKING: .action_context import ActionContext Use relative imports configuration import config except ImportError: Fallback config running standalone package structure differs class FallbackConfig: CODE_EXECUTOR_SANDBOX_METHOD='subP'; CODE_EXECUTOR_USE_SANDBOX=True; CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30; CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\" config FallbackConfig(); logging.warning(\"config.py found code_executor, using fallback configuration.\") logger logging.getLogger(__name__) Φ Helper Function (DEPRECATED) local _create_reflection deprecated favor centralized utility. Sandboxing Configuration Checks Read configuration settings, providing defaults missing SANDBOX_METHOD_CONFIG getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subP').lower() USE_SANDBOX_CONFIG getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True) DOCKER_IMAGE getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\") TIMEOUT_SECONDS int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', Use integer timeout DOCKER_MEM_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\") DOCKER_CPU_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\") Determine actual sandbox method ABM config sandbox_method_resolved: USE_SANDBOX_CONFIG: sandbox_method_resolved 'none' SANDBOX_METHOD_CONFIG 'none': logger.warning(\"CODE_EXECUTOR_USE_SANDBOX False config. Overriding method 'none'. SIGNIFICANT SECURITY RISK.\") SANDBOX_METHOD_CONFIG ['docker', 'subP', 'none']: sandbox_method_resolved SANDBOX_METHOD_CONFIG else: logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' config. Defaulting 'subP'.\") sandbox_method_resolved 'subP' Default config value invalid Check Docker availability 'docker' method resolved DOCKER_AVAILABLE False sandbox_method_resolved 'docker': Run 'docker info' check daemon connectivity. Capture output suppress docker_info_cmd [\"docker\", \"info\"] P subP.run(docker_info_cmd, check=True, capture_output=True, timeout=5) DOCKER_AVAILABLE True logger.info(\"Docker runtime detected appears responsive.\") except FileNotFoundError: logger.warning(\"Docker command found. Docker sandbox unavailable. fallback possible.\") except subP.CalledPError logger.warning(f\"Docker daemon check failed (command '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\") except subP.TimeoutExpired: logger.warning(\"Docker daemon check timed Docker sandbox likely unavailable.\") except Exception e_docker_check: logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\") Main Execution Function execute_code( inputs: Dict[str, Any] Dict[str, Any]: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. start_time time.time() action_name \"execute_code\" inputs.get(\"code\") code_path inputs.get(\"code_path\") language inputs.get(\"language\", \"python\") timeout inputs.get(\"timeout\", environment inputs.get(\"environment\") input_data inputs.get(\"input_data\") None code_path None: return \"error\": \"Either 'code' 'code_path' provided.\", \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=\"Input validation failed: 'code' 'code_path' provided.\", inputs=inputs, execution_time=time.time() start_time temp_file None code_path: os.path.exists(code_path): raise FileNotFoundError(f\" specified code_path exist: {code_path}\") exec_file code_path else: tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") f.write(code) temp_file f.name exec_file temp_file os.environ.copy() environment: safe_env {str(k): str(v) environment.items()} env.update(safe_env) language \"python\": raise ValueError(f\"Unsupported language: {language}\") result subP.run( [sys.executable, exec_file], capture_output=True, text=True, timeout=timeout, env=env, input=input_data execution_time time.time() start_time result.returncode outputs {\"output\": result.stdout, \"stderr\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.SUCCESS, message=\"Code executed successfully.\", inputs=inputs, outputs=outputs, confidence=1.0, execution_time=execution_time else: outputs {\"output\": result.stdout, \"error\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=f\"Code execution failed return {result.returncode}.\", inputs=inputs, outputs=outputs, confidence=0.1, potential_issues=[f\"Return Code: {result.returncode}\", result.stderr], execution_time=execution_time except subP.TimeoutExpired: execution_time time.time() start_time error_msg f\"Execution timed after {timeout} seconds\" return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=error_msg, inputs=inputs, potential_issues=[\"TimeoutExpired\"], execution_time=execution_time except Exception execution_time time.time() start_time error_msg unexpected error occurred: {str(e)}\" logger.error(f\"Error executing action '{action_name}': {error_msg}\", exc_info=True) return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.CRITICAL_FAILURE, message=error_msg, inputs=inputs, potential_issues=[str(e)], execution_time=execution_time finally: temp_file os.path.exists(temp_file): os.remove(temp_file) Internal Helper: Docker Execution _execute_with_docker(language: code: input_data: env_vars: Optional[Dict[str, str]] None) Dict[str, Any]: \"\"\"Executes inside Docker container. Returns partial result dict.\"\"\" Define language-specific interpreters script filenames within container exec_details: Dict[str, Tuple[str, str]] 'python': ('python', 'script.py'), executing Python strings 'python_script': ('python', 'script.py'), executing Python script files 'javascript': ('node', 'script.js'), Future: 'bash': ('bash', 'script.sh') language exec_details: return {\"error\": f\"Docker execution unsupported language: '{language}'.\", \"exit_code\": \"stdout\": \"stderr\": interpreter, script_filename_in_container exec_details[language] temp_dir_obj None ensuring cleanup try/finally temp_dir_obj tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\") temp_dir temp_dir_obj.name code_filepath_in_temp os.path.join(temp_dir, script_filename_in_container) language.endswith('_script'): 'python_script' host_script_path 'code' parameter script os.path.isfile(host_script_path): logger.error(f\"Script Docker execution found host: {host_script_path}\") return {\"error\": f\"Script found host: {host_script_path}\", \"exit_code\": \"stdout\": \"stderr\": shutil.copy2(host_script_path, code_filepath_in_temp) logger.debug(f\"Copied script '{host_script_path}' temporary Docker mount target '{code_filepath_in_temp}'.\") except Exception e_copy: logger.error(f\"Failed script '{host_script_path}' '{temp_dir}': {e_copy}\") return {\"error\": f\"Failed script Docker: {e_copy}\", \"exit_code\": \"stdout\": \"stderr\": else: language 'python', 'javascript' (code strings) open(code_filepath_in_temp, encoding='utf-8') f.write(code) except IOError e_write: logger.error(f\"Failed write temporary Docker: {e_write}\") return {\"error\": f\"Failed write temporary file: {e_write}\", \"exit_code\": \"stdout\": \"stderr\": abs_temp_dir os.path.abspath(temp_dir) docker_command \"docker\", \"run\", \"--rm\", \"--network\", \"none\", \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, Enforce memory limits \"--cpus\", DOCKER_CPU_LIMIT, Enforce CPU limits \"--security-opt=no-new-privileges\", Prevent privilege escalation \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", Mount read-only \"-w\", \"/sandbox\", Set working directory inside container Add environment variables prompt_vars env_vars: value env_vars.items(): docker_command.extend([\"-e\", f\"{key}={value}\"]) docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container]) logger.debug(f\"Executing Docker command: '.join(docker_command)}\") Run Docker container P P subP.run( docker_command, input=input_data.encode('utf-8'), Pass input_data stdin capture_output=True, Capture stdout/stderr timeout=TIMEOUT_SECONDS, Apply timeout check=False Do raise exception non-zero Decode stdout/stderr, replacing errors stdout P.stdout.decode('utf-8', errors='replace').strip() stderr P.stderr.decode('utf-8', errors='replace').strip() exit_code P.returncode exit_code logger.warning(f\"Docker execution finished non-zero {exit_code}. Stderr:\\n{stderr}\") else: logger.debug(f\"Docker execution successful (Exit Code: Stdout:\\n{stdout}\") return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None} except subP.TimeoutExpired: logger.error(f\"Docker execution timed after {TIMEOUT_SECONDS}s.\") Try cleanup container possible unresponsive) docker --filter \"ancestor=DOCKER_IMAGE\" xargs docker xargs docker return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": \"stdout\": \"stderr\": \"Timeout Error\"} except FileNotFoundError: caught",
    "compression_ratio": 2.8052093023255815,
    "symbol_count": 10750,
    "timestamp": "2025-11-18T11:00:52.566144Z"
  },
  {
    "stage_name": "Pico",
    "content": "TERM: Class: FallbackConfig D: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/code_executor.py, type: python_class FULL I CODE (code_executor.py): ```python START OF FILE 3.0Æ/code_executor.py ResonantiA P code_executor.py Executes snippets securely using sandboxing (Docker recommended). Includes mandatory Φ (Φ) output. WARNING: Improper configuration (especially disabling sandbox) MAJOR security risk. import logging import running external Pes (docker, interpreters) import tempfile creating temporary files/directories import import import platform Potentially useful platform-specific commands/paths import To python executable fallback import timeouts potentially timestamps import shutil Added script copying typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING Expanded hints import asyncio dataclasses import dataclass .Φ_components import ΦValidator, ResonanceTracker .utils.reflection_utils import create_reflection, ExecutionStatus TYPE_CHECKING: .action_context import ActionContext Use relative imports configuration import config except ImportError: Fallback config running standalone package structure differs class FallbackConfig: CODE_EXECUTOR_SANDBOX_METHOD='subP'; CODE_EXECUTOR_USE_SANDBOX=True; CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30; CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\" config FallbackConfig(); logging.warning(\"config.py found code_executor, using fallback configuration.\") logger logging.getLogger(__name__) Φ Helper Function (DEPRECATED) local _create_reflection deprecated favor centralized utility. Sandboxing Configuration Checks Read configuration settings, providing defaults missing SANDBOX_METHOD_CONFIG getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subP').lower() USE_SANDBOX_CONFIG getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True) DOCKER_IMAGE getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\") TIMEOUT_SECONDS int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', Use integer timeout DOCKER_MEM_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\") DOCKER_CPU_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\") Determine actual sandbox method ABM config sandbox_method_resolved: USE_SANDBOX_CONFIG: sandbox_method_resolved 'none' SANDBOX_METHOD_CONFIG 'none': logger.warning(\"CODE_EXECUTOR_USE_SANDBOX False config. Overriding method 'none'. SIGNIFICANT SECURITY RISK.\") SANDBOX_METHOD_CONFIG ['docker', 'subP', 'none']: sandbox_method_resolved SANDBOX_METHOD_CONFIG else: logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' config. Defaulting 'subP'.\") sandbox_method_resolved 'subP' Default config value invalid Check Docker availability 'docker' method resolved DOCKER_AVAILABLE False sandbox_method_resolved 'docker': Run 'docker info' check daemon connectivity. Capture output suppress docker_info_cmd [\"docker\", \"info\"] P subP.run(docker_info_cmd, check=True, capture_output=True, timeout=5) DOCKER_AVAILABLE True logger.info(\"Docker runtime detected appears responsive.\") except FileNotFoundError: logger.warning(\"Docker command found. Docker sandbox unavailable. fallback possible.\") except subP.CalledPError logger.warning(f\"Docker daemon check failed (command '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\") except subP.TimeoutExpired: logger.warning(\"Docker daemon check timed Docker sandbox likely unavailable.\") except Exception e_docker_check: logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\") Main Execution Function execute_code( inputs: Dict[str, Any] Dict[str, Any]: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): A dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. start_time time.time() action_name \"execute_code\" inputs.get(\"code\") code_path inputs.get(\"code_path\") language inputs.get(\"language\", \"python\") timeout inputs.get(\"timeout\", environment inputs.get(\"environment\") input_data inputs.get(\"input_data\") None code_path None: return \"error\": \"Either 'code' 'code_path' provided.\", \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=\"Input validation failed: 'code' 'code_path' provided.\", inputs=inputs, execution_time=time.time() start_time temp_file None code_path: os.path.exists(code_path): raise FileNotFoundError(f\" specified code_path exist: {code_path}\") exec_file code_path else: tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") f.write(code) temp_file f.name exec_file temp_file os.environ.copy() environment: safe_env {str(k): str(v) environment.items()} env.update(safe_env) language \"python\": raise ValueError(f\"Unsupported language: {language}\") result subP.run( [sys.executable, exec_file], capture_output=True, text=True, timeout=timeout, env=env, input=input_data execution_time time.time() start_time result.returncode outputs {\"output\": result.stdout, \"stderr\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.SUCCESS, message=\"Code executed successfully.\", inputs=inputs, outputs=outputs, confidence=1.0, execution_time=execution_time else: outputs {\"output\": result.stdout, \"error\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=f\"Code execution failed return {result.returncode}.\", inputs=inputs, outputs=outputs, confidence=0.1, potential_issues=[f\"Return Code: {result.returncode}\", result.stderr], execution_time=execution_time except subP.TimeoutExpired: execution_time time.time() start_time error_msg f\"Execution timed after {timeout} seconds\" return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=error_msg, inputs=inputs, potential_issues=[\"TimeoutExpired\"], execution_time=execution_time except Exception execution_time time.time() start_time error_msg unexpected error occurred: {str(e)}\" logger.error(f\"Error executing action '{action_name}': {error_msg}\", exc_info=True) return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.CRITICAL_FAILURE, message=error_msg, inputs=inputs, potential_issues=[str(e)], execution_time=execution_time finally: temp_file os.path.exists(temp_file): os.remove(temp_file) Internal Helper: Docker Execution _execute_with_docker(language: code: input_data: env_vars: Optional[Dict[str, str]] None) Dict[str, Any]: \"\"\"Executes inside Docker container. Returns partial result dict.\"\"\" Define language-specific interpreters script filenames within container exec_details: Dict[str, Tuple[str, str]] 'python': ('python', 'script.py'), executing Python strings 'python_script': ('python', 'script.py'), executing Python script files 'javascript': ('node', 'script.js'), Future: 'bash': ('bash', 'script.sh') language exec_details: return {\"error\": f\"Docker execution unsupported language: '{language}'.\", \"exit_code\": \"stdout\": \"stderr\": interpreter, script_filename_in_container exec_details[language] temp_dir_obj None ensuring cleanup try/finally temp_dir_obj tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\") temp_dir temp_dir_obj.name code_filepath_in_temp os.path.join(temp_dir, script_filename_in_container) language.endswith('_script'): 'python_script' host_script_path 'code' parameter script os.path.isfile(host_script_path): logger.error(f\"Script Docker execution found host: {host_script_path}\") return {\"error\": f\"Script found host: {host_script_path}\", \"exit_code\": \"stdout\": \"stderr\": shutil.copy2(host_script_path, code_filepath_in_temp) logger.debug(f\"Copied script '{host_script_path}' temporary Docker mount target '{code_filepath_in_temp}'.\") except Exception e_copy: logger.error(f\"Failed script '{host_script_path}' '{temp_dir}': {e_copy}\") return {\"error\": f\"Failed script Docker: {e_copy}\", \"exit_code\": \"stdout\": \"stderr\": else: language 'python', 'javascript' (code strings) open(code_filepath_in_temp, encoding='utf-8') f.write(code) except IOError e_write: logger.error(f\"Failed write temporary Docker: {e_write}\") return {\"error\": f\"Failed write temporary file: {e_write}\", \"exit_code\": \"stdout\": \"stderr\": abs_temp_dir os.path.abspath(temp_dir) docker_command \"docker\", \"run\", \"--rm\", \"--network\", \"none\", \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, Enforce memory limits \"--cpus\", DOCKER_CPU_LIMIT, Enforce CPU limits \"--security-opt=no-new-privileges\", Prevent privilege escalation \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", Mount read-only \"-w\", \"/sandbox\", Set working directory inside container Add environment variables prompt_vars env_vars: value env_vars.items(): docker_command.extend([\"-e\", f\"{key}={value}\"]) docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container]) logger.debug(f\"Executing Docker command: '.join(docker_command)}\") Run Docker container P P subP.run( docker_command, input=input_data.encode('utf-8'), Pass input_data stdin capture_output=True, Capture stdout/stderr timeout=TIMEOUT_SECONDS, Apply timeout check=False Do raise exception non-zero Decode stdout/stderr, replacing errors stdout P.stdout.decode('utf-8', errors='replace').strip() stderr P.stderr.decode('utf-8', errors='replace').strip() exit_code P.returncode exit_code logger.warning(f\"Docker execution finished non-zero {exit_code}. Stderr:\\n{stderr}\") else: logger.debug(f\"Docker execution successful (Exit Code: Stdout:\\n{stdout}\") return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None} except subP.TimeoutExpired: logger.error(f\"Docker execution timed after {TIMEOUT_SECONDS}s.\") Try cleanup container possible unresponsive) docker --filter \"ancestor=DOCKER_IMAGE\" xargs docker xargs docker return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": \"stdout\": \"stderr\": \"Timeout Error\"} except FileNotFoundError: caught",
    "compression_ratio": 2.8052093023255815,
    "symbol_count": 10750,
    "timestamp": "2025-11-18T11:00:52.788297Z"
  },
  {
    "stage_name": "Femto",
    "content": "TERM: Class: FallbackConfig D: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/code_executor.py, type: python_class FULL I CODE (code_executor.py): ```python START FILE 3.0Æ/code_executor.py ResonantiA P code_executor.py Executes snippets securely using sandboxing (Docker recommended). Includes mandatory Φ (Φ) output. WARNING: Improper configuration (especially disabling sandbox) MAJOR security risk. import logging import running external Pes (docker, interpreters) import tempfile creating temporary files/directories import import import platform Potentially useful platform-specific commands/paths import python executable fallback import timeouts potentially timestamps import shutil Added script copying typing import Dict, Any, Optional, List, Tuple, TYPE_CHECKING Expanded hints import asyncio dataclasses import dataclass .Φ_components import ΦValidator, ResonanceTracker .utils.reflection_utils import create_reflection, ExecutionStatus TYPE_CHECKING: .action_context import ActionContext Use relative imports configuration import config except ImportError: Fallback config running standalone package structure differs class FallbackConfig: CODE_EXECUTOR_SANDBOX_METHOD='subP'; CODE_EXECUTOR_USE_SANDBOX=True; CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30; CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\" config FallbackConfig(); logging.warning(\"config.py found code_executor, using fallback configuration.\") logger logging.getLogger(__name__) Φ Helper Function (DEPRECATED) local _create_reflection deprecated favor centralized utility. Sandboxing Configuration Checks Read configuration settings, providing defaults missing SANDBOX_METHOD_CONFIG getattr(config, 'CODE_EXECUTOR_SANDBOX_METHOD', 'subP').lower() USE_SANDBOX_CONFIG getattr(config, 'CODE_EXECUTOR_USE_SANDBOX', True) DOCKER_IMAGE getattr(config, 'CODE_EXECUTOR_DOCKER_IMAGE', \"python:3.11-slim\") TIMEOUT_SECONDS int(getattr(config, 'CODE_EXECUTOR_TIMEOUT', Use integer timeout DOCKER_MEM_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', \"512m\") DOCKER_CPU_LIMIT getattr(config, 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', \"1.0\") Determine actual sandbox method ABM config sandbox_method_resolved: USE_SANDBOX_CONFIG: sandbox_method_resolved 'none' SANDBOX_METHOD_CONFIG 'none': logger.warning(\"CODE_EXECUTOR_USE_SANDBOX False config. Overriding method 'none'. SIGNIFICANT SECURITY RISK.\") SANDBOX_METHOD_CONFIG ['docker', 'subP', 'none']: sandbox_method_resolved SANDBOX_METHOD_CONFIG else: logger.warning(f\"Invalid CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' config. Defaulting 'subP'.\") sandbox_method_resolved 'subP' Default config value invalid Check Docker availability 'docker' method resolved DOCKER_AVAILABLE False sandbox_method_resolved 'docker': Run 'docker info' check daemon connectivity. Capture output suppress docker_info_cmd [\"docker\", \"info\"] P subP.run(docker_info_cmd, check=True, capture_output=True, timeout=5) DOCKER_AVAILABLE True logger.info(\"Docker runtime detected appears responsive.\") except FileNotFoundError: logger.warning(\"Docker command found. Docker sandbox unavailable. fallback possible.\") except subP.CalledPError logger.warning(f\"Docker daemon check failed (command '.join(docker_info_cmd)} returned error {e.returncode}). Docker sandbox likely unavailable. Stderr: {e.stderr.decode(errors='ignore')}\") except subP.TimeoutExpired: logger.warning(\"Docker daemon check timed Docker sandbox likely unavailable.\") except Exception e_docker_check: logger.warning(f\"Unexpected error checking Docker status: {e_docker_check}. Assuming Docker unavailable.\") Main Execution Function execute_code( inputs: Dict[str, Any] Dict[str, Any]: Execute specified language return results Φ CRC. action compliant ResonantiA P v3.1-CA Φ standards. Args: inputs (Dict): dictionary containing: (str): execute. language (str): Programming language (default: python). timeout (int): Execution timeout seconds. environment (Dict[str, str]): Optional environment variables. code_path (str): Path containing code. input_data (str): Optional string script's stdin. start_time time.time() action_name \"execute_code\" inputs.get(\"code\") code_path inputs.get(\"code_path\") language inputs.get(\"language\", \"python\") timeout inputs.get(\"timeout\", environment inputs.get(\"environment\") input_data inputs.get(\"input_data\") None code_path None: return \"error\": \"Either 'code' 'code_path' provided.\", \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=\"Input validation failed: 'code' 'code_path' provided.\", inputs=inputs, execution_time=time.time() start_time temp_file None code_path: os.path.exists(code_path): raise FileNotFoundError(f\" specified code_path exist: {code_path}\") exec_file code_path else: tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f\".{language}\") f.write(code) temp_file f.name exec_file temp_file os.environ.copy() environment: safe_env {str(k): str(v) environment.items()} env.update(safe_env) language \"python\": raise ValueError(f\"Unsupported language: {language}\") result subP.run( [sys.executable, exec_file], capture_output=True, text=True, timeout=timeout, env=env, input=input_data execution_time time.time() start_time result.returncode outputs {\"output\": result.stdout, \"stderr\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.SUCCESS, message=\"Code executed successfully.\", inputs=inputs, outputs=outputs, confidence=1.0, execution_time=execution_time else: outputs {\"output\": result.stdout, \"error\": result.stderr} return \"result\": outputs, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=f\"Code execution failed return {result.returncode}.\", inputs=inputs, outputs=outputs, confidence=0.1, potential_issues=[f\"Return Code: {result.returncode}\", result.stderr], execution_time=execution_time except subP.TimeoutExpired: execution_time time.time() start_time error_msg f\"Execution timed after {timeout} seconds\" return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.FAILURE, message=error_msg, inputs=inputs, potential_issues=[\"TimeoutExpired\"], execution_time=execution_time except Exception execution_time time.time() start_time error_msg unexpected error occurred: {str(e)}\" logger.error(f\"Error executing action '{action_name}': {error_msg}\", exc_info=True) return \"error\": error_msg, \"CRC\": create_reflection( action_name=action_name, status=ExecutionStatus.CRITICAL_FAILURE, message=error_msg, inputs=inputs, potential_issues=[str(e)], execution_time=execution_time finally: temp_file os.path.exists(temp_file): os.remove(temp_file) Internal Helper: Docker Execution _execute_with_docker(language: code: input_data: env_vars: Optional[Dict[str, str]] None) Dict[str, Any]: \"\"\"Executes inside Docker container. Returns partial result dict.\"\"\" Define language-specific interpreters script filenames within container exec_details: Dict[str, Tuple[str, str]] 'python': ('python', 'script.py'), executing Python strings 'python_script': ('python', 'script.py'), executing Python script files 'javascript': ('node', 'script.js'), Future: 'bash': ('bash', 'script.sh') language exec_details: return {\"error\": f\"Docker execution unsupported language: '{language}'.\", \"exit_code\": \"stdout\": \"stderr\": interpreter, script_filename_in_container exec_details[language] temp_dir_obj None ensuring cleanup try/finally temp_dir_obj tempfile.TemporaryDirectory(prefix=\"resonatia_docker_exec_\") temp_dir temp_dir_obj.name code_filepath_in_temp os.path.join(temp_dir, script_filename_in_container) language.endswith('_script'): 'python_script' host_script_path 'code' parameter script os.path.isfile(host_script_path): logger.error(f\"Script Docker execution found host: {host_script_path}\") return {\"error\": f\"Script found host: {host_script_path}\", \"exit_code\": \"stdout\": \"stderr\": shutil.copy2(host_script_path, code_filepath_in_temp) logger.debug(f\"Copied script '{host_script_path}' temporary Docker mount target '{code_filepath_in_temp}'.\") except Exception e_copy: logger.error(f\"Failed script '{host_script_path}' '{temp_dir}': {e_copy}\") return {\"error\": f\"Failed script Docker: {e_copy}\", \"exit_code\": \"stdout\": \"stderr\": else: language 'python', 'javascript' (code strings) open(code_filepath_in_temp, encoding='utf-8') f.write(code) except IOError e_write: logger.error(f\"Failed write temporary Docker: {e_write}\") return {\"error\": f\"Failed write temporary file: {e_write}\", \"exit_code\": \"stdout\": \"stderr\": abs_temp_dir os.path.abspath(temp_dir) docker_command \"docker\", \"run\", \"--rm\", \"--network\", \"none\", \"--memory\", DOCKER_MEM_LIMIT, \"--memory-swap\", DOCKER_MEM_LIMIT, Enforce memory limits \"--cpus\", DOCKER_CPU_LIMIT, Enforce CPU limits \"--security-opt=no-new-privileges\", Prevent privilege escalation \"-v\", f\"{abs_temp_dir}:/sandbox:ro\", Mount read-only \"-w\", \"/sandbox\", Set working directory inside container Add environment variables prompt_vars env_vars: value env_vars.items(): docker_command.extend([\"-e\", f\"{key}={value}\"]) docker_command.extend([DOCKER_IMAGE, interpreter, script_filename_in_container]) logger.debug(f\"Executing Docker command: '.join(docker_command)}\") Run Docker container P P subP.run( docker_command, input=input_data.encode('utf-8'), Pass input_data stdin capture_output=True, Capture stdout/stderr timeout=TIMEOUT_SECONDS, Apply timeout check=False Do raise exception non-zero Decode stdout/stderr, replacing errors stdout P.stdout.decode('utf-8', errors='replace').strip() stderr P.stderr.decode('utf-8', errors='replace').strip() exit_code P.returncode exit_code logger.warning(f\"Docker execution finished non-zero {exit_code}. Stderr:\\n{stderr}\") else: logger.debug(f\"Docker execution successful (Exit Code: Stdout:\\n{stdout}\") return {\"stdout\": stdout, \"stderr\": stderr, \"exit_code\": exit_code, \"error\": None} except subP.TimeoutExpired: logger.error(f\"Docker execution timed after {TIMEOUT_SECONDS}s.\") Try cleanup container possible unresponsive) docker --filter \"ancestor=DOCKER_IMAGE\" xargs docker xargs docker return {\"error\": f\"TimeoutExpired: Execution exceeded {TIMEOUT_SECONDS}s limit.\", \"exit_code\": \"stdout\": \"stderr\": \"Timeout Error\"} except FileNotFoundError: caught",
    "compression_ratio": 2.8078212290502793,
    "symbol_count": 10740,
    "timestamp": "2025-11-18T11:00:53.046872Z"
  },
  {
    "stage_name": "Atto",
    "content": "TERM: Class: FallbackConfig D: Execute Φ CRC. ResonantiA P Φ Args: Programming Execution Optional Path Optional BLUEPRINT DETAILS: Extracted /mnt/3626C55326C514B1/Happier/Three_PointO_Æ/code_executor.py, FULL I CODE START FILE 3.0Æ/code_executor.py ResonantiA P Executes Includes Φ (Φ) WARNING: Improper MAJOR Pes Potentially Added Dict, Any, Optional, List, Tuple, TYPE_CHECKING Expanded .Φ_components ΦValidator, ResonanceTracker ExecutionStatus TYPE_CHECKING: ActionContext Use ImportError: Fallback FallbackConfig: CODE_EXECUTOR_SANDBOX_METHOD='subP'; CODE_EXECUTOR_USE_SANDBOX=True; CODE_EXECUTOR_DOCKER_IMAGE='python:3.11-slim'; CODE_EXECUTOR_TIMEOUT=30; CODE_EXECUTOR_DOCKER_MEM_LIMIT=\"256m\"; CODE_EXECUTOR_DOCKER_CPU_LIMIT=\"0.5\" FallbackConfig(); Φ Helper Function (DEPRECATED) Sandboxing Configuration Checks Read SANDBOX_METHOD_CONFIG 'CODE_EXECUTOR_SANDBOX_METHOD', USE_SANDBOX_CONFIG 'CODE_EXECUTOR_USE_SANDBOX', True) DOCKER_IMAGE 'CODE_EXECUTOR_DOCKER_IMAGE', TIMEOUT_SECONDS 'CODE_EXECUTOR_TIMEOUT', Use DOCKER_MEM_LIMIT 'CODE_EXECUTOR_DOCKER_MEM_LIMIT', DOCKER_CPU_LIMIT 'CODE_EXECUTOR_DOCKER_CPU_LIMIT', Determine ABM USE_SANDBOX_CONFIG: SANDBOX_METHOD_CONFIG False Overriding SIGNIFICANT SECURITY RISK.\") SANDBOX_METHOD_CONFIG SANDBOX_METHOD_CONFIG CODE_EXECUTOR_SANDBOX_METHOD '{SANDBOX_METHOD_CONFIG}' Defaulting Default Check Docker DOCKER_AVAILABLE False Run Capture P DOCKER_AVAILABLE True FileNotFoundError: Docker Docker Stderr: Docker Exception Docker Assuming Docker Main Execution Function Dict[str, Any] Dict[str, Any]: Execute Φ CRC. ResonantiA P Φ Args: Programming Execution Optional Path Optional None None: \"CRC\": None FileNotFoundError(f\" ValueError(f\"Unsupported \"CRC\": \"CRC\": Code: \"CRC\": Exception \"CRC\": Internal Helper: Docker Execution Optional[Dict[str, None) Dict[str, Any]: Docker Returns Define Dict[str, Tuple[str, Python Python Future: None Docker Docker Exception Docker: IOError Docker: DOCKER_MEM_LIMIT, DOCKER_MEM_LIMIT, Enforce DOCKER_CPU_LIMIT, Enforce CPU Prevent Mount Set Add Docker Run Docker P P Pass Capture Apply Do Decode P.stdout.decode('utf-8', P.stderr.decode('utf-8', P.returncode Stderr:\\n{stderr}\") Code: Stdout:\\n{stdout}\") None} Try Execution Error\"} FileNotFoundError:",
    "compression_ratio": 13.474530831099196,
    "symbol_count": 2238,
    "timestamp": "2025-11-18T11:00:53.332287Z"
  },
  {
    "stage_name": "Zepto",
    "content": "Φ|Φ|Æ|Æ|Φ",
    "compression_ratio": 3350.6666666666665,
    "symbol_count": 9,
    "timestamp": "2025-11-18T11:00:53.342879Z"
  }
]