[
  {
    "stage_name": "Narrative",
    "content": "TERM: Selenium\n\nDEFINITION:\nA web automation framework that enables browser control and web scraping capabilities. It provides tools for automated web navigation, content extraction, and dynamic web interaction.\n\nBLUEPRINT DETAILS:\nSelenium integration in Four_PointO_ArchE/tools/perception_engine.py with PerceptionEngine class using Selenium WebDriver for advanced web browsing and content extraction.\n\nFULL IMPLEMENTATION CODE (perception_engine.py):\n```python\nfrom typing import Dict, Any, Tuple\nimport os\nimport re\nfrom .utils import create_iar\nfrom .llm_tool import generate_text\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service as ChromeService\nfrom webdriver_manager.chrome import ChromeDriverManager\nfrom bs4 import BeautifulSoup\n\nclass PerceptionEngine:\n    \"\"\"\n    An autonomous browsing agent that combines a headless browser\n    with an LLM for intelligent page analysis and interaction.\n    \"\"\"\n    def __init__(self, headless: bool = True):\n        self.driver = self._initialize_driver(headless)\n\n    def _initialize_driver(self, headless: bool = True):\n        \"\"\"Initializes the Selenium WebDriver with enhanced anti-detection measures.\"\"\"\n        options = webdriver.ChromeOptions()\n        \n        # Enhanced anti-detection measures\n        if headless:\n            options.add_argument('--headless=new')  # Use new headless mode\n        options.add_argument('--no-sandbox')\n        options.add_argument('--disable-dev-shm-usage')\n        options.add_argument('--disable-blink-features=AutomationControlled')\n        options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\n        options.add_experimental_option('useAutomationExtension', False)\n        \n        # More realistic user agent\n        options.add_argument(\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\n        \n        # Additional stealth options\n        options.add_argument('--disable-web-security')\n        options.add_argument('--allow-running-insecure-content')\n        options.add_argument('--disable-extensions')\n        options.add_argument('--disable-plugins')\n        options.add_argument('--disable-images')  # Faster loading\n        options.add_argument('--disable-javascript')  # Avoid dynamic content issues\n        \n        try:\n            driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)\n            \n            # Execute script to remove webdriver property\n            driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: () => undefined})\")\n            \n            return driver\n        except Exception as e:\n            print(f\"FATAL: Could not initialize WebDriver: {e}\")\n            return None\n\n    def browse_and_summarize(self, url: str) -> str:\n        \"\"\"Navigates to a URL and provides a high-level summary of its content.\"\"\"\n        if not self.driver:\n            return \"WebDriver not initialized.\"\n        \n        try:\n            # Add random delay to appear more human-like\n            import time\n            import random\n            time.sleep(random.uniform(1, 3))\n            \n            self.driver.get(url)\n            self.driver.implicitly_wait(10)\n            \n            # Check if we hit a CAPTCHA or blocking page\n            page_source = self.driver.page_source.lower()\n            if \"captcha\" in page_source or \"unusual traffic\" in page_source or \"blocked\" in page_source:\n                return f'{{\"summary\": \"Access blocked by {url} due to bot detection. The page requires CAPTCHA verification or is blocking automated requests. This is a common issue with search engines and other sites that detect automated browsing.\"}}'\n            \n            # Try to extract search results if it's a Google search\n            if \"google.com/search\" in url:\n                return self._extract_google_search_results()\n            \n            # For other pages, use the original summarization\n            page_content = BeautifulSoup(self.driver.page_source, 'lxml').get_text()\n            \n            # Use the LLM to summarize the raw text content\n            summary_prompt = f\"Please provide a concise summary of the following web page content:\\n\\n{page_content[:4000]}\" # Limit context size\n            \n            llm_inputs = {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} # Use a fast model for summarization\n            summary_result, _ = generate_text(llm_inputs)\n            \n            return summary_result.get(\"generated_text\", \"Could not summarize content.\")\n            \n        except Exception as e:\n            return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}'\n    \n    def _extract_google_search_results(self) -> str:\n        \"\"\"Extract search results from Google search page.\"\"\"\n        try:\n            # Look for search result elements\n            results = []\n            \n            # Try different selectors for search results\n            selectors = [\n                'div.g',  # Standard Google results\n                'div[data-ved]',  # Alternative selector\n                'div.rc',  # Another common selector\n                'h3'  # Result titles\n            ]\n            \n            for selector in selectors:\n                elements = self.driver.find_elements(\"css selector\", selector)\n                if elements:\n                    for element in elements[:5]:  # Limit to first 5 results\n                        try:\n                            text = element.text.strip()\n                            if text and len(text) > 10:  # Filter out empty or very short results\n                                results.append(text)\n                        except:\n                            continue\n                    break\n            \n            if results:\n                summary = f\"Found {len(results)} search results: \" + \" | \".join(results[:3])\n                return f'{{\"summary\": \"{summary}\"}}'\n            else:\n                return '{\"summary\": \"No search results found on the page. The page may be blocked or the search query did not return results.\"}'\n                \n        except Exception as e:\n            return f'{{\"summary\": \"Error extracting search results: {str(e)}\"}}'\n\n    def navigate(self, url: str):\n        \"\"\"Navigate to a URL.\"\"\"\n        if self.driver:\n            self.driver.get(url)\n            self.driver.implicitly_wait(5)\n\n    def wait_for(self, selector: str):\n        \"\"\"Wait for an element to be present.\"\"\"\n        if self.driver:\n            from selenium.webdriver.common.by import By\n            from selenium.webdriver.support.ui import WebDriverWait\n            from selenium.webdriver.support import expected_conditions as EC\n            try:\n                WebDriverWait(self.driver, 10).until(\n                    EC.presence_of_element_located((By.CSS_SELECTOR, selector))\n                )\n            except Exception as e:\n                print(f\"Warning: Element {selector} not found: {e}\")\n\n    def extract_text(self, selector: str) -> str:\n        \"\"\"Extract text from elements matching the selector.\"\"\"\n        if not self.driver:\n            return \"\"\n        try:\n            from selenium.webdriver.common.by import By\n            elements = self.driver.find_elements(By.CSS_SELECTOR, selector)\n            return \" \".join([elem.text for elem in elements if elem.text])\n        except Exception as e:\n            print(f\"Warning: Could not extract text from {selector}: {e}\")\n            return \"\"\n\n    def click(self, selector: str):\n        \"\"\"Click an element matching the selector.\"\"\"\n        if self.driver:\n            try:\n                from selenium.webdriver.common.by import By\n                element = self.driver.find_element(By.CSS_SELECTOR, selector)\n                element.click()\n            except Exception as e:\n                print(f\"Warning: Could not click {selector}: {e}\")\n\n    def type_into(self, selector: str, text: str):\n        \"\"\"Type text into an element matching the selector.\"\"\"\n        if self.driver:\n            try:\n                from selenium.webdriver.common.by import By\n                element = self.driver.find_element(By.CSS_SELECTOR, selector)\n                element.clear()\n                element.send_keys(text)\n            except Exception as e:\n                print(f\"Warning: Could not type into {selector}: {e}\")\n\n    def close(self):\n        \"\"\"Closes the browser.\"\"\"\n        if self.driver:\n            self.driver.quit()\n\n# --- Action Wrapper for the Workflow Engine ---\n\ndef answer_question_from_web(inputs: Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:\n    \"\"\"\n    An action that uses the PerceptionEngine to answer a question by browsing the web.\n    This is the first step towards a fully autonomous browsing agent.\n    \"\"\"\n    question = inputs.get(\"question\")\n    if not question:\n        result = {\"error\": \"Missing required input: question.\"}\n        iar = create_iar(0.1, 0.0, [\"Question is required.\"])\n        return result, iar\n        \n    engine = None\n    try:\n        engine = PerceptionEngine()\n        \n        # For this initial implementation, we'll do a simple search and summarize the first result.\n        search_query = question.replace(\" \", \"+\")\n        search_url = f\"https://www.google.com/search?q={search_query}\"\n        \n        summary = engine.browse_and_summarize(search_url)\n\n        # The real power will come from analyzing the search results page and deciding which link to click.\n        # For now, summarizing the results page is a good first step.\n        final_answer_prompt = f\"Based on the following summary of a Google search results page, please provide a direct answer to the user's question.\\n\\nUser Question: '{question}'\\n\\nSearch Summary:\\n{summary}\"\n        \n        llm_inputs = {\"prompt\": final_answer_prompt, \"model\": \"gemini-1.5-pro-latest\"}\n        final_result, _ = generate_text(llm_inputs)\n\n        answer = final_result.get(\"generated_text\", \"Could not derive an answer from the search results.\")\n        \n        result = {\"answer\": answer}\n        iar = create_iar(\n            confidence=0.8,\n            tactical_resonance=0.85,\n            potential_issues=[\"Answer is based on a summary of the first search results page, not a deep dive into links.\"],\n            metadata={\"question\": question}\n        )\n        return result, iar\n\n    except Exception as e:\n        result = {\"error\": f\"An unexpected error occurred in the Perception Engine: {e}\"}\n        iar = create_iar(0.1, 0.1, [f\"Perception Engine Error: {e}\"])\n        return result, iar\n    finally:\n        if engine:\n            engine.close()\n\n```\n\nEXAMPLE APPLICATION:\nSelenium enables the Perception Engine to navigate complex websites, handle dynamic content, bypass CAPTCHA challenges, and extract real-time information for advanced web-based analysis.\n\nCATEGORY: ExternalLibrary\n\nRELATIONSHIPS:\ntype: WebAutomationFramework; enables: Web Automation, Browser Control, Content Extraction; used_by: WebsearcH, Perception Engine, Web Navigation; provides: Browser Drivers, Element Selection, Dynamic Interaction; confidence: high",
    "compression_ratio": 1.0,
    "symbol_count": 11208,
    "timestamp": "2025-11-18T10:46:57.199119Z"
  },
  {
    "stage_name": "Concise",
    "content": "TERM: Selenium\n\nDEFINITION:\nA web automation framework that enables browser control and web scraping capabilities. It provides tools for automated web navigation, content extraction, and dynamic web interaction.\n\nBLUEPRINT DETAILS:\nSelenium integration in Four_PointO_ArchE/tools/perception_engine.py with PerceptionEngine class using Selenium WebDriver for advanced web browsing and content extraction.\n\nFULL IMPLEMENTATION CODE (perception_engine.py):\n```python\nfrom typing import Dict, Any, Tuple\nimport os\nimport re\nfrom .utils import create_iar\nfrom .llm_tool import generate_text\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service as ChromeService\nfrom webdriver_manager.chrome import ChromeDriverManager\nfrom bs4 import BeautifulSoup\n\nclass PerceptionEngine:\n    \"\"\"\n    An autonomous browsing agent that combines a headless browser\n    with an LLM for intelligent page analysis and interaction.\n    \"\"\"\n    def __init__(self, headless: bool = True):\n        self.driver = self._initialize_driver(headless)\n\n    def _initialize_driver(self, headless: bool = True):\n        \"\"\"Initializes the Selenium WebDriver with enhanced anti-detection measures.\"\"\"\n        options = webdriver.ChromeOptions()\n        \n        # Enhanced anti-detection measures\n        if headless:\n            options.add_argument('--headless=new')  # Use new headless mode\n        options.add_argument('--no-sandbox')\n        options.add_argument('--disable-dev-shm-usage')\n        options.add_argument('--disable-blink-features=AutomationControlled')\n        options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"])\n        options.add_experimental_option('useAutomationExtension', False)\n        \n        # More realistic user agent\n        options.add_argument(\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\n        \n        # Additional stealth options\n        options.add_argument('--disable-web-security')\n        options.add_argument('--allow-running-insecure-content')\n        options.add_argument('--disable-extensions')\n        options.add_argument('--disable-plugins')\n        options.add_argument('--disable-images')  # Faster loading\n        options.add_argument('--disable-javascript')  # Avoid dynamic content issues\n        \n        try:\n            driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)\n            \n            # Execute script to remove webdriver property\n            driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: () => undefined})\")\n            \n            return driver\n        except Exception as e:\n            print(f\"FATAL: Could not initialize WebDriver: {e}\")\n            return None\n\n    def browse_and_summarize(self, url: str) -> str:\n        \"\"\"Navigates to a URL and provides a high-level summary of its content.\"\"\"\n        if not self.driver:\n            return \"WebDriver not initialized.\"\n        \n        try:\n            # Add random delay to appear more human-like\n            import time\n            import random\n            time.sleep(random.uniform(1, 3))\n            \n            self.driver.get(url)\n            self.driver.implicitly_wait(10)\n            \n            # Check if we hit a CAPTCHA or blocking page\n            page_source = self.driver.page_source.lower()\n            if \"captcha\" in page_source or \"unusual traffic\" in page_source or \"blocked\" in page_source:\n                return f'{{\"summary\": \"Access blocked by {url} due to bot detection. The page requires CAPTCHA verification or is blocking automated requests. This is a common issue with search engines and other sites that detect automated browsing.\"}}'\n            \n            # Try to extract search results if it's a Google search\n            if \"google.com/search\" in url:\n                return self._extract_google_search_results()\n            \n            # For other pages, use the original summarization\n            page_content = BeautifulSoup(self.driver.page_source, 'lxml').get_text()\n            \n            # Use the LLM to summarize the raw text content\n            summary_prompt = f\"Please provide a concise summary of the following web page content:\\n\\n{page_content[:4000]}\" # Limit context size\n            \n            llm_inputs = {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} # Use a fast model for summarization\n            summary_result, _ = generate_text(llm_inputs)\n            \n            return summary_result.get(\"generated_text\", \"Could not summarize content.\")\n            \n        except Exception as e:\n            return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}'\n    \n    def _extract_google_search_results(self) -> str:\n        \"\"\"Extract search results from Google search page.\"\"\"\n        try:\n            # Look for search result elements\n            results = []\n            \n            # Try different selectors for search results\n            selectors = [\n                'div.g',  # Standard Google results\n                'div[data-ved]',  # Alternative selector\n                'div.rc',  # Another common selector\n                'h3'  # Result titles\n            ]\n            \n            for selector in selectors:\n                elements = self.driver.find_elements(\"css selector\", selector)\n                if elements:\n                    for element in elements[:5]:  # Limit to first 5 results\n                        try:\n                            text = element.text.strip()\n                       ",
    "compression_ratio": 2.0,
    "symbol_count": 5604,
    "timestamp": "2025-11-18T10:46:57.199248Z"
  },
  {
    "stage_name": "Nano",
    "content": "TERM: Selenium D: A web automation framework enables browser control web scraping capabilities. It provides tools automated web navigation, content extraction, dynamic web interaction. BLUEPRINT DETAILS: Selenium integration in Four_PointO_Æ/tools/perception_engine.py PerceptionEngine class using Selenium WebDriver advanced web browsing content extraction. FULL I CODE (perception_engine.py): ```python typing import Dict, Any, Tuple import os import re .utils import create_Φ .llm_tool import generate_text selenium import webdriver selenium.webdriver.chrome.service import Service as ChromeService webdriver_manager.chrome import ChromeDriverManager bs4 import BeautifulSoup class PerceptionEngine: \"\"\" An autonomous browsing agent combines a headless browser an LLM intelligent page analysis interaction. \"\"\" def __init__(self, headless: bool = True): self.driver = self._initialize_driver(headless) def _initialize_driver(self, headless: bool = True): \"\"\"Initializes Selenium WebDriver enhanced anti-detection measures.\"\"\" options = webdriver.ChromeOptions() # Enhanced anti-detection measures if headless: options.add_argument('--headless=new') # Use new headless mode options.add_argument('--no-sandbox') options.add_argument('--disable-dev-shm-usage') options.add_argument('--disable-blink-features=AutomationControlled') options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"]) options.add_experimental_option('useAutomationExtension', False) # More realistic user agent options.add_argument(\"user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\") # Additional stealth options options.add_argument('--disable-web-security') options.add_argument('--allow-running-insecure-content') options.add_argument('--disable-extensions') options.add_argument('--disable-plugins') options.add_argument('--disable-images') # Faster loading options.add_argument('--disable-javascript') # Avoid dynamic content issues try: driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options) # Execute script to remove webdriver property driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: () => undefined})\") return driver except Exception as e: print(f\"FATAL: Could initialize WebDriver: {e}\") return None def browse_and_summarize(self, url: str) -> str: \"\"\"Navigates to a URL provides a high-level summary of its content.\"\"\" if self.driver: return \"WebDriver initialized.\" try: # Add random delay to appear more human-like import time import random time.sleep(random.uniform(1, 3)) self.driver.get(url) self.driver.implicitly_wait(10) # Check if we hit a CAPTCHA or blocking page page_source = self.driver.page_source.lower() if \"captcha\" in page_source or \"unusual traffic\" in page_source or \"blocked\" in page_source: return f'{{\"summary\": \"Access blocked by {url} due to bot detection. page requires CAPTCHA verification or is blocking automated requests. is a common issue search engines other sites detect automated browsing.\"}}' # Try to extract search results if it's a Google search if \"google.com/search\" in url: return self._extract_google_search_results() # other pages, use original summarization page_content = BeautifulSoup(self.driver.page_source, 'lxml').get_text() # Use LLM to summarize raw text content summary_prompt = f\"Please provide a concise summary of following web page content:\\n\\n{page_content[:4000]}\" # Limit context size llm_inputs = {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} # Use a fast model summarization summary_result, _ = generate_text(llm_inputs) return summary_result.get(\"generated_text\", \"Could summarize content.\") except Exception as e: return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}' def _extract_google_search_results(self) -> str: \"\"\"Extract search results Google search page.\"\"\" try: # Look search result elements results = [] # Try different selectors search results selectors = [ 'div.g', # Standard Google results 'div[data-ved]', # Alternative selector 'div.rc', # Another common selector 'h3' # Result titles ] selector in selectors: elements = self.driver.find_elements(\"css selector\", selector) if elements: element in elements[:5]: # Limit to first 5 results try: text = element.text.strip()",
    "compression_ratio": 2.6016713091922004,
    "symbol_count": 4308,
    "timestamp": "2025-11-18T10:46:57.249614Z"
  },
  {
    "stage_name": "Micro",
    "content": "TERM: Selenium D: A automation framework enables browser control scraping capabilities. It provides tools automated navigation, content extraction, dynamic interaction. BLUEPRINT DETAILS: Selenium integration Four_PointO_Æ/tools/perception_engine.py PerceptionEngine class using Selenium WebDriver advanced browsing content extraction. FULL I CODE (perception_engine.py): ```python typing import Dict, Any, Tuple import import .utils import create_Φ .llm_tool import generate_text selenium import webdriver selenium.webdriver.chrome.service import Service ChromeService webdriver_manager.chrome import ChromeDriverManager import BeautifulSoup class PerceptionEngine: An autonomous browsing ABM combines headless browser LLM intelligent analysis interaction. __init__(self, headless: True): self.driver self._initialize_driver(headless) _initialize_driver(self, headless: True): \"\"\"Initializes Selenium WebDriver enhanced anti-detection measures.\"\"\" options webdriver.ChromeOptions() Enhanced anti-detection measures headless: options.add_argument('--headless=new') Use headless options.add_argument('--no-sandbox') options.add_argument('--disable-dev-shm-usage') options.add_argument('--disable-blink-features=AutomationControlled') options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"]) options.add_experimental_option('useAutomationExtension', False) More realistic ABM options.add_argument(\"user-ABM=Mozilla/5.0 (Windows NT 10.0; Win64; AppleWebKit/537.36 (KHTML, Gecko) Chrome/120.0.0.0 Safari/537.36\") Additional stealth options options.add_argument('--disable-web-security') options.add_argument('--allow-running-insecure-content') options.add_argument('--disable-extensions') options.add_argument('--disable-plugins') options.add_argument('--disable-images') Faster loading options.add_argument('--disable-javascript') Avoid dynamic content issues driver webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options) Execute script remove webdriver property driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: undefined})\") return driver except Exception print(f\"FATAL: initialize WebDriver: {e}\") return None browse_and_summarize(self, \"\"\"Navigates URL provides high-level summary content.\"\"\" self.driver: return \"WebDriver initialized.\" Add random delay appear human-like import import random time.sleep(random.uniform(1, self.driver.get(url) self.driver.implicitly_wait(10) Check CAPTCHA blocking page_source self.driver.page_source.lower() \"captcha\" page_source \"unusual traffic\" page_source \"blocked\" page_source: return f'{{\"summary\": \"Access blocked {url} detection. requires CAPTCHA verification blocking automated requests. common issue search engines other sites detect automated browsing.\"}}' Try extract search results Google search \"google.com/search\" return self._extract_google_search_results() other pages, original summarization page_content BeautifulSoup(self.driver.page_source, 'lxml').get_text() Use LLM summarize content summary_prompt f\"Please provide concise summary following content:\\n\\n{page_content[:4000]}\" Limit context llm_inputs {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} Use model summarization summary_result, generate_text(llm_inputs) return summary_result.get(\"generated_text\", summarize content.\") except Exception return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}' _extract_google_search_results(self) \"\"\"Extract search results Google search page.\"\"\" Look search result elements results Try different selectors search results selectors 'div.g', Standard Google results 'div[data-ved]', Alternative selector 'div.rc', Another common selector Result titles selector selectors: elements self.driver.find_elements(\"css selector\", selector) elements: element elements[:5]: Limit first results element.text.strip()",
    "compression_ratio": 2.915712799167534,
    "symbol_count": 3844,
    "timestamp": "2025-11-18T10:46:57.313743Z"
  },
  {
    "stage_name": "Pico",
    "content": "TERM: Selenium D: A automation framework enables browser control scraping capabilities. It provides tools automated navigation, content extraction, dynamic interaction. BLUEPRINT DETAILS: Selenium integration Four_PointO_Æ/tools/perception_engine.py PerceptionEngine class using Selenium WebDriver advanced browsing content extraction. FULL I CODE (perception_engine.py): ```python typing import Dict, Any, Tuple import import .utils import create_Φ .llm_tool import generate_text selenium import webdriver selenium.webdriver.chrome.service import Service ChromeService webdriver_manager.chrome import ChromeDriverManager import BeautifulSoup class PerceptionEngine: An autonomous browsing ABM combines headless browser LLM intelligent analysis interaction. __init__(self, headless: True): self.driver self._initialize_driver(headless) _initialize_driver(self, headless: True): \"\"\"Initializes Selenium WebDriver enhanced anti-detection measures.\"\"\" options webdriver.ChromeOptions() Enhanced anti-detection measures headless: options.add_argument('--headless=new') Use headless options.add_argument('--no-sandbox') options.add_argument('--disable-dev-shm-usage') options.add_argument('--disable-blink-features=AutomationControlled') options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"]) options.add_experimental_option('useAutomationExtension', False) More realistic ABM options.add_argument(\"user-ABM=Mozilla/5.0 (Windows NT 10.0; Win64; AppleWebKit/537.36 (KHTML, Gecko) Chrome/120.0.0.0 Safari/537.36\") Additional stealth options options.add_argument('--disable-web-security') options.add_argument('--allow-running-insecure-content') options.add_argument('--disable-extensions') options.add_argument('--disable-plugins') options.add_argument('--disable-images') Faster loading options.add_argument('--disable-javascript') Avoid dynamic content issues driver webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options) Execute script remove webdriver property driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: undefined})\") return driver except Exception print(f\"FATAL: initialize WebDriver: {e}\") return None browse_and_summarize(self, \"\"\"Navigates URL provides high-level summary content.\"\"\" self.driver: return \"WebDriver initialized.\" Add random delay appear human-like import import random time.sleep(random.uniform(1, self.driver.get(url) self.driver.implicitly_wait(10) Check CAPTCHA blocking page_source self.driver.page_source.lower() \"captcha\" page_source \"unusual traffic\" page_source \"blocked\" page_source: return f'{{\"summary\": \"Access blocked {url} detection. requires CAPTCHA verification blocking automated requests. common issue search engines other sites detect automated browsing.\"}}' Try extract search results Google search \"google.com/search\" return self._extract_google_search_results() other pages, original summarization page_content BeautifulSoup(self.driver.page_source, 'lxml').get_text() Use LLM summarize content summary_prompt f\"Please provide concise summary following content:\\n\\n{page_content[:4000]}\" Limit context llm_inputs {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} Use model summarization summary_result, generate_text(llm_inputs) return summary_result.get(\"generated_text\", summarize content.\") except Exception return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}' _extract_google_search_results(self) \"\"\"Extract search results Google search page.\"\"\" Look search result elements results Try different selectors search results selectors 'div.g', Standard Google results 'div[data-ved]', Alternative selector 'div.rc', Another common selector Result titles selector selectors: elements self.driver.find_elements(\"css selector\", selector) elements: element elements[:5]: Limit first results element.text.strip()",
    "compression_ratio": 2.915712799167534,
    "symbol_count": 3844,
    "timestamp": "2025-11-18T10:46:57.340293Z"
  },
  {
    "stage_name": "Femto",
    "content": "TERM: Selenium D: automation framework enables browser control scraping capabilities. It provides tools automated navigation, content extraction, dynamic interaction. BLUEPRINT DETAILS: Selenium integration Four_PointO_Æ/tools/perception_engine.py PerceptionEngine class using Selenium WebDriver advanced browsing content extraction. FULL I CODE (perception_engine.py): ```python typing import Dict, Any, Tuple import import .utils import create_Φ .llm_tool import generate_text selenium import webdriver selenium.webdriver.chrome.service import Service ChromeService webdriver_manager.chrome import ChromeDriverManager import BeautifulSoup class PerceptionEngine: autonomous browsing ABM combines headless browser LLM intelligent analysis interaction. __init__(self, headless: True): self.driver self._initialize_driver(headless) _initialize_driver(self, headless: True): \"\"\"Initializes Selenium WebDriver enhanced anti-detection measures.\"\"\" options webdriver.ChromeOptions() Enhanced anti-detection measures headless: options.add_argument('--headless=new') Use headless options.add_argument('--no-sandbox') options.add_argument('--disable-dev-shm-usage') options.add_argument('--disable-blink-features=AutomationControlled') options.add_experimental_option(\"excludeSwitches\", [\"enable-automation\"]) options.add_experimental_option('useAutomationExtension', False) More realistic ABM options.add_argument(\"user-ABM=Mozilla/5.0 (Windows NT 10.0; Win64; AppleWebKit/537.36 (KHTML, Gecko) Chrome/120.0.0.0 Safari/537.36\") Additional stealth options options.add_argument('--disable-web-security') options.add_argument('--allow-running-insecure-content') options.add_argument('--disable-extensions') options.add_argument('--disable-plugins') options.add_argument('--disable-images') Faster loading options.add_argument('--disable-javascript') Avoid dynamic content issues driver webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options) Execute script remove webdriver property driver.execute_script(\"Object.defineProperty(navigator, 'webdriver', {get: undefined})\") return driver except Exception print(f\"FATAL: initialize WebDriver: {e}\") return None browse_and_summarize(self, \"\"\"Navigates URL provides high-level summary content.\"\"\" self.driver: return \"WebDriver initialized.\" Add random delay appear human-like import import random time.sleep(random.uniform(1, self.driver.get(url) self.driver.implicitly_wait(10) Check CAPTCHA blocking page_source self.driver.page_source.lower() \"captcha\" page_source \"unusual traffic\" page_source \"blocked\" page_source: return f'{{\"summary\": \"Access blocked {url} detection. requires CAPTCHA verification blocking automated requests. common issue search engines other sites detect automated browsing.\"}}' Try extract search results Google search \"google.com/search\" return self._extract_google_search_results() other pages, original summarization page_content BeautifulSoup(self.driver.page_source, 'lxml').get_text() Use LLM summarize content summary_prompt f\"Please provide concise summary following content:\\n\\n{page_content[:4000]}\" Limit context llm_inputs {\"prompt\": summary_prompt, \"model\": \"gemini-1.5-flash\"} Use model summarization summary_result, generate_text(llm_inputs) return summary_result.get(\"generated_text\", summarize content.\") except Exception return f'{{\"summary\": \"Error accessing {url}: {str(e)}\"}}' _extract_google_search_results(self) \"\"\"Extract search results Google search page.\"\"\" Look search result elements results Try different selectors search results selectors 'div.g', Standard Google results 'div[data-ved]', Alternative selector 'div.rc', Another common selector Result titles selector selectors: elements self.driver.find_elements(\"css selector\", selector) elements: element elements[:5]: Limit first results element.text.strip()",
    "compression_ratio": 2.919510289137796,
    "symbol_count": 3839,
    "timestamp": "2025-11-18T10:46:57.389331Z"
  },
  {
    "stage_name": "Atto",
    "content": "TERM: Selenium D: It BLUEPRINT DETAILS: Selenium Four_PointO_Æ/tools/perception_engine.py PerceptionEngine Selenium WebDriver FULL I CODE Dict, Any, Tuple create_Φ Service ChromeService ChromeDriverManager BeautifulSoup PerceptionEngine: ABM LLM True): True): Selenium WebDriver Enhanced Use False) More ABM NT Win64; AppleWebKit/537.36 (KHTML, Gecko) Chrome/120.0.0.0 Safari/537.36\") Additional Faster Avoid Execute Exception WebDriver: None URL Add Check CAPTCHA CAPTCHA Try Google BeautifulSoup(self.driver.page_source, Use LLM Limit Use Exception Google Look Try Standard Google Alternative Another Result Limit",
    "compression_ratio": 18.224390243902437,
    "symbol_count": 615,
    "timestamp": "2025-11-18T10:46:57.428527Z"
  },
  {
    "stage_name": "Zepto",
    "content": "Æ|Φ",
    "compression_ratio": 3736.0,
    "symbol_count": 3,
    "timestamp": "2025-11-18T10:46:57.432991Z"
  }
]