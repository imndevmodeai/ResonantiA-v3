{"content": "TERM: Class: WorkflowContextInjector\n\nDEFINITION:\nClass: WorkflowContextInjector\n\nIntelligently injects workflow task outputs into code snippets.\n\nReplaces naive Jinja2 rendering with a smart system that:\n1. Extracts task references from code\n2. Validates they exist in workflow context\n3. Injects values directly into code\n4. Provides clear diagnostics on failures\n\nMethods: __init__, extract_template_variables, validate_and_resolve, inject_into_code, create_task_context_dict\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_context_injector.py, type: python_class\n\nFULL IMPLEMENTATION CODE (workflow_context_injector.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nWorkflow Context Injector - Smart Template Resolution for Inter-Task Communication\n\nThis module solves the pattern of tasks needing to reference outputs from previous tasks.\nInstead of raw Jinja2 templates, this provides intelligent context injection with:\n- Automatic variable extraction and injection\n- Pre-execution validation\n- Clear error diagnostics\n- Fallback mechanisms\n\"\"\"\n\nimport re\nimport json\nimport logging\nfrom typing import Dict, Any, List, Tuple, Optional\nfrom dataclasses import dataclass, asdict\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass TemplateVariable:\n    \"\"\"Represents a single template variable reference.\"\"\"\n    full_ref: str  # e.g., \"tasks.parse_and_validate_spr.output.result\"\n    path_parts: List[str]  # e.g., [\"parse_and_validate_spr\", \"output\", \"result\"]\n    line_number: int\n    is_valid: bool = False\n    resolved_value: Any = None\n    error_message: str = \"\"\n\nclass WorkflowContextInjector:\n    \"\"\"\n    Intelligently injects workflow task outputs into code snippets.\n    \n    Replaces naive Jinja2 rendering with a smart system that:\n    1. Extracts task references from code\n    2. Validates they exist in workflow context\n    3. Injects values directly into code\n    4. Provides clear diagnostics on failures\n    \"\"\"\n    \n    def __init__(self):\n        self.template_pattern = re.compile(r'\\{\\{\\s*tasks\\.(\\w+(?:\\.\\w+)*)\\s*\\}\\}')\n        self.task_ref_cache: Dict[str, Any] = {}\n    \n    def extract_template_variables(self, code: str) -> List[TemplateVariable]:\n        \"\"\"Extract all template variable references from code.\"\"\"\n        variables = []\n        for line_num, line in enumerate(code.split('\\n'), 1):\n            for match in self.template_pattern.finditer(line):\n                full_ref = match.group(0)\n                path = match.group(1).split('.')\n                \n                variables.append(TemplateVariable(\n                    full_ref=full_ref,\n                    path_parts=path,\n                    line_number=line_num\n                ))\n        \n        return variables\n    \n    def validate_and_resolve(\n        self,\n        variables: List[TemplateVariable],\n        task_outputs: Dict[str, Dict[str, Any]]\n    ) -> Tuple[List[TemplateVariable], List[str]]:\n        \"\"\"\n        Validate that all template variables can be resolved from task outputs.\n        \n        Returns:\n            Tuple of (validated_variables, error_messages)\n        \"\"\"\n        errors = []\n        \n        for var in variables:\n            # First part is task name\n            task_name = var.path_parts[0]\n            \n            if task_name not in task_outputs:\n                errors.append(f\"Line {var.line_number}: Task '{task_name}' not found in workflow outputs\")\n                var.error_message = f\"Task '{task_name}' not in outputs\"\n                continue\n            \n            # Navigate the path\n            current = task_outputs[task_name]\n            for i, part in enumerate(var.path_parts[1:], 1):\n                if not isinstance(current, dict):\n                    errors.append(\n                        f\"Line {var.line_number}: Cannot access '{part}' - \"\n                        f\"'{'.'.join(var.path_parts[:i])}' is not a dict (is {type(current).__name__})\"\n                    )\n                    var.error_message = f\"Path resolution failed at '{'.'.join(var.path_parts[:i])}'\"\n                    break\n                \n                if part not in current:\n                    available = list(current.keys())[:5]\n                    errors.append(\n                        f\"Line {var.line_number}: Key '{part}' not found in \"\n                        f\"'{'.'.join(var.path_parts[:i])}'. Available: {available}\"\n                    )\n                    var.error_message = f\"Key '{part}' not found\"\n                    break\n                \n                current = current[part]\n            else:\n                # Successfully resolved\n                var.is_valid = True\n                var.resolved_value = current\n        \n        return variables, errors\n    \n    def inject_into_code(\n        self,\n        code: str,\n        task_outputs: Dict[str, Dict[str, Any]],\n        safe_mode: bool = True\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"\n        Intelligently inject task outputs into code.\n        \n        Args:\n            code: Python code with Jinja2-style task references\n            task_outputs: Dict of task_name -> task result\n            safe_mode: If True, fail on any unresolvable variable\n        \n        Returns:\n            Tuple of (injected_code, injection_metadata)\n        \n        Raises:\n            ValueError: If safe_mode=True and variables cannot be resolved\n        \"\"\"\n        # Extract variables\n        variables = self.extract_template_variables(code)\n        \n        if not variables:\n            # No template variables, return as-is\n            return code, {\"injected_count\": 0, \"variables\": []}\n        \n        # Validate and resolve\n        variables, errors = self.validate_and_resolve(variables, task_outputs)\n        \n        # Handle errors\n        if errors:\n            if safe_mode:\n                error_msg = \"Template variable resolution failed:\\n\" + \"\\n\".join(errors)\n                logger.error(error_msg)\n                raise ValueError(error_msg)\n            else:\n                logger.warning(f\"Some template variables couldn't be resolved: {errors}\")\n        \n        # Inject valid variables directly into code\n        injected_code = code\n        injected_variables = []\n        \n        for var in variables:\n            if not var.is_valid:\n                if safe_mode:\n                    continue  # Skip invalid variables in safe mode\n                else:\n                    # In non-safe mode, comment out the reference\n                    logger.warning(f\"Skipping invalid variable at line {var.line_number}: {var.error_message}\")\n                    continue\n            \n            # Convert the value to a safe Python literal\n            try:\n                # For simple types, use repr(); for complex types, use json\n                if isinstance(var.resolved_value, (str, int, float, bool, type(None))):\n                    value_repr = repr(var.resolved_value)\n                else:\n                    value_repr = json.dumps(var.resolved_value)\n                \n                # Replace the template with the injected value\n                injected_code = injected_code.replace(var.full_ref, value_repr)\n                injected_variables.append({\n                    \"variable\": var.full_ref,\n                    \"line\": var.line_number,\n                    \"type\": type(var.resolved_value).__name__,\n                    \"preview\": str(var.resolved_value)[:100]\n                })\n                \n                logger.debug(f\"Injected {var.full_ref} at line {var.line_number}\")\n            \n            except Exception as e:\n                logger.error(f\"Failed to inject {var.full_ref}: {e}\")\n                if safe_mode:\n                    raise ValueError(f\"Cannot inject {var.full_ref}: {e}\")\n        \n        metadata = {\n            \"injected_count\": len(injected_variables),\n            \"variables\": injected_variables,\n            \"errors\": errors,\n            \"resolution_success\": len(errors) == 0\n        }\n        \n        return injected_code, metadata\n    \n    def create_task_context_dict(\n        self,\n        task_outputs: Dict[str, Dict[str, Any]]\n    ) -> str:\n        \"\"\"\n        Generate Python code that recreates the task context as a dict.\n        \n        This can be prepended to user code to provide `tasks` as a variable.\n        \"\"\"\n        # Create a safe serialization of task outputs\n        try:\n            tasks_dict_code = f\"tasks = {json.dumps(task_outputs)}\"\n        except (TypeError, ValueError):\n            # If not JSON serializable, use repr with comments\n            logger.warning(\"Task outputs not JSON serializable, using repr()\")\n            tasks_dict_code = f\"tasks = {repr(task_outputs)}\"\n        \n        return tasks_dict_code\n\n\ndef create_injection_report(\n    original_code: str,\n    injected_code: str,\n    metadata: Dict[str, Any]\n) -> str:\n    \"\"\"Create a diagnostic report of the injection process.\"\"\"\n    report = []\n    report.append(\"=\" * 70)\n    report.append(\"WORKFLOW CONTEXT INJECTION REPORT\")\n    report.append(\"=\" * 70)\n    \n    report.append(f\"\\n✓ Variables Injected: {metadata['injected_count']}\")\n    report.append(f\"✓ Resolution Success: {metadata['resolution_success']}\")\n    \n    if metadata['variables']:\n        report.append(\"\\nInjected Variables:\")\n        for var in metadata['variables']:\n            report.append(f\"  • {var['variable']} ({var['type']})\")\n            report.append(f\"    Line: {var['line']}, Value: {var['preview']}\")\n    \n    if metadata['errors']:\n        report.append(f\"\\n⚠ Errors ({len(metadata['errors'])}):\")\n        for error in metadata['errors']:\n            report.append(f\"  • {error}\")\n    \n    report.append(\"\\nOriginal Code:\")\n    report.append(\"-\" * 70)\n    report.append(original_code)\n    \n    report.append(\"\\nInjected Code:\")\n    report.append(\"-\" * 70)\n    report.append(injected_code)\n    \n    report.append(\"\\n\" + \"=\" * 70)\n    \n    return \"\\n\".join(report)\n\n\nif __name__ == '__main__':\n    # Example usage\n    injector = WorkflowContextInjector()\n    \n    sample_code = \"\"\"\nimport json\nfrom difflib import SequenceMatcher\n\nparsed_result = {{ tasks.parse_and_validate_spr.output.result }}\nif parsed_result.get('status') != 'success':\n    print(json.dumps(parsed_result))\nelse:\n    new_spr = parsed_result['spr_definition']\n    print(json.dumps(new_spr))\n\"\"\"\n    \n    sample_task_outputs = {\n        \"parse_and_validate_spr\": {\n            \"output\": {\n                \"result\": {\n                    \"status\": \"success\",\n                    \"spr_definition\": {\n                        \"spr_id\": \"test_spr\",\n                        \"term\": \"Test\",\n                        \"description\": \"A test SPR\"\n                    }\n                }\n            }\n        }\n    }\n    \n    try:\n        injected, metadata = injector.inject_into_code(sample_code, sample_task_outputs)\n        print(create_injection_report(sample_code, injected, metadata))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n\n```\n\nEXAMPLE APPLICATION:\nClass: WorkflowContextInjector\n\nIntelligently injects workflow task outputs into code snippets.\n\nReplaces naive Jinja2 rendering with a smart system that:\n1. Extracts task references from code\n2. Validates they exist in workflow context\n3. Injects values directly into code\n4. Provides clear diagnostics on failures\n\nMethods: __init__, extract_template_variables, validate_and_resolve, inject_into_code, create_task_context_dict\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_context_injector.py; source_type: python_class"}