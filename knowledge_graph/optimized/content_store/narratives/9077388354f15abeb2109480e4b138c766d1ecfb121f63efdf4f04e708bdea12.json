{"content": "TERM: The Alchemist's Crucible: A Chronicle of the ABM DSL Engine: Implementation Example 6\n\nDEFINITION:\nImplementation code:\n\n{\n          \"world\": {\"width\": 1, \"height\": 1, \"step_hours\": 0.1, \"hours\": 24},\n          \"agents\": [{\n            \"name\": \"Body\", \"count\": 1,\n            \"attrs\": {\"drug\": 0, \"metabolite\": 0, \"pH\": 7.4},\n            \"behaviour\": [\n              \"ScheduleDose(drug, 100, at_hour=0)\",\n              \"FirstOrderDecay(drug, t_half=2)\",\n              \"Metabolise(drug, metabolite, 10)\"\n            ]\n          }]\n        }\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/specifications/abm_dsl_engine.md, type: specification_code\n\nFULL SPECIFICATION (abm_dsl_engine.md):\n# The Alchemist's Crucible: A Chronicle of the ABM DSL Engine\n\n## Canonical Chronicle Piece: The Worlds in a Bottle\n\nIn the ResonantiA Saga, after ArchE had mastered analysis of the past (`CausalInference`) and the future (`PredictiveModeling`), a new frontier emerged: the *possible*. How could the system explore complex \"what-if\" scenarios, where thousands of independent actors interact in unpredictable ways? This chronicle tells of the forging of the **Alchemist's Crucible**, the `Agent Based ModelinG` Domain-Specific Language (DSL) Engine. It is the story of how ArchE was given the power to create \"worlds in a bottle\"—_in silico_ laboratories where it could simulate the emergent chaos of complex systems, from cellular biology to market economies.\n\n## Scholarly Introduction: Conceptual Foundations and Implementability\n\nThis specification details a Domain-Specific Language (DSL) for Agent-Based Modeling (ABM), designed to be parsed into executable simulations, primarily using the Mesa framework. The DSL's grammar, defined implicitly by the JSON schema in the technical sections, allows users to declare agent populations, environmental grids, behavioral primitives, and victory conditions in a human-readable format. This approach dramatically lowers the barrier to entry for complex systems modeling. The specification is highly implementable; the provided JSON examples can be directly used as test cases for a parser that generates Python code for the Mesa library.\n\n## The Story of the Alchemist's Crucible: A Narrative of Emergence\n\nImagine ArchE as a brilliant biologist studying a new disease. She can analyze data from past outbreaks, but she wants to know: \"What would happen if we introduced a new vaccine that was 70% effective and required a booster every 6 months?\"\n- **Without the Crucible:** This is almost impossible to answer. The interactions are too complex.\n- **With the Crucible (`ABM DSL Engine`):**\n    1.  **Writing the Recipe (`JSON Schema`):** The biologist doesn't write thousands of lines of code. Instead, she writes a simple, declarative recipe in the DSL.\n        - `world`: \"Create a population grid of 10,000 squares, representing a city.\"\n        - `agents`: \"Create 1,000 'Human' agents. Give them attributes like 'age' and 'health'. Give them behaviors like 'MoveRandomly' and 'InteractWithNeighbors'.\"\n        - `behaviors`: \"Define a 'TransmitDisease' behavior. Define a 'Vaccinate' behavior that changes an agent's 'health' status.\"\n        - `victory_condition`: \"Stop the simulation when 'infected_count' is zero.\"\n    2.  **Mixing the Elixir (`create_model_from_schema`):** The biologist hands this recipe to the Alchemist's Crucible. The engine reads the simple recipe and, like magic, transmutes it into a fully formed, complex simulation—a living \"world in a bottle.\"\n    3.  **Observing the Reaction (`Simulation`):** ArchE runs the simulation. It watches as the virtual disease spreads, as vaccinated agents show resistance, and as herd immunity begins to emerge. It can run the simulation dozens of times, tweaking the vaccine's effectiveness or the booster schedule.\nThe Crucible allows ArchE to explore the unpredictable, *emergent* consequences of a policy *before* implementing it in the real world. It turns abstract ideas into living, testable realities.\n\n## Real-World Analogy: SimCity for Business Strategy\n\nA traditional spreadsheet for a business might show revenue and costs. An Agent-Based Model is like turning that spreadsheet into a playable game of *SimCity*.\n- **The DSL Recipe:** Instead of cells and formulas, you define the actors:\n    - 10,000 `Customer` agents with attributes like `brand_loyalty` and `budget`.\n    - 3 `Competitor` agents with `pricing_strategy` behaviors.\n    - 50 `Product` agents with `features` and `quality`.\n- **The \"What-If\" Game:** You can now play the game.\n    - \"What happens if we lower our price by 10%?\" -> Run the simulation and watch how many `Customer` agents switch from `Competitor` agents.\n    - \"What happens if a `Competitor` introduces a new feature?\" -> Run the simulation and see how many of your `Customer` agents you lose.\nThe ABM DSL Engine allows strategists to move beyond static analysis and explore the dynamic, emergent, and often surprising results of their decisions in a complex marketplace.\n\n# Living Specification: ABM DSL Engine\n\n## SPR Integration\n\n### Self-Perpetuating Resonance Components\n\n**Modeling Resonance**: The system maintains resonance with ArchE's modeling capabilities by providing a bridge between high-level concepts and computational execution.\n\n**Temporal Resonance**: The time management system creates resonance between simulation time and real-world time, enabling accurate temporal modeling.\n\n**Spatial Resonance**: The grid system creates resonance between spatial relationships and agent interactions, enabling realistic spatial modeling.\n\n**Behavioral Resonance**: The behavior primitives create resonance between simple rules and complex emergent behaviors.\n\n### Resonance Patterns\n\n**Schema-Execution Harmony**: The DSL compiler creates resonance between high-level specifications and low-level execution.\n\n**Agent-Environment Interaction**: The grid system creates resonance between agent behaviors and environmental constraints.\n\n**Time-Process Synchronization**: The temporal system creates resonance between simulation steps and real-world processes.\n\n**Behavior-Emergence Alignment**: The behavior primitives create resonance between individual actions and collective outcomes.\n\n## Technical Implementation\n\n### Core Function: `create_model_from_schema`\n\nThe primary entry point that transforms JSON schemas into runnable Mesa models.\n\n**Parameters**:\n- `schema`: Dictionary containing the model specification\n- `seed`: Optional random seed for reproducible results\n\n**Returns**: A fully configured Mesa Model ready for execution\n\n### Advanced Features\n\n**JSON DSL Compiler**:\n- **Schema Validation**: Comprehensive validation of input schemas\n- **Model Generation**: Automatic generation of Mesa-compatible models\n- **Error Handling**: Graceful handling of invalid schemas and missing dependencies\n- **Fallback Support**: Degradation when Mesa library is unavailable\n\n**Agent System**:\n- **Generic Agents**: Flexible agent creation with customizable attributes\n- **Behavior Assignment**: Dynamic assignment of behavioral capabilities\n- **Tag-based Grouping**: Logical grouping of agents by type and function\n- **Attribute Management**: Comprehensive attribute tracking and modification\n\n**Spatial Modeling**:\n- **Grid-based World**: Configurable spatial environment with specified dimensions\n- **Topology Support**: Support for both bounded and toroidal (wrapped) worlds\n- **Movement System**: Sophisticated movement with collision detection\n- **Neighborhood Analysis**: Moore neighborhood support for spatial interactions\n\n**Behavior Primitives**:\n- **Movement Behaviors**: Random movement and targeted movement towards specific agents\n- **Pharmacokinetic Modeling**: pH-dependent decay, first-order kinetics, and metabolism\n- **Dosing System**: Scheduled dosing with precise timing control\n- **Metabolic Processes**: Resource conversion and transformation\n\n**Time Management**:\n- **Step-based Progression**: Configurable time steps for simulation control\n- **Hour Tracking**: Conversion between simulation steps and real-world hours\n- **Temporal Primitives**: Time-dependent behaviors and processes\n- **Synchronization**: Coordination of all temporal processes\n\n**Data Collection**:\n- **Built-in Metrics**: Automatic collection of step counts and agent populations\n- **Custom Attributes**: Tracking of agent attributes and state changes\n- **Snapshot Capabilities**: Periodic capture of system state\n- **Analysis Support**: Data preparation for post-simulation analysis\n\n**Victory Conditions**:\n- **Configurable Stopping**: User-defined conditions for simulation termination\n- **Safe Evaluation**: Secure evaluation of stopping conditions\n- **Error Handling**: Graceful handling of invalid conditions\n- **Flexible Logic**: Support for complex logical expressions\n\n### Integration Points\n\n**Mesa Integration**: Deep integration with the Mesa ABM framework for simulation execution.\n\n**ABM Tool Integration**: Integration with the broader ABM tooling for model management and analysis.\n\n**Workflow Engine Integration**: Integration with the workflow engine for automated model execution.\n\n**Data Analysis Integration**: Integration with analysis tools for result processing and visualization.\n\n**Configuration Integration**: Integration with the configuration system for model parameters and settings.\n\n## Usage Examples\n\n### Basic Model Creation\n```python\nfrom Three_PointO_ArchE.abm_dsl_engine import create_model_from_schema\n\n# Define a simple model schema\nschema = {\n    \"world\": {\"type\": \"grid\", \"width\": 20, \"height\": 20, \"torus\": False},\n    \"agents\": [\n        {\"name\": \"Drone\", \"count\": 5,\n         \"attrs\": {\"battery\": 100},\n         \"behaviour\": [\"MoveRandom\"]}\n    ],\n    \"victory_condition\": \"all Drone.battery == 0\"\n}\n\n# Create and run the model\nmodel = create_model_from_schema(schema, seed=42)\nfor step in range(100):\n    model.step()\n    if not model.running:\n        break\n```\n\n### Pharmacokinetic Modeling\n```python\n# Define a pharmacokinetic model\npk_schema = {\n    \"world\": {\"width\": 1, \"height\": 1, \"step_hours\": 0.1, \"hours\": 24},\n    \"agents\": [\n        {\"name\": \"Body\", \"count\": 1,\n         \"attrs\": {\"drug\": 0, \"metabolite\": 0, \"pH\": 7.4},\n         \"behaviour\": [\n             \"ScheduleDose(drug, 100, at_hour=0)\",\n             \"FirstOrderDecay(drug, t_half=2)\",\n             \"Metabolise(drug, metabolite, 10)\",\n             \"FirstOrderDecaypH(metabolite, t_half_ref=4, sensitivity=0.5, ref_pH=7.4)\"\n         ]}\n    ]\n}\n\n# Create and run the PK model\npk_model = create_model_from_schema(pk_schema)\nfor step in range(240):  # 24 hours with 0.1-hour steps\n    pk_model.step()\n    if step % 10 == 0:  # Print every hour\n        body = pk_model.agents_by_tag[\"Body\"][0]\n        print(f\"Hour {step/10:.1f}: Drug={body.attrs['drug']:.2f}, \"\n              f\"Metabolite={body.attrs['metabolite']:.2f}\")\n```\n\n### Complex Multi-Agent System\n```python\n# Define a predator-prey system with pH effects\necosystem_schema = {\n    \"world\": {\"width\": 30, \"height\": 30, \"torus\": True},\n    \"agents\": [\n        {\"name\": \"Prey\", \"count\": 20,\n         \"attrs\": {\"energy\": 100, \"pH\": 7.0},\n         \"behaviour\": [\n             \"MoveRandom\",\n             \"FirstOrderDecay(energy, t_half=10)\",\n             \"pHShift(0.1, window=[0, 12])\"\n         ]},\n        {\"name\": \"Predator\", \"count\": 5,\n         \"attrs\": {\"energy\": 50, \"pH\": 7.0},\n         \"behaviour\": [\n             \"MoveTowards(Prey)\",\n             \"FirstOrderDecay(energy, t_half=8)\",\n             \"pHShift(-0.05, window=[12, 24])\"\n         ]}\n    ],\n    \"victory_condition\": \"len(Prey) == 0 or len(Predator) == 0\"\n}\n\n# Create and run the ecosystem model\necosystem = create_model_from_schema(ecosystem_schema)\nstep_count = 0\nwhile ecosystem.running and step_count < 1000:\n    ecosystem.step()\n    step_count += 1\n    if step_count % 50 == 0:\n        prey_count = len(ecosystem.agents_by_tag[\"Prey\"])\n        predator_count = len(ecosystem.agents_by_tag[\"Predator\"])\n        print(f\"Step {step_count}: Prey={prey_count}, Predator={predator_count}\")\n```\n\n### Model Analysis\n```python\n# Analyze model results\ndef analyze_model(model):\n    print(\"=== Model Analysis ===\")\n    print(f\"Total steps: {model._current_step}\")\n    print(f\"Total hours: {model.hours_from_test():.1f}\")\n    print(f\"Final agent counts:\")\n    for tag, agents in model.agents_by_tag.items():\n        print(f\"  {tag}: {len(agents)}\")\n    \n    # Analyze agent attributes\n    for tag, agents in model.agents_by_tag.items():\n        if agents:\n            attrs = agents[0].attrs\n            print(f\"\\n{tag} attributes:\")\n            for attr, value in attrs.items():\n                print(f\"  {attr}: {value}\")\n\n# Run analysis\nanalyze_model(model)\n```\n\n### Custom Behavior Extension\n```python\n# Example of how to extend the behavior system\nclass ExtendedDSLAgent(DSLAgent):\n    def step(self):\n        super().step()  # Call parent behavior\n        \n        # Add custom behavior\n        for instr in self._behaviour:\n            if instr.startswith(\"CustomBehavior\"):\n                # Parse and execute custom behavior\n                self._execute_custom_behavior(instr)\n    \n    def _execute_custom_behavior(self, instruction):\n        # Implementation of custom behavior\n        pass\n```\n\n## How the Alchemist Forges a World: A Real-World Workflow\n\nThis workflow details the end-to-end process of using the ABM DSL Engine to create and run a simulation from a simple JSON specification.\n\n1.  **Phase 1: The Blueprint (JSON Schema)**\n    *   **Action:** A user or another ArchE process defines the world to be simulated in a JSON object.\n    *   **Example (`pk_schema` from above):**\n        ```json\n        {\n          \"world\": {\"width\": 1, \"height\": 1, \"step_hours\": 0.1, \"hours\": 24},\n          \"agents\": [{\n            \"name\": \"Body\", \"count\": 1,\n            \"attrs\": {\"drug\": 0, \"metabolite\": 0, \"pH\": 7.4},\n            \"behaviour\": [\n              \"ScheduleDose(drug, 100, at_hour=0)\",\n              \"FirstOrderDecay(drug, t_half=2)\",\n              \"Metabolise(drug, metabolite, 10)\"\n            ]\n          }]\n        }\n        ```\n\n2.  **Phase 2: The Transmutation (`create_model_from_schema`)**\n    *   **Action:** A workflow task calls the `perform_abm` tool with `operation: 'create_model'`, `model_type: 'generic_dsl'`, and the `schema` from Phase 1.\n    *   **Process:**\n        *   The `create_model_from_schema` function is invoked internally.\n        *   **Schema Validation:** It first validates the JSON against its internal rules.\n        *   **World Creation:** It creates a `Mesa` model instance and a `Grid` based on the `\"world\"` parameters.\n        *   **Agent Forging:** It iterates through the `\"agents\"` list. For each entry, it creates the specified `count` of `DSLAgent` instances.\n        *   **Attribute & Behavior Assignment:** It assigns the initial `attrs` to each agent and attaches the list of `behaviour` strings.\n    *   **Result:** A fully instantiated, in-memory `Mesa` model object is returned, ready for simulation.\n\n3.  **Phase 3: The Observation (`run_simulation`)**\n    *   **Action:** A workflow task calls `perform_abm` with `operation: 'run_simulation'`, passing in the `model` object from Phase 2 and `steps: 240`.\n    *   **Process:**\n        *   The `run_simulation` function loops 240 times.\n        *   In each loop, it calls the model's `step()` method.\n        *   The `Mesa` scheduler activates each agent's `step()` method.\n        *   The agent's `step()` method iterates through its list of behavior strings (e.g., `\"FirstOrderDecay(drug, t_half=2)\"`).\n        *   It parses each string and executes the corresponding internal function (e.g., `_behaviour_first_order_decay(...)`), which modifies the agent's `attrs` in place.\n        *   The model's `datacollector` records the state of the agents at the end of each step.\n    *   **Result:** The simulation runs to completion, and the function returns the model object, now containing the full history of the simulation in its `datacollector`.\n\n4.  **Phase 4: The Analysis (`analyze_results`)**\n    *   **Action:** A final workflow task calls `perform_abm` with `operation: 'analyze_results'`, passing in the simulation results.\n    *   **Process:** The analysis function extracts the data from the `datacollector` into a pandas DataFrame, calculates summary statistics, and identifies key events (like convergence or oscillation).\n    *   **Result:** A structured dictionary containing the analysis is returned, ready for interpretation or visualization.\n\n## SPR Integration and Knowledge Tapestry Mapping\n\n*   **Primary SPR**: `Agent Based ModelinG` (ABM)\n*   **Sub-SPRs**:\n    *   `Emergence Over TimE`: The core phenomenon that ABM is designed to study.\n    *   `Complex System VisioninG`: The primary capability enabled by this tool.\n*   **Tapestry Relationships**:\n    *   **`is_a`**: `What-If ScenariO Analysis`, `Simulation FrameworK`\n    *   **`part_of`**: The `RISE` Analytical Triad\n    *   **`enables`**: `Policy TestinG`, `Strategic ForesighT`\n    *   **`uses`**: `Mesa LibrarY`\n    *   **`embodies`**: The principle of understanding macro behavior from micro rules.\n\nThis Living Tome ensures the ABM DSL Engine is understood not just as a code library, but as the Alchemist's Crucible—a powerful tool for transmuting simple, declarative ideas into living, complex simulations to reveal emergent truths.\n\n\nEXAMPLE APPLICATION:\nImplementation code:\n\n{\n          \"world\": {\"width\": 1, \"height\": 1, \"step_hours\": 0.1, \"hours\": 24},\n          \"agents\": [{\n            \"name\": \"Body\", \"count\": 1,\n            \"attrs\": {\"drug\": 0, \"metabolite\": 0, \"pH\": 7.4},\n            \"behaviour\": [\n              \"ScheduleDose(drug, 100, at_hour=0)\",\n              \"FirstOrderDecay(drug, t_half=2)\",\n              \"Metabolise(drug, metabolite, 10)\"\n            ]\n          }]\n        }\n\nCATEGORY: ImplementationKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/specifications/abm_dsl_engine.md; source_type: specification_code"}