{"content": "TERM: Class: ValidationResult\n\nDEFINITION:\nClass: ValidationResult\n\n\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_validator.py, type: python_class\n\nFULL IMPLEMENTATION CODE (workflow_validator.py):\n```python\nimport json\nimport os\nimport logging\nfrom typing import Dict, Any, List, Tuple, Set\nfrom dataclasses import dataclass\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    errors: List[str]\n    warnings: List[str]\n    task_dependencies: Dict[str, Set[str]]\n    action_types: Set[str]\n\nclass WorkflowValidator:\n    \"\"\"Validates workflow structure, dependencies, and action types.\"\"\"\n    \n    def __init__(self, action_registry: Dict[str, Any]):\n        self.action_registry = action_registry\n        self.required_task_fields = {\n            'description', 'action_type', 'inputs', 'dependencies'\n        }\n        self.optional_task_fields = {\n            'outputs', 'condition', 'retries', 'timeout'\n        }\n    \n    def validate_workflow(self, workflow: Dict[str, Any]) -> ValidationResult:\n        \"\"\"Validate a workflow definition.\"\"\"\n        errors = []\n        warnings = []\n        task_dependencies = defaultdict(set)\n        action_types = set()\n        \n        # Validate top-level structure\n        if not isinstance(workflow, dict):\n            errors.append(\"Workflow must be a dictionary\")\n            return ValidationResult(False, errors, warnings, task_dependencies, action_types)\n        \n        required_fields = {'name', 'description', 'version', 'tasks'}\n        missing_fields = required_fields - set(workflow.keys())\n        if missing_fields:\n            errors.append(f\"Missing required fields: {missing_fields}\")\n        \n        # Validate tasks\n        if 'tasks' not in workflow or not isinstance(workflow['tasks'], dict):\n            errors.append(\"Workflow must contain a 'tasks' dictionary\")\n        else:\n            for task_id, task in workflow['tasks'].items():\n                # Validate task structure\n                task_errors, task_warnings = self._validate_task(task_id, task)\n                errors.extend(task_errors)\n                warnings.extend(task_warnings)\n                \n                # Track dependencies and action types\n                if 'dependencies' in task:\n                    task_dependencies[task_id] = set(task['dependencies'])\n                if 'action_type' in task:\n                    action_types.add(task['action_type'])\n        \n        # Validate dependency cycles\n        if not errors:  # Only check cycles if no other errors\n            cycle = self._check_dependency_cycles(task_dependencies)\n            if cycle:\n                errors.append(f\"Circular dependency detected: {' -> '.join(cycle)}\")\n        \n        # Validate action types\n        invalid_actions = action_types - set(self.action_registry.keys())\n        if invalid_actions:\n            errors.append(f\"Invalid action types: {invalid_actions}\")\n        \n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings,\n            task_dependencies=dict(task_dependencies),\n            action_types=action_types\n        )\n    \n    def _validate_task(self, task_id: str, task: Dict[str, Any]) -> Tuple[List[str], List[str]]:\n        \"\"\"Validate a single task definition.\"\"\"\n        errors = []\n        warnings = []\n        \n        # Check required fields\n        missing_fields = self.required_task_fields - set(task.keys())\n        if missing_fields:\n            errors.append(f\"Task '{task_id}' missing required fields: {missing_fields}\")\n        \n        # Validate action_type\n        if 'action_type' in task:\n            if task['action_type'] not in self.action_registry:\n                errors.append(f\"Task '{task_id}' has invalid action_type: {task['action_type']}\")\n        \n        # Validate inputs\n        if 'inputs' in task:\n            if not isinstance(task['inputs'], dict):\n                errors.append(f\"Task '{task_id}' inputs must be a dictionary\")\n        \n        # Validate dependencies\n        if 'dependencies' in task:\n            if not isinstance(task['dependencies'], list):\n                errors.append(f\"Task '{task_id}' dependencies must be a list\")\n        \n        # Validate condition\n        if 'condition' in task:\n            if not isinstance(task['condition'], str):\n                errors.append(f\"Task '{task_id}' condition must be a string\")\n        \n        # Check for unused optional fields\n        unused_fields = set(task.keys()) - (self.required_task_fields | self.optional_task_fields)\n        if unused_fields:\n            warnings.append(f\"Task '{task_id}' has unused fields: {unused_fields}\")\n        \n        return errors, warnings\n    \n    def _check_dependency_cycles(self, dependencies: Dict[str, Set[str]]) -> List[str]:\n        \"\"\"Check for cycles in task dependencies using DFS.\"\"\"\n        visited = set()\n        path = []\n        \n        def dfs(task_id: str) -> List[str]:\n            if task_id in path:\n                cycle_start = path.index(task_id)\n                return path[cycle_start:] + [task_id]\n            \n            if task_id in visited:\n                return []\n            \n            visited.add(task_id)\n            path.append(task_id)\n            \n            for dep in dependencies.get(task_id, set()):\n                cycle = dfs(dep)\n                if cycle:\n                    return cycle\n            \n            path.pop()\n            return []\n        \n        for task_id in dependencies:\n            cycle = dfs(task_id)\n            if cycle:\n                return cycle\n        \n        return []\n\ndef validate_workflow_file(filepath: str, action_registry: Dict[str, Any]) -> ValidationResult:\n    \"\"\"Validate a workflow file.\"\"\"\n    try:\n        with open(filepath, 'r') as f:\n            workflow = json.load(f)\n        \n        validator = WorkflowValidator(action_registry)\n        return validator.validate_workflow(workflow)\n    \n    except json.JSONDecodeError as e:\n        return ValidationResult(\n            is_valid=False,\n            errors=[f\"Invalid JSON: {str(e)}\"],\n            warnings=[],\n            task_dependencies={},\n            action_types=set()\n        )\n    except Exception as e:\n        return ValidationResult(\n            is_valid=False,\n            errors=[f\"Error validating workflow: {str(e)}\"],\n            warnings=[],\n            task_dependencies={},\n            action_types=set()\n        )\n\nif __name__ == \"__main__\":\n    # Example usage\n    from action_registry import main_action_registry\n    \n    workflow_path = \"workflows/system_genesis_and_evolution_workflow.json\"\n    result = validate_workflow_file(workflow_path, main_action_registry.actions)\n    \n    if result.is_valid:\n        print(\"Workflow is valid!\")\n        if result.warnings:\n            print(\"\\nWarnings:\")\n            for warning in result.warnings:\n                print(f\"- {warning}\")\n    else:\n        print(\"Workflow is invalid!\")\n        print(\"\\nErrors:\")\n        for error in result.errors:\n            print(f\"- {error}\") \n```\n\nEXAMPLE APPLICATION:\nClass: ValidationResult\n\n\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_validator.py; source_type: python_class"}