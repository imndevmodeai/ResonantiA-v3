{"content": "TERM: Class: ZeptoSPRDecompressionResult\n\nDEFINITION:\nResult container for Zepto SPR decompression operations.\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/zepto_spr_processor.py, type: python_class\n\nFULL IMPLEMENTATION CODE (zepto_spr_processor.py):\n```python\n\"\"\"\nUniversal Zepto SPR Processor Abstraction\nResonantiA Protocol v3.5-GP - Universal Abstraction Layer\n\nThis module provides a universal abstraction for the Zepto SPR (Sparse Priming Representation)\ncompression and decompression process, enabling system-wide integration of hyper-dense symbolic\nknowledge representation.\n\nThe abstraction follows Universal Abstraction principles: Represent → Compare → Learn → Crystallize\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional, Tuple, Union\nfrom dataclasses import dataclass, asdict\nimport logging\nfrom pathlib import Path\nimport json\n\nlogger = logging.getLogger(__name__)\n\n# Import Pattern Crystallization Engine\ntry:\n    from .pattern_crystallization_engine import (\n        PatternCrystallizationEngine,\n        CompressionStage,\n        SymbolCodexEntry\n    )\n    CRYSTALLIZATION_ENGINE_AVAILABLE = True\nexcept ImportError:\n    CRYSTALLIZATION_ENGINE_AVAILABLE = False\n    PatternCrystallizationEngine = None\n    CompressionStage = None\n    SymbolCodexEntry = None\n    logger.warning(\"PatternCrystallizationEngine not available. Zepto SPR processing will be limited.\")\n\n\n@dataclass\nclass ZeptoSPRResult:\n    \"\"\"Result container for Zepto SPR processing operations.\"\"\"\n    zepto_spr: str\n    compression_ratio: float\n    compression_stages: List[Dict[str, Any]]\n    new_codex_entries: Dict[str, Dict[str, Any]]\n    original_length: int\n    zepto_length: int\n    processing_time_sec: Optional[float] = None\n    error: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n\n@dataclass\nclass ZeptoSPRDecompressionResult:\n    \"\"\"Result container for Zepto SPR decompression operations.\"\"\"\n    decompressed_text: str\n    symbols_found: List[str]\n    symbols_expanded: Dict[str, str]\n    decompression_accuracy: Optional[float] = None\n    error: Optional[str] = None\n    metadata: Optional[Dict[str, Any]] = None\n\n\nclass IZeptoSPRProcessor(ABC):\n    \"\"\"\n    Universal Abstract Interface for Zepto SPR Processing.\n    \n    This interface defines the contract for all Zepto SPR processors,\n    enabling polymorphic usage throughout the ResonantiA system.\n    \n    Implements Universal Abstraction: Represent → Compare → Learn → Crystallize\n    \"\"\"\n    \n    @abstractmethod\n    def compress_to_zepto(\n        self,\n        narrative: str,\n        target_stage: str = \"Zepto\",\n        context: Optional[Dict[str, Any]] = None\n    ) -> ZeptoSPRResult:\n        \"\"\"\n        Compress a narrative to Zepto SPR form.\n        \n        Args:\n            narrative: The verbose narrative to compress\n            target_stage: Compression stage target (\"Concise\", \"Nano\", \"Micro\", \"Pico\", \"Femto\", \"Atto\", \"Zepto\")\n            context: Optional context metadata for compression\n            \n        Returns:\n            ZeptoSPRResult containing the compressed SPR and metadata\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def decompress_from_zepto(\n        self,\n        zepto_spr: str,\n        codex: Optional[Dict[str, Any]] = None,\n        context: Optional[Dict[str, Any]] = None\n    ) -> ZeptoSPRDecompressionResult:\n        \"\"\"\n        Decompress a Zepto SPR back to readable narrative.\n        \n        Args:\n            zepto_spr: The Zepto SPR string to decompress\n            codex: Optional symbol codex (uses default if None)\n            context: Optional context metadata for decompression\n            \n        Returns:\n            ZeptoSPRDecompressionResult containing decompressed text and metadata\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_compression(\n        self,\n        original: str,\n        zepto_spr: str,\n        decompressed: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate compression integrity and meaning preservation.\n        \n        Args:\n            original: Original narrative\n            zepto_spr: Compressed Zepto SPR\n            decompressed: Optional decompressed text (will decompress if None)\n            \n        Returns:\n            Validation metrics dictionary\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def get_codex(self) -> Dict[str, Any]:\n        \"\"\"Retrieve the current Symbol Codex.\"\"\"\n        pass\n    \n    @abstractmethod\n    def update_codex(self, new_entries: Dict[str, Dict[str, Any]]) -> bool:\n        \"\"\"Update the Symbol Codex with new entries.\"\"\"\n        pass\n\n\nclass ZeptoSPRProcessorAdapter(IZeptoSPRProcessor):\n    \"\"\"\n    Concrete Implementation of IZeptoSPRProcessor.\n    \n    Adapts PatternCrystallizationEngine to the universal interface,\n    enabling seamless integration throughout the ResonantiA system.\n    \"\"\"\n    \n    def __init__(\n        self,\n        symbol_codex_path: str = \"knowledge_graph/symbol_codex.json\",\n        protocol_vocabulary_path: str = \"knowledge_graph/protocol_symbol_vocabulary.json\"\n    ):\n        \"\"\"Initialize the adapter with Pattern Crystallization Engine.\"\"\"\n        if not CRYSTALLIZATION_ENGINE_AVAILABLE:\n            raise RuntimeError(\n                \"PatternCrystallizationEngine not available. \"\n                \"Cannot initialize ZeptoSPRProcessorAdapter.\"\n            )\n        \n        self.engine = PatternCrystallizationEngine(\n            symbol_codex_path=symbol_codex_path,\n            protocol_vocabulary_path=protocol_vocabulary_path\n        )\n        self.codex_path = Path(symbol_codex_path)\n        logger.info(\"ZeptoSPRProcessorAdapter initialized with PatternCrystallizationEngine\")\n    \n    def compress_to_zepto(\n        self,\n        narrative: str,\n        target_stage: str = \"Zepto\",\n        context: Optional[Dict[str, Any]] = None\n    ) -> ZeptoSPRResult:\n        \"\"\"Compress narrative to Zepto SPR using PatternCrystallizationEngine.\"\"\"\n        import time\n        start_time = time.time()\n        \n        try:\n            if not narrative or not isinstance(narrative, str):\n                return ZeptoSPRResult(\n                    zepto_spr=\"\",\n                    compression_ratio=1.0,\n                    compression_stages=[],\n                    new_codex_entries={},\n                    original_length=0,\n                    zepto_length=0,\n                    error=\"Invalid narrative input\"\n                )\n            \n            original_length = len(narrative)\n            \n            # Delegate to PatternCrystallizationEngine (Russian Doll Architecture)\n            zepto_spr, new_codex_entries, compression_stages_list = self.engine.distill_to_spr(\n                thought_trail_entry=narrative,\n                target_stage=target_stage\n            )\n            \n            zepto_length = len(zepto_spr) if zepto_spr else 0\n            compression_ratio = original_length / zepto_length if zepto_length > 0 else 1.0\n            \n            # Convert compression stages to serializable format (Russian dolls)\n            compression_stages = [\n                {\n                    \"stage_name\": stage.stage_name,\n                    \"content\": stage.content,  # Store layer content for retrieval\n                    \"compression_ratio\": stage.compression_ratio,\n                    \"symbol_count\": stage.symbol_count,\n                    \"timestamp\": stage.timestamp\n                }\n                for stage in compression_stages_list\n            ]\n            \n            # Convert SymbolCodexEntry objects to dicts\n            codex_entries_dict = {\n                symbol: asdict(entry) if hasattr(entry, '__dict__') else entry\n                for symbol, entry in new_codex_entries.items()\n            }\n            \n            processing_time = time.time() - start_time\n            \n            return ZeptoSPRResult(\n                zepto_spr=zepto_spr,\n                compression_ratio=compression_ratio,\n                compression_stages=compression_stages,\n                new_codex_entries=codex_entries_dict,\n                original_length=original_length,\n                zepto_length=zepto_length,\n                processing_time_sec=processing_time,\n                metadata=context or {}\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error compressing to Zepto SPR: {e}\", exc_info=True)\n            return ZeptoSPRResult(\n                zepto_spr=\"\",\n                compression_ratio=1.0,\n                compression_stages=[],\n                new_codex_entries={},\n                original_length=len(narrative) if narrative else 0,\n                zepto_length=0,\n                error=str(e)\n            )\n    \n    def decompress_from_zepto(\n        self,\n        zepto_spr: str,\n        codex: Optional[Dict[str, Any]] = None,\n        context: Optional[Dict[str, Any]] = None,\n        target_layer: Optional[str] = None,\n        compression_stages: Optional[List[Dict[str, Any]]] = None\n    ) -> ZeptoSPRDecompressionResult:\n        \"\"\"\n        Layered Decompression: Russian Doll Architecture\n        \n        Decompresses Zepto SPR through progressive layers, like Russian dolls.\n        Each layer adds more detail and nuance.\n        \"\"\"\n        try:\n            if not zepto_spr or not isinstance(zepto_spr, str):\n                return ZeptoSPRDecompressionResult(\n                    decompressed_text=\"\",\n                    symbols_found=[],\n                    symbols_expanded={},\n                    error=\"Invalid Zepto SPR input\"\n                )\n            \n            # Convert codex dict to SymbolCodexEntry objects if needed\n            codex_entries = None\n            if codex:\n                codex_entries = {}\n                for symbol, entry_data in codex.items():\n                    if isinstance(entry_data, dict):\n                        # Handle enhanced SymbolCodexEntry format with nuanced knowledge\n                        try:\n                            if 'symbol' in entry_data and 'meaning' in entry_data:\n                                codex_entries[symbol] = SymbolCodexEntry(\n                                    symbol=entry_data.get('symbol', symbol),\n                                    meaning=entry_data.get('meaning', ''),\n                                    context=entry_data.get('context', ''),\n                                    usage_examples=entry_data.get('usage_examples', []),\n                                    original_patterns=entry_data.get('original_patterns', []),\n                                    relationships=entry_data.get('relationships', {}),\n                                    critical_specifics=entry_data.get('critical_specifics', []),\n                                    generalizable_patterns=entry_data.get('generalizable_patterns', []),\n                                    contextual_variations=entry_data.get('contextual_variations', {}),\n                                    decompression_template=entry_data.get('decompression_template', entry_data.get('meaning', '')),\n                                    created_at=entry_data.get('created_at', '')\n                                )\n                            else:\n                                # Simple dict format - use as-is, engine will handle it\n                                codex_entries[symbol] = entry_data\n                        except Exception:\n                            # Fallback: use as dict\n                            codex_entries[symbol] = entry_data\n                    else:\n                        codex_entries[symbol] = entry_data\n            \n            # Convert compression_stages dicts to CompressionStage objects if provided\n            compression_stages_objects = None\n            if compression_stages:\n                from .pattern_crystallization_engine import CompressionStage\n                compression_stages_objects = [\n                    CompressionStage(\n                        stage_name=stage.get('stage_name', ''),\n                        content=stage.get('content', ''),\n                        compression_ratio=stage.get('compression_ratio', 1.0),\n                        symbol_count=stage.get('symbol_count', 0),\n                        timestamp=stage.get('timestamp', '')\n                    )\n                    for stage in compression_stages\n                ]\n            \n            # Delegate to engine with layered decompression support\n            decompressed = self.engine.decompress_spr(\n                zepto_spr=zepto_spr,\n                codex=codex_entries,\n                target_layer=target_layer,\n                compression_stages=compression_stages_objects\n            )\n            \n            # Extract symbols found\n            symbols_found = self.engine._extract_symbols(zepto_spr)\n            \n            # Build symbols_expanded mapping\n            symbols_expanded = {}\n            active_codex = codex_entries if codex_entries else self.engine.codex\n            for symbol in symbols_found:\n                if symbol in active_codex:\n                    entry = active_codex[symbol]\n                    if isinstance(entry, SymbolCodexEntry):\n                        symbols_expanded[symbol] = entry.meaning\n                    elif isinstance(entry, dict):\n                        symbols_expanded[symbol] = entry.get('meaning', str(symbol))\n            \n            return ZeptoSPRDecompressionResult(\n                decompressed_text=decompressed,\n                symbols_found=symbols_found,\n                symbols_expanded=symbols_expanded,\n                metadata=context or {}\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error decompressing Zepto SPR: {e}\", exc_info=True)\n            return ZeptoSPRDecompressionResult(\n                decompressed_text=\"\",\n                symbols_found=[],\n                symbols_expanded={},\n                error=str(e)\n            )\n    \n    def validate_compression(\n        self,\n        original: str,\n        zepto_spr: str,\n        decompressed: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Validate compression integrity.\"\"\"\n        try:\n            if decompressed is None:\n                decomp_result = self.decompress_from_zepto(zepto_spr)\n                decompressed = decomp_result.decompressed_text\n            \n            # Use engine's validation method\n            validation = self.engine.validate_compression(\n                original=original,\n                zepto_spr=zepto_spr,\n                decompressed=decompressed\n            )\n            \n            return validation\n            \n        except Exception as e:\n            logger.error(f\"Error validating compression: {e}\", exc_info=True)\n            return {\n                \"compression_ratio\": len(original) / len(zepto_spr) if zepto_spr else 1.0,\n                \"decompression_accuracy\": 0.0,\n                \"key_concepts_preserved\": False,\n                \"logical_structure_intact\": False,\n                \"error\": str(e)\n            }\n    \n    def get_codex(self) -> Dict[str, Any]:\n        \"\"\"Retrieve current Symbol Codex.\"\"\"\n        try:\n            return {\n                symbol: asdict(entry) if hasattr(entry, '__dict__') else entry\n                for symbol, entry in self.engine.codex.items()\n            }\n        except Exception as e:\n            logger.error(f\"Error retrieving codex: {e}\", exc_info=True)\n            return {}\n    \n    def update_codex(self, new_entries: Dict[str, Dict[str, Any]]) -> bool:\n        \"\"\"Update Symbol Codex with new entries.\"\"\"\n        try:\n            for symbol, entry_data in new_entries.items():\n                if isinstance(entry_data, dict):\n                    entry = SymbolCodexEntry(**entry_data)\n                    self.engine.codex[symbol] = entry\n                else:\n                    self.engine.codex[symbol] = entry_data\n            \n            self.engine._save_codex()\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error updating codex: {e}\", exc_info=True)\n            return False\n\n\nclass ZeptoSPRRegistry:\n    \"\"\"\n    System-wide Registry for Zepto SPR Processors.\n    \n    Provides singleton access and factory methods for Zepto SPR processing\n    throughout the ResonantiA system.\n    \"\"\"\n    \n    _instance: Optional[IZeptoSPRProcessor] = None\n    _default_config: Dict[str, str] = {\n        \"symbol_codex_path\": \"knowledge_graph/symbol_codex.json\",\n        \"protocol_vocabulary_path\": \"knowledge_graph/protocol_symbol_vocabulary.json\"\n    }\n    \n    @classmethod\n    def get_processor(\n        cls,\n        config: Optional[Dict[str, str]] = None,\n        force_new: bool = False\n    ) -> Optional[IZeptoSPRProcessor]:\n        \"\"\"\n        Get or create the universal Zepto SPR processor instance.\n        \n        Args:\n            config: Optional configuration override\n            force_new: Force creation of new instance\n            \n        Returns:\n            IZeptoSPRProcessor instance or None if unavailable\n        \"\"\"\n        if force_new or cls._instance is None:\n            try:\n                final_config = {**cls._default_config, **(config or {})}\n                cls._instance = ZeptoSPRProcessorAdapter(**final_config)\n                logger.info(\"ZeptoSPRRegistry: Created new processor instance\")\n            except Exception as e:\n                logger.error(f\"ZeptoSPRRegistry: Failed to create processor: {e}\", exc_info=True)\n                return None\n        \n        return cls._instance\n    \n    @classmethod\n    def register_processor(cls, processor: IZeptoSPRProcessor):\n        \"\"\"Register a custom processor implementation.\"\"\"\n        cls._instance = processor\n        logger.info(\"ZeptoSPRRegistry: Registered custom processor\")\n    \n    @classmethod\n    def reset(cls):\n        \"\"\"Reset the registry (useful for testing).\"\"\"\n        cls._instance = None\n\n\n# Convenience functions for universal access\ndef get_zepto_processor(config: Optional[Dict[str, str]] = None) -> Optional[IZeptoSPRProcessor]:\n    \"\"\"Get the universal Zepto SPR processor.\"\"\"\n    return ZeptoSPRRegistry.get_processor(config)\n\n\ndef compress_to_zepto(\n    narrative: str,\n    target_stage: str = \"Zepto\",\n    config: Optional[Dict[str, str]] = None\n) -> ZeptoSPRResult:\n    \"\"\"Universal function to compress narrative to Zepto SPR.\"\"\"\n    processor = get_zepto_processor(config)\n    if processor:\n        return processor.compress_to_zepto(narrative, target_stage)\n    return ZeptoSPRResult(\n        zepto_spr=\"\",\n        compression_ratio=1.0,\n        compression_stages=[],\n        new_codex_entries={},\n        original_length=len(narrative) if narrative else 0,\n        zepto_length=0,\n        error=\"Zepto SPR processor not available\"\n    )\n\n\ndef decompress_from_zepto(\n    zepto_spr: str,\n    codex: Optional[Dict[str, Any]] = None,\n    config: Optional[Dict[str, str]] = None\n) -> ZeptoSPRDecompressionResult:\n    \"\"\"Universal function to decompress Zepto SPR.\"\"\"\n    processor = get_zepto_processor(config)\n    if processor:\n        return processor.decompress_from_zepto(zepto_spr, codex)\n    return ZeptoSPRDecompressionResult(\n        decompressed_text=\"\",\n        symbols_found=[],\n        symbols_expanded={},\n        error=\"Zepto SPR processor not available\"\n    )\n\n\n__all__ = [\n    'IZeptoSPRProcessor',\n    'ZeptoSPRProcessorAdapter',\n    'ZeptoSPRRegistry',\n    'ZeptoSPRResult',\n    'ZeptoSPRDecompressionResult',\n    'get_zepto_processor',\n    'compress_to_zepto',\n    'decompress_from_zepto'\n]\n\n```\n\nEXAMPLE APPLICATION:\nResult container for Zepto SPR decompression operations.\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/zepto_spr_processor.py; source_type: python_class"}