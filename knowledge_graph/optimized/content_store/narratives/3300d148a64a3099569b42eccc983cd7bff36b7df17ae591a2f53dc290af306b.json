{"content": "TERM: Class: CognitiveResonantControllerSystem\n\nDEFINITION:\nClass: CognitiveResonantControllerSystem\n\nMaster controller system managing multiple frequency domain controllers\nImplements hierarchical control architecture with learning capabilities\n\nMethods: __init__, _initialize_default_controllers, process_query, _general_proportional_extraction, get_system_diagnostics\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/cognitive_resonant_controller.py, type: python_class\n\nFULL IMPLEMENTATION CODE (cognitive_resonant_controller.py):\n```python\n\"\"\"\nCognitive Resonant Controller System (CRCS)\nA generalized implementation of Proportional Resonant Controller principles \nfor cognitive architecture error elimination across multiple frequency domains.\n\nBased on successful Implementation Resonance controller demonstration.\n\"\"\"\n\nimport logging\nimport json\nimport math\nimport re\nimport time\nfrom typing import Dict, List, Tuple, Optional, Any\nfrom dataclasses import dataclass, field\nfrom abc import ABC, abstractmethod\n\n# --- Start of new integration code ---\nCRCS_AVAILABLE = True\n\ntry:\n    from .autopoietic_self_analysis import QuantumProbability\nexcept ImportError:\n    class QuantumProbability: # Fallback class\n        def __init__(self, prob: float, evidence: list = None):\n            self.probability = prob\n        def to_dict(self):\n            return {\"probability\": self.probability}\n        def collapse(self) -> float:\n            return self.probability\n\n@dataclass\nclass CognitiveResponse:\n    content: str\n    processing_path: str\n    confidence: QuantumProbability\n    processing_time_ms: float\n    controller_used: Optional[str] = None\n    fallback_reason: Optional[str] = None\n    metadata: Dict = field(default_factory=dict)\n# --- End of new integration code ---\n\n# This is a forward declaration for type hinting, as the class is not available at this point\nclass BaseLLMProvider(ABC):\n    @abstractmethod\n    def complete(self, prompt: str, **kwargs) -> Dict[str, Any]:\n        pass\n\nlogger = logging.getLogger(\"CRCS\")\n\n@dataclass\nclass ControllerPerformanceMetrics:\n    \"\"\"Track performance metrics for each controller domain\"\"\"\n    domain: str\n    queries_processed: int = 0\n    successful_extractions: int = 0\n    failed_extractions: int = 0\n    average_response_time: float = 0.0\n    error_magnitude_reduction: float = 0.0\n    confidence_scores: List[float] = field(default_factory=list)\n    \n    @property\n    def success_rate(self) -> float:\n        if self.queries_processed == 0:\n            return 0.0\n        return self.successful_extractions / self.queries_processed\n    \n    @property\n    def average_confidence(self) -> float:\n        if not self.confidence_scores:\n            return 0.0\n        return sum(self.confidence_scores) / len(self.confidence_scores)\n\n@dataclass\nclass DomainControllerConfig:\n    \"\"\"Configuration for a specific frequency domain controller\"\"\"\n    domain_name: str\n    frequency_patterns: List[str]  # Trigger patterns for this domain\n    resonant_gain: float = 500.0   # Ki - specialized extraction gain\n    proportional_gain: float = 10.0  # Kp - general error correction\n    damping_factor: float = 0.1    # wc - operational flexibility\n    extraction_strategy: str = \"chunk_aggregation\"  # How to extract for this domain\n    context_window: int = 3        # Number of surrounding chunks to include\n    confidence_threshold: float = 0.7  # Minimum confidence for success\n    auto_tune: bool = True         # Whether to automatically adjust gains\n\nclass FrequencyDomainController(ABC):\n    \"\"\"Abstract base class for domain-specific controllers\"\"\"\n    \n    def __init__(self, config: DomainControllerConfig):\n        self.config = config\n        self.metrics = ControllerPerformanceMetrics(domain=config.domain_name)\n        \n    @abstractmethod\n    def detect_frequency_domain(self, query: str) -> bool:\n        \"\"\"Detect if query belongs to this frequency domain\"\"\"\n        pass\n    \n    @abstractmethod\n    def extract_specialized_context(self, chunks: List[str], query: str) -> Optional[str]:\n        \"\"\"Apply specialized extraction for this domain\"\"\"\n        pass\n    \n    def update_performance(self, success: bool, confidence: float, response_time: float):\n        \"\"\"Update performance metrics and auto-tune if enabled\"\"\"\n        self.metrics.queries_processed += 1\n        if success:\n            self.metrics.successful_extractions += 1\n        else:\n            self.metrics.failed_extractions += 1\n        \n        self.metrics.confidence_scores.append(confidence)\n        self.metrics.average_response_time = (\n            (self.metrics.average_response_time * (self.metrics.queries_processed - 1) + response_time) \n            / self.metrics.queries_processed\n        )\n        \n        # Auto-tuning logic\n        if self.config.auto_tune and self.metrics.queries_processed % 10 == 0:\n            self._auto_tune_parameters()\n    \n    def _auto_tune_parameters(self):\n        \"\"\"Automatically adjust controller parameters based on performance\"\"\"\n        success_rate = self.metrics.success_rate\n        avg_confidence = self.metrics.average_confidence\n        \n        # Increase resonant gain if success rate is low but confidence is high\n        if success_rate < 0.7 and avg_confidence > 0.6:\n            self.config.resonant_gain *= 1.1\n            logger.info(f\"Auto-tuned {self.config.domain_name}: Increased resonant gain to {self.config.resonant_gain}\")\n        \n        # Decrease damping if success rate is high (allow more precision)\n        elif success_rate > 0.9:\n            self.config.damping_factor *= 0.95\n            logger.info(f\"Auto-tuned {self.config.domain_name}: Decreased damping to {self.config.damping_factor}\")\n\nclass ImplementationResonanceController(FrequencyDomainController):\n    \"\"\"Specialized controller for Implementation Resonance queries\"\"\"\n    \n    def detect_frequency_domain(self, query: str) -> bool:\n        query_lower = query.lower()\n        return any(pattern in query_lower for pattern in self.config.frequency_patterns)\n    \n    def extract_specialized_context(self, chunks: List[str], query: str) -> Optional[str]:\n        \"\"\"High-gain extraction for Implementation Resonance domain\"\"\"\n        relevant_chunks = []\n        \n        for chunk in chunks:\n            chunk_lower = chunk.lower()\n            if any(pattern in chunk_lower for pattern in [\n                'implementation resonance', 'jedi principle 6', 'bridge the worlds', \n                'as above so below'\n            ]):\n                relevant_chunks.append(chunk)\n        \n        if relevant_chunks:\n            combined_context = \"\\n\\n\".join(relevant_chunks)\n            logger.info(f\"Implementation Resonance Controller: Found {len(relevant_chunks)} relevant chunks\")\n            return combined_context\n        \n        return None\n\nclass SPRController(FrequencyDomainController):\n    \"\"\"Specialized controller for SPR-related queries\"\"\"\n    \n    def detect_frequency_domain(self, query: str) -> bool:\n        query_lower = query.lower()\n        return any(pattern in query_lower for pattern in self.config.frequency_patterns)\n    \n    def extract_specialized_context(self, chunks: List[str], query: str) -> Optional[str]:\n        \"\"\"Extract SPR definitions and Guardian Points patterns\"\"\"\n        relevant_chunks = []\n        \n        for chunk in chunks:\n            chunk_lower = chunk.lower()\n            if any(pattern in chunk_lower for pattern in [\n                'guardian points', 'sparse priming representation', 'spr', \n                'cognitive keys', 'resonant patterns'\n            ]) or self._contains_guardian_points_pattern(chunk):\n                relevant_chunks.append(chunk)\n        \n        if relevant_chunks:\n            combined_context = \"\\n\\n\".join(relevant_chunks)\n            logger.info(f\"SPR Controller: Found {len(relevant_chunks)} SPR-related chunks\")\n            return combined_context\n        \n        return None\n    \n    def _contains_guardian_points_pattern(self, text: str) -> bool:\n        \"\"\"Detect Guardian Points pattern: CapitalLetter...lowercase...CapitalLetter\"\"\"\n        pattern = r'\\b[A-Z0-9][a-z]+(?:\\s+[a-z]+)*\\s+[A-Z0-9]\\b'\n        return bool(re.search(pattern, text))\n\nclass ProportionalResonantController(FrequencyDomainController):\n    \"\"\"Specialized controller for Proportional Resonant Control Pattern queries\"\"\"\n    \n    def detect_frequency_domain(self, query: str) -> bool:\n        query_lower = query.lower()\n        return any(pattern in query_lower for pattern in self.config.frequency_patterns)\n    \n    def extract_specialized_context(self, chunks: List[str], query: str) -> Optional[str]:\n        \"\"\"Extract context related to Proportional Resonant Control patterns\"\"\"\n        relevant_chunks = []\n        \n        for chunk in chunks:\n            chunk_lower = chunk.lower()\n            if any(pattern in chunk_lower for pattern in [\n                'proportional resonant', 'pr controller', 'frequency domain', 'resonant gain',\n                'oscillatory error', 'control pattern', 'proportionalresonantcontrolpattern'\n            ]):\n                relevant_chunks.append(chunk)\n        \n        if relevant_chunks:\n            combined_context = \"\\n\\n\".join(relevant_chunks)\n            logger.info(f\"Proportional Resonant Controller: Found {len(relevant_chunks)} relevant chunks\")\n            return combined_context\n        \n        return None\n\nclass CognitiveResonantControllerSystem:\n    \"\"\"\n    Master controller system managing multiple frequency domain controllers\n    Implements hierarchical control architecture with learning capabilities\n    \"\"\"\n    \n    def __init__(self, protocol_chunks: List[str], llm_provider: Optional[BaseLLMProvider] = None):\n        self.protocol_chunks = protocol_chunks\n        self.llm_provider = llm_provider  # Store the LLM provider\n        self.domain_controllers: Dict[str, FrequencyDomainController] = {}\n        self.general_controller_params = {\n            'proportional_gain': 10.0,\n            'integration_time': 1.0,\n            'damping': 0.1\n        }\n        self.system_metrics = {\n            'total_queries': 0,\n            'successful_domains': 0,\n            'fallback_activations': 0,\n            'learning_events': 0\n        }\n        \n        self._initialize_default_controllers()\n        logger.info(\"Cognitive Resonant Controller System initialized\")\n    \n    def _initialize_default_controllers(self):\n        \"\"\"Initialize the proven domain controllers\"\"\"\n        \n        # Implementation Resonance Controller (proven successful)\n        impl_config = DomainControllerConfig(\n            domain_name=\"ImplementationResonance\",\n            frequency_patterns=['implementation resonance', 'jedi principle 6', 'bridge the worlds'],\n            resonant_gain=500.0,\n            proportional_gain=10.0,\n            damping_factor=0.1\n        )\n        self.domain_controllers[\"ImplementationResonance\"] = ImplementationResonanceController(impl_config)\n        \n        # SPR Controller \n        spr_config = DomainControllerConfig(\n            domain_name=\"SPRQueries\",\n            frequency_patterns=['spr', 'sparse priming', 'guardian points', 'cognitive keys'],\n            resonant_gain=400.0,\n            proportional_gain=15.0,\n            damping_factor=0.15\n        )\n        self.domain_controllers[\"SPRQueries\"] = SPRController(spr_config)\n        \n        # Proportional Resonant Controller (NEW!)\n        pr_config = DomainControllerConfig(\n            domain_name=\"ProportionalResonantQueries\",\n            frequency_patterns=['proportional resonant', 'pr controller', 'proportionalresonantcontrolpattern'],\n            resonant_gain=450.0,\n            proportional_gain=12.0,\n            damping_factor=0.12\n        )\n        self.domain_controllers[\"ProportionalResonantQueries\"] = ProportionalResonantController(pr_config)\n        \n        logger.info(f\"Initialized {len(self.domain_controllers)} domain controllers\")\n    \n    def process_query(self, query: str) -> Tuple[Optional[str], Dict[str, Any]]:\n        \"\"\"\n        Main query processing with multi-domain controller selection\n        Returns: (extracted_context, control_metrics)\n        \"\"\"\n        start_time = time.time()\n        self.system_metrics['total_queries'] += 1\n        \n        # Phase 1: Domain Detection & Controller Selection\n        active_controllers = []\n        for domain_name, controller in self.domain_controllers.items():\n            if controller.detect_frequency_domain(query):\n                active_controllers.append((domain_name, controller))\n                logger.info(f\"Activated {domain_name} controller for query\")\n        \n        # Phase 2: Specialized Extraction\n        if active_controllers:\n            self.system_metrics['successful_domains'] += 1\n            \n            for domain_name, controller in active_controllers:\n                context = controller.extract_specialized_context(self.protocol_chunks, query)\n                if context:\n                    response_time = time.time() - start_time\n                    controller.update_performance(True, 0.85, response_time)\n                    \n                    return context, {\n                        'active_domain': domain_name,\n                        'controller_used': controller.__class__.__name__,\n                        'extraction_method': 'specialized_resonant',\n                        'response_time': response_time,\n                        'chunks_found': len(context.split('\\n\\n')),\n                        'system_metrics': self.system_metrics\n                    }\n        \n        # Phase 3: Fallback to General Proportional Control\n        self.system_metrics['fallback_activations'] += 1\n        logger.info(\"No specialized controller activated, using general proportional control\")\n        \n        # Pass the original query to the general extraction method\n        context = self._general_proportional_extraction(query)\n        \n        return context, {\n            'active_domain': 'General',\n            'controller_used': 'ProportionalControl' if not self.llm_provider else 'GenerativeFallback',\n            'extraction_method': 'tfidf_fallback' if not self.llm_provider else 'generative_response',\n            'response_time': time.time() - start_time,\n            'system_metrics': self.system_metrics\n        }\n    \n    def _general_proportional_extraction(self, query: str) -> Optional[str]:\n        \"\"\"\n        Fallback extraction. First tries TF-IDF, then uses a generative LLM if available.\n        \"\"\"\n        # --- TF-IDF Search (Attempt 1) ---\n        query_words = set(word.lower() for word in query.replace('?', '').split())\n        num_chunks = len(self.protocol_chunks)\n        \n        if num_chunks == 0:\n            return None\n        \n        idf = {\n            word: math.log(num_chunks / max(1, sum(1 for chunk in self.protocol_chunks if word in chunk.lower())))\n            for word in query_words\n        }\n        \n        best_chunk, max_score = None, 0\n        for chunk in self.protocol_chunks:\n            words_in_chunk = chunk.lower().split()\n            chunk_word_count = len(words_in_chunk)\n            if chunk_word_count == 0:\n                continue\n                \n            tfidf_score = sum(\n                (words_in_chunk.count(word) / chunk_word_count) * idf[word] \n                for word in query_words\n            )\n            \n            if tfidf_score > max_score:\n                max_score, best_chunk = tfidf_score, chunk\n        \n        if best_chunk and max_score > 0.3: # Raised threshold to prevent low-quality matches\n            logger.info(f\"General controller: Found context (TF-IDF Score: {max_score:.4f})\")\n            return best_chunk\n        \n        # --- Generative Fallback (Attempt 2) ---\n        if self.llm_provider:\n            logger.info(\"TF-IDF search failed. Engaging generative LLM for direct response.\")\n            try:\n                prompt = f\"You are ArchE, an advanced cognitive system. A user has sent you the following message: '{query}'. Please provide a direct, helpful, and concise response. IMPORTANT: Respond with plain text only. Do not use function calls, special formatting, or any structured output. Just give a natural, conversational response.\"\n                response = self.llm_provider.generate(prompt, model=\"gemini-1.5-pro\", max_tokens=1000, temperature=0.7)\n                \n                # Debug logging to see exactly what we're getting\n                logger.info(f\"LLM response type: {type(response)}, content: {response}\")\n                \n                # Handle both string and dict responses from the LLM provider\n                if isinstance(response, dict):\n                    # Check if it's a function call response\n                    if response.get(\"type\") == \"function_call\":\n                        logger.info(f\"LLM returned function call: {response.get('function')} with args: {response.get('arguments')}\")\n                        # Extract useful information from function call arguments\n                        args = response.get(\"arguments\", {})\n                        if isinstance(args, dict):\n                            # Look for common argument fields that might contain the response\n                            for key in [\"response\", \"answer\", \"text\", \"content\", \"message\"]:\n                                if key in args and args[key]:\n                                    return str(args[key])\n                            # If no direct response field, try to construct one from available data\n                            if args:\n                                return f\"Function {response.get('function')} called with: {str(args)}\"\n                        return \"I received your message, but I am having trouble formulating a response right now.\"\n                    else:\n                        # Other dict format - try to extract text\n                        logger.info(f\"LLM returned dict format: {response}\")\n                        # Look for common response fields\n                        for key in [\"response\", \"answer\", \"text\", \"content\", \"message\", \"output\"]:\n                            if key in response and response[key]:\n                                return str(response[key])\n                        return \"I received your message, but I am having trouble formulating a response right now.\"\n                elif isinstance(response, str):\n                    # Normal string response\n                    if response:\n                        return response.strip()\n                    else:\n                        logger.error(\"LLM response was empty string.\")\n                        return \"I received your message, but I am having trouble formulating a response right now.\"\n                else:\n                    # Unexpected response type\n                    logger.error(f\"LLM returned unexpected response type: {type(response)}\")\n                    return \"I received your message, but I am having trouble formulating a response right now.\"\n            except Exception as e:\n                logger.error(f\"Error during generative LLM fallback: {e}\", exc_info=True)\n                return f\"An error occurred while trying to generate a response: {e}\"\n\n        logger.warning(\"No relevant chunk found and no LLM provider available for generative fallback.\")\n        return None\n    \n    def get_system_diagnostics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system diagnostics\"\"\"\n        diagnostics = {\n            'system_metrics': self.system_metrics,\n            'domain_controllers': {}\n        }\n        \n        for domain_name, controller in self.domain_controllers.items():\n            diagnostics['domain_controllers'][domain_name] = {\n                'performance': {\n                    'domain': controller.metrics.domain,\n                    'queries_processed': controller.metrics.queries_processed,\n                    'successful_extractions': controller.metrics.successful_extractions,\n                    'failed_extractions': controller.metrics.failed_extractions,\n                    'success_rate': controller.metrics.success_rate,\n                    'average_confidence': controller.metrics.average_confidence,\n                    'average_response_time': controller.metrics.average_response_time\n                },\n                'config': {\n                    'domain_name': controller.config.domain_name,\n                    'frequency_patterns': controller.config.frequency_patterns,\n                    'resonant_gain': controller.config.resonant_gain,\n                    'proportional_gain': controller.config.proportional_gain,\n                    'damping_factor': controller.config.damping_factor\n                }\n            }\n        \n        return diagnostics\n\n# --- Start of new adapter class ---\nclass CognitiveResonantController:\n    \"\"\"\n    Adapter to make the original CRCS compatible with the CognitiveIntegrationHub.\n    \"\"\"\n    def __init__(self, protocol_chunks: List[str] = None, llm_provider: Optional[BaseLLMProvider] = None):\n        if protocol_chunks is None:\n            # Basic fallback for direct instantiation by the hub\n            protocol_chunks = [\"Default protocol chunk for CRCS initialization\"]\n        self._crcs = CognitiveResonantControllerSystem(protocol_chunks, llm_provider)\n\n    def handle_query(self, query: str) -> CognitiveResponse:\n        \"\"\"\n        Processes a query and transforms the output into the canonical CognitiveResponse.\n        \"\"\"\n        start_time = time.time()\n        context, metrics = self._crcs.process_query(query)\n        processing_time_ms = (time.time() - start_time) * 1000\n\n        if context:\n            # Successful extraction by a controller\n            confidence = 0.85 # High confidence for successful specific extraction\n            controller = metrics.get('controller_used', 'Unknown')\n            return CognitiveResponse(\n                content=context,\n                processing_path=\"crcs_direct\",\n                confidence=QuantumProbability(confidence, [f\"controller:{controller}\"]),\n                processing_time_ms=processing_time_ms,\n                controller_used=controller,\n                metadata=metrics\n            )\n        else:\n            # Fallback, no specific context found\n            confidence = 0.3 # Low confidence\n            return CognitiveResponse(\n                content=\"CRCS could not find a specific resonant context.\",\n                processing_path=\"crcs_fallback\",\n                confidence=QuantumProbability(confidence, [\"fallback_tfidf_or_llm\"]),\n                processing_time_ms=processing_time_ms,\n                controller_used=metrics.get('controller_used', 'GeneralProportional'),\n                fallback_reason=\"no_specific_controller_match\",\n                metadata=metrics\n            )\n# --- End of new adapter class ---\n\n# Import time for timing measurements\nimport time \n```\n\nEXAMPLE APPLICATION:\nClass: CognitiveResonantControllerSystem\n\nMaster controller system managing multiple frequency domain controllers\nImplements hierarchical control architecture with learning capabilities\n\nMethods: __init__, _initialize_default_controllers, process_query, _general_proportional_extraction, get_system_diagnostics\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/cognitive_resonant_controller.py; source_type: python_class"}