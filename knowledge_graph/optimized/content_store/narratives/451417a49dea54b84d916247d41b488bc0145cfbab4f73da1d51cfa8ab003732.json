{"content": "TERM: Class: WorkflowActionDiscovery\n\nDEFINITION:\nClass: WorkflowActionDiscovery\n\nDiscovers and catalogs all available workflows and actions for dynamic use\n\nMethods: __init__, _discover_workflows, _discover_actions, _extract_workflow_tasks, _extract_tags, list_available_workflows, list_available_actions, get_workflow, get_action, search_workflows\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_action_discovery.py, type: python_class\n\nFULL IMPLEMENTATION CODE (workflow_action_discovery.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nWorkflow and Action Discovery Module\nDiscovers available workflows and actions, allowing dynamic usage by agents\n\"\"\"\n\nimport json\nimport os\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass WorkflowActionDiscovery:\n    \"\"\"Discovers and catalogs all available workflows and actions for dynamic use\"\"\"\n    \n    def __init__(self, workflows_dir: str = None, action_registry=None):\n        \"\"\"\n        Initialize workflow and action discovery\n        \n        Args:\n            workflows_dir: Directory containing workflow JSON files\n            action_registry: ActionRegistry instance to query for available actions\n        \"\"\"\n        if workflows_dir is None:\n            # Default to Three_PointO_ArchE/workflows\n            base_dir = Path(__file__).parent\n            workflows_dir = str(base_dir.parent / \"workflows\")\n        \n        self.workflows_dir = Path(workflows_dir)\n        self.action_registry = action_registry\n        self.workflows_catalog = {}\n        self.actions_catalog = {}\n        \n        # Discover and load workflows and actions\n        self._discover_workflows()\n        self._discover_actions()\n        \n    def _discover_workflows(self):\n        \"\"\"Discover all available workflow JSON files\"\"\"\n        logger.info(f\"Discovering workflows in: {self.workflows_dir}\")\n        \n        if not self.workflows_dir.exists():\n            logger.warning(f\"Workflows directory does not exist: {self.workflows_dir}\")\n            return\n        \n        for workflow_file in self.workflows_dir.glob(\"*.json\"):\n            try:\n                with open(workflow_file, 'r') as f:\n                    workflow_data = json.load(f)\n                    \n                workflow_name = workflow_data.get('workflow_name') or workflow_file.stem\n                \n                # Extract key information\n                catalog_entry = {\n                    'name': workflow_name,\n                    'filename': workflow_file.name,\n                    'path': str(workflow_file),\n                    'description': workflow_data.get('description', ''),\n                    'tasks': self._extract_workflow_tasks(workflow_data),\n                    'input_parameters': workflow_data.get('input_parameters', {}),\n                    'output': workflow_data.get('output', {}),\n                    'tags': self._extract_tags(workflow_data)\n                }\n                \n                self.workflows_catalog[workflow_name] = catalog_entry\n                logger.debug(f\"Discovered workflow: {workflow_name}\")\n                \n            except Exception as e:\n                logger.warning(f\"Failed to load workflow {workflow_file.name}: {e}\")\n        \n        logger.info(f\"Discovered {len(self.workflows_catalog)} workflows\")\n        \n    def _discover_actions(self):\n        \"\"\"Discover all available actions from action registry\"\"\"\n        if not self.action_registry:\n            logger.warning(\"No action registry provided, cannot discover actions\")\n            return\n        \n        try:\n            # Get list of registered actions\n            actions = self.action_registry.list_actions()\n            \n            # Get signatures for each action\n            signatures = self.action_registry.get_action_signatures()\n            \n            for action_name in actions:\n                signature_info = signatures.get(action_name, {})\n                \n                self.actions_catalog[action_name] = {\n                    'name': action_name,\n                    'description': signature_info.get('doc', ''),\n                    'parameters': signature_info.get('params', {}),\n                    'callable': True\n                }\n            \n            logger.info(f\"Discovered {len(self.actions_catalog)} registered actions\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to discover actions: {e}\")\n    \n    def _extract_workflow_tasks(self, workflow_data: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Extract task information from workflow\"\"\"\n        tasks = []\n        workflow_tasks = workflow_data.get('tasks', {})\n        \n        for task_name, task_def in workflow_tasks.items():\n            tasks.append({\n                'task_id': task_name,\n                'action_type': task_def.get('action_type', 'unknown'),\n                'description': task_def.get('description', ''),\n                'inputs': task_def.get('inputs', {}),\n                'outputs': task_def.get('outputs', {}),\n                'dependencies': task_def.get('dependencies', [])\n            })\n        \n        return tasks\n    \n    def _extract_tags(self, workflow_data: Dict) -> List[str]:\n        \"\"\"Extract tags from workflow data\"\"\"\n        tags = []\n        \n        # Extract from description\n        description = workflow_data.get('description', '').lower()\n        \n        if 'knowledge' in description or 'scaffolding' in description:\n            tags.append('knowledge_scaffolding')\n        if 'rise' in description or 'resonant' in description:\n            tags.append('rise')\n        if 'analysis' in description:\n            tags.append('analysis')\n        if 'search' in description:\n            tags.append('search')\n        if 'dynamic' in description:\n            tags.append('dynamic')\n        if 'genesis' in description or 'autopoietic' in description:\n            tags.append('autopoietic')\n        if 'metamorphosis' in description:\n            tags.append('metamorphosis')\n        if 'strategy' in description or 'fusion' in description:\n            tags.append('strategy')\n        if 'vetting' in description:\n            tags.append('vetting')\n        \n        return tags\n    \n    def list_available_workflows(self) -> List[Dict[str, Any]]:\n        \"\"\"Return list of available workflows with metadata\"\"\"\n        return list(self.workflows_catalog.values())\n    \n    def list_available_actions(self) -> List[Dict[str, Any]]:\n        \"\"\"Return list of available actions with metadata\"\"\"\n        return list(self.actions_catalog.values())\n    \n    def get_workflow(self, workflow_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get workflow by name\"\"\"\n        return self.workflows_catalog.get(workflow_name)\n    \n    def get_action(self, action_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get action by name\"\"\"\n        return self.actions_catalog.get(action_name)\n    \n    def search_workflows(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"Search workflows by query string\"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for workflow_name, workflow in self.workflows_catalog.items():\n            # Search in name, description, tags\n            if (query_lower in workflow_name.lower() or\n                query_lower in workflow.get('description', '').lower() or\n                any(query_lower in tag for tag in workflow.get('tags', []))):\n                results.append(workflow)\n        \n        return results\n    \n    def search_actions(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"Search actions by query string\"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for action_name, action in self.actions_catalog.items():\n            if (query_lower in action_name.lower() or\n                query_lower in action.get('description', '').lower()):\n                results.append(action)\n        \n        return results\n    \n    def recommend_workflows_for_problem(self, problem_description: str) -> List[Dict[str, Any]]:\n        \"\"\"Recommend workflows based on problem description\"\"\"\n        recommendations = []\n        problem_lower = problem_description.lower()\n        \n        # Keyword-based recommendations\n        keyword_mappings = {\n            'knowledge': ['knowledge_scaffolding', 'robust_knowledge_gathering'],\n            'research': ['enhanced_search', 'advanced_research_analysis'],\n            'search': ['simple_search_test', 'enhanced_search'],\n            'strategy': ['strategy_fusion', 'autonomous_spacecraft'],\n            'analysis': ['dynamic_analysis', 'asymmetric_warfare_analysis'],\n            'quantum': ['quantum_hybrid_ai', 'quantum_drug_discovery'],\n            'rise': ['rise_v2_robust'],\n            'autopoietic': ['autopoietic_genesis_protocol'],\n            'metamorphosis': ['metamorphosis_protocol'],\n            'vetting': ['high_stakes_vetting']\n        }\n        \n        for keyword, workflow_keywords in keyword_mappings.items():\n            if keyword in problem_lower:\n                # Search for matching workflows\n                matched = self.search_workflows(keyword)\n                for workflow in matched:\n                    if workflow not in recommendations:\n                        recommendations.append({\n                            'workflow': workflow,\n                            'match_reason': f\"Problem mentions '{keyword}'\"\n                        })\n        \n        return recommendations[:5]  # Top 5 recommendations\n    \n    def get_complete_catalog(self) -> Dict[str, Any]:\n        \"\"\"Return complete catalog of workflows and actions\"\"\"\n        return {\n            'workflows': self.list_available_workflows(),\n            'actions': self.list_available_actions(),\n            'total_workflows': len(self.workflows_catalog),\n            'total_actions': len(self.actions_catalog)\n        }\n    \n    def export_catalog(self, output_path: str):\n        \"\"\"Export catalog to JSON file\"\"\"\n        catalog = self.get_complete_catalog()\n        \n        with open(output_path, 'w') as f:\n            json.dump(catalog, f, indent=2)\n        \n        logger.info(f\"Catalog exported to: {output_path}\")\n\n\n\n```\n\nEXAMPLE APPLICATION:\nClass: WorkflowActionDiscovery\n\nDiscovers and catalogs all available workflows and actions for dynamic use\n\nMethods: __init__, _discover_workflows, _discover_actions, _extract_workflow_tasks, _extract_tags, list_available_workflows, list_available_actions, get_workflow, get_action, search_workflows\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/workflow_action_discovery.py; source_type: python_class"}