{"content": "TERM: Function: forge_specification_from_intention\n\nDEFINITION:\nFunction: forge_specification_from_intention\n\nConvenience function to forge a specification from raw intention.\n\nArgs:\n    intention: The raw need or idea\n    proposed_name: Proposed name for the component\n    initiator: Who is requesting this (default: Guardian)\n    rationale: Why this is needed now\n    context: Where this fits in ArchE\n    related_principles: List of relevant principles\n    existing_components: List of related components\n    model: Optional LLM model to use\n    \nReturns:\n    Specification forging result\n\nParameters: intention, proposed_name, initiator, rationale, context\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/specification_forger_agent.py, type: python_function\n\nFULL IMPLEMENTATION CODE (specification_forger_agent.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nThe Specification Forger Agent\n\nWHO: The Scribe of ArchE, master of the ResonantiA Protocol\nWHAT: Transforms raw intentions into formal Living Specifications\nWHEN: Invoked when new capability needed OR gap detected\nWHERE: specifications/*.md (output location)\nWHY: Bridge abstract principles to concrete blueprints\nHOW: LLM-augmented generation using robust prompt template\n\nThis is the implementation of Chapter 1: The Lawgiver's Forge from the Genesis Protocol.\n\"\"\"\n\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\n\n# Temporal Core Integration\nfrom Three_PointO_ArchE.temporal_core import now_iso, format_filename\n\n# LLM Provider Integration\nfrom Three_PointO_ArchE.llm_providers import get_llm_provider, get_model_for_provider\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass SpecificationIntent:\n    \"\"\"\n    Captures the raw intention for a new specification.\n    \n    Answers the Six Questions:\n    - WHO: initiator (Guardian or AutopoieticLearningLoop)\n    - WHAT: intention (the raw need or idea)\n    - WHEN: timestamp (when this need was identified)\n    - WHERE: context (where this fits in ArchE)\n    - WHY: rationale (why this is needed now)\n    - HOW: approach (initial thoughts on implementation)\n    \"\"\"\n    intention: str\n    initiator: str  # \"Guardian\" or \"AutopoieticLearningLoop\"\n    timestamp: str\n    related_principles: List[str]\n    existing_components: List[str]\n    rationale: str\n    proposed_name: str\n    context: str\n\n\nclass SpecificationForgerAgent:\n    \"\"\"\n    The Lawgiver's Forge: Transforms raw intentions into Living Specifications.\n    \n    This agent implements the Specification Forger Protocol by:\n    1. Receiving raw, unstructured intent\n    2. Augmenting with LLM using robust prompt template\n    3. Generating formal, multi-part specification\n    4. Presenting for Guardian review\n    5. Solidifying approved specs into specifications/\n    \"\"\"\n    \n    def __init__(self, model: Optional[str] = None):\n        \"\"\"\n        Initialize the Specification Forger Agent.\n        \n        Args:\n            model: Optional LLM model to use (defaults to provider default)\n        \"\"\"\n        self.llm_provider = get_llm_provider()\n        self.model = model or get_model_for_provider('google')\n        self.prompt_template = self._load_prompt_template()\n        logger.info(f\"Specification Forger Agent initialized with model: {self.model}\")\n    \n    def _load_prompt_template(self) -> Dict[str, Any]:\n        \"\"\"\n        Load the robust prompt template for specification generation.\n        \n        Returns:\n            The prompt template structure\n        \"\"\"\n        return {\n            \"role\": (\n                \"You are the Scribe of ArchE, a master of the ResonantiA Protocol. \"\n                \"Your task is to transform a raw intention into a formal, multi-part Living Specification. \"\n                \"The specification must be so clear and complete that another AI could use it to write the \"\n                \"full implementation without further questions. It must resonate with the principle of 'As Above, So Below.' \"\n                \"You MUST answer the Six Sacred Questions (WHO, WHAT, WHEN, WHERE, WHY, HOW) in every section.\"\n            ),\n            \"input_variables\": [\"intention\", \"related_principles\", \"existing_components\", \"initiator\", \"rationale\"],\n            \"output_format\": {\n                \"title\": \"The Chronicle of [Component Name]\",\n                \"sections\": [\n                    {\n                        \"name\": \"Part I: The Six Questions (Grounding)\",\n                        \"subsections\": [\n                            \"WHO: Identity & Stakeholders\",\n                            \"WHAT: Essence & Transformation\", \n                            \"WHEN: Temporality & Sequence\",\n                            \"WHERE: Location & Context\",\n                            \"WHY: Purpose & Causation\",\n                            \"HOW: Mechanism & Process\"\n                        ]\n                    },\n                    {\n                        \"name\": \"Part II: The Philosophical Mandate\",\n                        \"instruction\": \"Describe the core purpose. What problem does it solve? Frame in ResonantiA Saga.\"\n                    },\n                    {\n                        \"name\": \"Part III: The Allegory\",\n                        \"instruction\": \"Create a powerful real-world analogy (e.g., 'The Master Watchmaker').\"\n                    },\n                    {\n                        \"name\": \"Part IV: The Web of Knowledge (SPR Integration)\",\n                        \"instruction\": \"Define primary SPR and relationships to other SPRs.\"\n                    },\n                    {\n                        \"name\": \"Part V: The Technical Blueprint\",\n                        \"instruction\": \"Detailed blueprint: class names, method signatures, data structures.\"\n                    },\n                    {\n                        \"name\": \"Part VI: The IAR Compliance Pattern\",\n                        \"instruction\": \"How will operations be logged to ThoughtTrail?\"\n                    },\n                    {\n                        \"name\": \"Part VII: Validation Criteria\",\n                        \"instruction\": \"How to verify implementation resonance?\"\n                    }\n                ]\n            },\n            \"constraints\": [\n                \"Each section must fully answer the relevant question\",\n                \"Language must be epic yet precise\",\n                \"Technical blueprint must enable code generation\",\n                \"Specification must be self-contained and complete\",\n                \"Use proper markdown formatting with headers and sections\"\n            ]\n        }\n    \n    def forge_specification(self, intent: SpecificationIntent) -> Dict[str, Any]:\n        \"\"\"\n        The Lawgiver's Forge: Transform intention into specification.\n        \n        WHO: Called by Guardian or AutopoieticLearningLoop\n        WHAT: Generates formal specification from raw intent\n        WHEN: When new capability needed\n        WHERE: Creates file in specifications/\n        WHY: Bridge abstract need to concrete blueprint\n        HOW: LLM-augmented generation with robust prompt\n        \n        Args:\n            intent: The raw intention captured as SpecificationIntent\n            \n        Returns:\n            Dictionary containing:\n            - specification_text: The generated markdown\n            - file_path: Proposed path for the specification\n            - metadata: Generation metadata\n        \"\"\"\n        logger.info(f\"Forging specification: {intent.proposed_name}\")\n        logger.info(f\"Initiator: {intent.initiator}, Timestamp: {intent.timestamp}\")\n        \n        # Step 1: Construct the robust prompt\n        prompt = self._construct_prompt(intent)\n        \n        # Step 2: Invoke LLM (with timing)\n        try:\n            import time\n            logger.info(f\"Invoking LLM with model: {self.model}\")\n            start_time = time.time()\n            \n            response = self.llm_provider.generate(\n                prompt=prompt,\n                model=self.model,\n                max_tokens=16384,  # Large for comprehensive spec\n                temperature=0.7    # Balance creativity and coherence\n            )\n            \n            generation_time_ms = (time.time() - start_time) * 1000\n            specification_text = response\n            \n            # Step 3: Format and structure\n            formatted_spec = self._format_specification(\n                text=specification_text,\n                intent=intent\n            )\n            \n            # Step 4: Validate specification structure\n            has_six_questions = all(q in formatted_spec for q in [\"WHO:\", \"WHAT:\", \"WHEN:\", \"WHERE:\", \"WHY:\", \"HOW:\"])\n            has_iar_compliance = \"IAR Compliance\" in formatted_spec or \"Intention, Action, Reflection\" in formatted_spec\n            \n            # Calculate confidence based on validation\n            confidence = 0.5  # Base\n            if has_six_questions:\n                confidence += 0.3\n            if has_iar_compliance:\n                confidence += 0.2\n            \n            # Step 5: Generate metadata\n            file_path = f\"specifications/{self._sanitize_filename(intent.proposed_name)}.md\"\n            \n            result = {\n                \"specification_text\": formatted_spec,\n                \"file_path\": file_path,\n                \"metadata\": {\n                    \"generated_at\": now_iso(),\n                    \"initiator\": intent.initiator,\n                    \"original_intent\": intent.intention,\n                    \"model_used\": self.model,\n                    \"status\": \"draft_pending_guardian_review\",\n                    \"generation_time_ms\": generation_time_ms,\n                    \"confidence\": confidence,\n                    \"has_six_questions\": has_six_questions,\n                    \"has_iar_compliance\": has_iar_compliance\n                }\n            }\n            \n            logger.info(f\"Specification forged successfully: {file_path} (confidence: {confidence:.3f}, time: {generation_time_ms:.0f}ms)\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Specification forging failed: {e}\", exc_info=True)\n            return {\n                \"error\": str(e),\n                \"specification_text\": None,\n                \"file_path\": None,\n                \"metadata\": {\n                    \"generated_at\": now_iso(),\n                    \"status\": \"failed\"\n                }\n            }\n    \n    def _construct_prompt(self, intent: SpecificationIntent) -> str:\n        \"\"\"\n        Construct the robust prompt for LLM.\n        \n        Args:\n            intent: The specification intent\n            \n        Returns:\n            Formatted prompt string\n        \"\"\"\n        prompt = f\"\"\"\n{self.prompt_template['role']}\n\nINPUT CONTEXT:\n- Intention: {intent.intention}\n- Initiator: {intent.initiator}\n- Timestamp: {intent.timestamp}\n- Rationale: {intent.rationale}\n- System Context: {intent.context}\n- Related Principles: {', '.join(intent.related_principles)}\n- Existing Components: {', '.join(intent.existing_components)}\n\nYOUR TASK:\nGenerate a complete Living Specification for: \"{intent.proposed_name}\"\n\nThe specification MUST include these sections:\n\n## Part I: The Six Questions (Grounding)\n\nAnswer each question comprehensively:\n\n### WHO: Identity & Stakeholders\n- Who initiates this component?\n- Who uses it?\n- Who approves it?\n\n### WHAT: Essence & Transformation\n- What is this component?\n- What does it transform?\n- What is its fundamental nature?\n\n### WHEN: Temporality & Sequence\n- When is it invoked?\n- When does it complete?\n- What is its lifecycle?\n\n### WHERE: Location & Context\n- Where does it live in the system?\n- Where does it fit in the hierarchy?\n- What is its context?\n\n### WHY: Purpose & Causation\n- Why does this exist?\n- Why this approach?\n- Why now?\n\n### HOW: Mechanism & Process\n- How does it work?\n- How is it implemented?\n- How is it validated?\n\n## Part II: The Philosophical Mandate\n\nFrame this in the epic narrative of the ResonantiA Saga. What fundamental problem does this solve? What paradox does it address?\n\n## Part III: The Allegory\n\nCreate a powerful, real-world analogy or metaphor that explains how this works.\n\n## Part IV: The Web of Knowledge (SPR Integration)\n\nDefine the primary SPR for this component. Detail its relationships to other SPRs.\n\n## Part V: The Technical Blueprint\n\nProvide detailed technical specifications:\n- Primary class name(s)\n- Key methods with full signatures (arguments and return types)\n- Expected data structures\n- Integration points\n\n## Part VI: The IAR Compliance Pattern\n\nDescribe how this component adheres to Intention-Action-Reflection:\n- How operations are logged to ThoughtTrail\n- Success and failure reflection patterns\n- Confidence scoring approach\n\n## Part VII: Validation Criteria\n\nDefine how to verify implementation resonance:\n- What tests prove correctness?\n- What metrics indicate success?\n- How to detect implementation drift?\n\nCONSTRAINTS:\n{chr(10).join(f'- {c}' for c in self.prompt_template['constraints'])}\n\nGenerate the complete specification now:\n\"\"\"\n        return prompt\n    \n    def _format_specification(self, text: str, intent: SpecificationIntent) -> str:\n        \"\"\"\n        Format the generated specification with proper headers and metadata.\n        \n        Args:\n            text: Raw LLM-generated text\n            intent: Original intent\n            \n        Returns:\n            Formatted markdown specification\n        \"\"\"\n        header = f\"\"\"# {intent.proposed_name}\n\n**Generated**: {now_iso()}  \n**Initiator**: {intent.initiator}  \n**Status**: ðŸ”„ DRAFT (Awaiting Guardian Approval)  \n**Genesis Protocol**: Specification Forger Agent v1.0\n\n---\n\n## Original Intent\n\n{intent.intention}\n\n**Rationale**: {intent.rationale}\n\n**Context**: {intent.context}\n\n---\n\n\"\"\"\n        \n        footer = f\"\"\"\n\n---\n\n## Metadata\n\n- **Generated By**: Specification Forger Agent\n- **Model Used**: {self.model}\n- **Timestamp**: {now_iso()}\n- **Related Principles**: {', '.join(intent.related_principles)}\n- **Existing Components**: {', '.join(intent.existing_components)}\n\n---\n\n**Specification Status**: ðŸ”„ AWAITING GUARDIAN APPROVAL  \n**Next Step**: Guardian review and approval before solidification  \n\n---\n\n> Generated via the Genesis Protocol: The Lawgiver's Forge\n\"\"\"\n        \n        return header + text + footer\n    \n    def _sanitize_filename(self, name: str) -> str:\n        \"\"\"\n        Convert proposed name to valid filename.\n        \n        Args:\n            name: Proposed component name\n            \n        Returns:\n            Sanitized filename (lowercase, underscores)\n        \"\"\"\n        return name.lower().replace(' ', '_').replace('-', '_')\n    \n    def solidify_specification(self, draft_path: str, guardian_approved: bool) -> Dict[str, Any]:\n        \"\"\"\n        Solidify an approved specification into canonical form.\n        \n        WHO: Guardian approval required\n        WHAT: Move draft to canonical specifications/\n        WHEN: After Guardian review\n        WHERE: specifications/ directory\n        WHY: Specification becomes living law\n        HOW: Update status, commit to filesystem\n        \n        Args:\n            draft_path: Path to draft specification\n            guardian_approved: Whether Guardian approved\n            \n        Returns:\n            Solidification result\n        \"\"\"\n        if not guardian_approved:\n            logger.warning(f\"Specification NOT approved by Guardian: {draft_path}\")\n            return {\n                \"solidified\": False,\n                \"reason\": \"Guardian approval required\",\n                \"draft_path\": draft_path\n            }\n        \n        try:\n            # Read draft\n            draft_file = Path(draft_path)\n            content = draft_file.read_text()\n            \n            # Update status\n            content = content.replace(\n                \"**Status**: ðŸ”„ DRAFT (Awaiting Guardian Approval)\",\n                f\"**Status**: âœ… CANONICAL (Guardian Approved at {now_iso()})\"\n            )\n            content = content.replace(\n                \"**Specification Status**: ðŸ”„ AWAITING GUARDIAN APPROVAL\",\n                \"**Specification Status**: âœ… CANONICAL\"\n            )\n            \n            # Write back\n            draft_file.write_text(content)\n            \n            logger.info(f\"Specification solidified: {draft_path}\")\n            \n            return {\n                \"solidified\": True,\n                \"canonical_path\": str(draft_file),\n                \"solidified_at\": now_iso()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Solidification failed: {e}\", exc_info=True)\n            return {\n                \"solidified\": False,\n                \"error\": str(e)\n            }\n\n\n# ============================================================================\n# CONVENIENCE FUNCTION\n# ============================================================================\n\ndef forge_specification_from_intention(\n    intention: str,\n    proposed_name: str,\n    initiator: str = \"Guardian\",\n    rationale: str = \"\",\n    context: str = \"\",\n    related_principles: Optional[List[str]] = None,\n    existing_components: Optional[List[str]] = None,\n    model: Optional[str] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Convenience function to forge a specification from raw intention.\n    \n    Args:\n        intention: The raw need or idea\n        proposed_name: Proposed name for the component\n        initiator: Who is requesting this (default: Guardian)\n        rationale: Why this is needed now\n        context: Where this fits in ArchE\n        related_principles: List of relevant principles\n        existing_components: List of related components\n        model: Optional LLM model to use\n        \n    Returns:\n        Specification forging result\n    \"\"\"\n    intent = SpecificationIntent(\n        intention=intention,\n        initiator=initiator,\n        timestamp=now_iso(),\n        related_principles=related_principles or [\"As Above, So Below\", \"Universal Abstraction\"],\n        existing_components=existing_components or [],\n        rationale=rationale,\n        proposed_name=proposed_name,\n        context=context\n    )\n    \n    agent = SpecificationForgerAgent(model=model)\n    return agent.forge_specification(intent)\n\n\n```\n\nEXAMPLE APPLICATION:\nFunction: forge_specification_from_intention\n\nConvenience function to forge a specification from raw intention.\n\nArgs:\n    intention: The raw need or idea\n    proposed_name: Proposed name for the component\n    initiator: Who is requesting this (default: Guardian)\n    rationale: Why this is needed now\n    context: Where this fits in ArchE\n    related_principles: List of relevant principles\n    existing_components: List of related components\n    model: Optional LLM model to use\n    \nReturns:\n    S\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/specification_forger_agent.py; source_type: python_function"}