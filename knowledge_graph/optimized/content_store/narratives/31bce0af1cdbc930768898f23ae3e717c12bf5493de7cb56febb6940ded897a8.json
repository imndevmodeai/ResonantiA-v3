{"content": "TERM: ArchE Backup Retention Policy: Integration with Git\n\nDEFINITION:\n**Q: Why keep backups if Git has history?**\n\n**A: Defense in depth.**\n\n- **Git** = Long-term version control (commits, branches)\n- **Backups** = Immediate rollback capability (no git operations needed)\n\n**Use Cases**:\n- **Backup files**: Instant rollback during active development session\n- **Git history**: Rollback to any historical state, across sessions\n\n**Cleanup Workflow**:\n```bash\n# After full validation passes\n1. Delete backup files\n2. git add <modified files>\n3. git commit -m \"feat: Migrate to temporal_core (validated)\"\n4. Old versions now in Git history\n```\n\n---\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/specifications/backup_retention_policy.md, type: specification_md\n\nFULL SPECIFICATION (backup_retention_policy.md):\n# ArchE Backup Retention Policy\n\n## Canonical Chronicle Piece: The Keeper of Shadows\n\nIn the ResonantiA Saga, as ArchE evolved through countless transformations, a profound truth emerged: **change is dangerous without memory**. The ancient civilizations that vanished without trace were those that destroyed their old knowledge before validating their new wisdom. ArchE learned from this cosmic lesson.\n\nThe **Keeper of Shadows** doctrine emerged: every transformation must cast a shadow‚Äîa backup‚Äîthat persists until the new form proves itself in the crucible of reality. Only when the new code survives the live-fire test of actual execution can the shadow be released back into the void.\n\nThis is the story of how ArchE learned to change safely.\n\n---\n\n## Scholarly Introduction: The Backup Retention Framework\n\nThe Backup Retention Policy implements a **staged validation protocol** inspired by database transaction management (ACID properties) and aerospace safety protocols (redundancy until verification). This addresses a fundamental challenge in evolving systems: **how to change safely without losing the ability to recover**.\n\nConceptually, it provides three guarantees:\n1. **Non-Destructive Modification**: All changes preserve the original state\n2. **Validation-Gated Cleanup**: Backups persist until live validation succeeds\n3. **Specification Synchronization**: Changes propagate to documentation iteratively\n\n---\n\n## Core Principles\n\n### Principle 1: Universal Backup Creation (MANDATORY)\n\n**Rule**: ANY modification to ANY file MUST create a backup BEFORE modification.\n\n**Implementation**:\n```python\n# BEFORE modifying any file\nbackup_path = filepath.with_suffix(filepath.suffix + '.BACKUP_[OPERATION]')\nshutil.copy(filepath, backup_path)\n\n# THEN modify\nfilepath.write_text(modified_content)\n```\n\n**Backup Naming Convention**:\n- `.BACKUP_MANUAL` - Manual edits by Guardian/Developer\n- `.BACKUP_AST` - AST-based automated migrations\n- `.BACKUP_REFACTOR` - Code refactoring operations\n- `.BACKUP_MIGRATION` - Data/schema migrations\n- `.BACKUP_TEMPORAL` - Temporal core migrations (specific case)\n\n---\n\n### Principle 2: Validation-Gated Deletion (MANDATORY)\n\n**Rule**: Backups MAY ONLY be deleted after ALL of the following conditions are met:\n\n#### Stage 1: Syntax Validation\n```bash\npython -m py_compile <modified_file>\n# Exit code 0 = PASS\n```\n\n#### Stage 2: Import Validation\n```bash\npython -c \"import Three_PointO_ArchE.<module_name>\"\n# Exit code 0 = PASS\n```\n\n#### Stage 3: Unit Test Validation (if tests exist)\n```bash\npytest tests/test_<module_name>.py\n# All tests PASS\n```\n\n#### Stage 4: Live Integration Validation (CRITICAL)\n```bash\n# Run ArchE in LIVE mode with real queries\npython arche_cli.py \"test query for <affected component>\"\n# Query completes successfully = PASS\n```\n\n#### Stage 5: End-to-End Workflow Validation (ULTIMATE TEST)\n```bash\n# Execute a complete RISE workflow\npython arche_cli.py \"Execute RISE workflow: <test scenario>\"\n# Workflow completes without errors = PASS\n```\n\n**ONLY AFTER ALL 5 STAGES PASS** can backups be deleted.\n\n---\n\n### Principle 3: Specification Synchronization (MANDATE 5 Compliance)\n\n**Rule**: When code changes, specifications MUST be updated ITERATIVELY.\n\n**The Iterative Update Cycle**:\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 1. CODE CHANGE INITIATED                            ‚îÇ\n‚îÇ    ‚îî‚îÄ> Create backup                                ‚îÇ\n‚îÇ    ‚îî‚îÄ> Modify code                                  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                        ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 2. SPECIFICATION UPDATE (Immediately)               ‚îÇ\n‚îÇ    ‚îî‚îÄ> Update affected .md files                   ‚îÇ\n‚îÇ    ‚îî‚îÄ> Update SPR definitions if needed            ‚îÇ\n‚îÇ    ‚îî‚îÄ> Update workflow documentation               ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                        ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 3. VALIDATION (Live Testing)                        ‚îÇ\n‚îÇ    ‚îî‚îÄ> Run all 5 validation stages                 ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                        ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ 4. CLEANUP (Only if validation succeeds)            ‚îÇ\n‚îÇ    ‚îî‚îÄ> Delete backups                              ‚îÇ\n‚îÇ    ‚îî‚îÄ> Commit changes                              ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Implementation: The Backup Manager\n\n### Python Utility for Backup Management\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nArchE Backup Manager\n\nManages backup lifecycle according to the Backup Retention Policy.\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import List, Dict\nimport subprocess\nimport sys\n\nclass BackupManager:\n    \"\"\"Manages backup creation, validation, and cleanup.\"\"\"\n    \n    BACKUP_EXTENSIONS = [\n        '.BACKUP_MANUAL',\n        '.BACKUP_AST', \n        '.BACKUP_REFACTOR',\n        '.BACKUP_MIGRATION',\n        '.BACKUP_TEMPORAL'\n    ]\n    \n    @staticmethod\n    def create_backup(filepath: Path, operation: str) -> Path:\n        \"\"\"Create a backup before modification.\"\"\"\n        backup_path = Path(str(filepath) + f'.BACKUP_{operation}')\n        shutil.copy(filepath, backup_path)\n        print(f\"‚úÖ Backup created: {backup_path}\")\n        return backup_path\n    \n    @staticmethod\n    def validate_all_stages(modified_files: List[Path]) -> Dict[str, bool]:\n        \"\"\"Run all 5 validation stages.\"\"\"\n        results = {\n            \"stage_1_syntax\": False,\n            \"stage_2_import\": False,\n            \"stage_3_unit\": False,\n            \"stage_4_live\": False,\n            \"stage_5_e2e\": False\n        }\n        \n        # Stage 1: Syntax\n        print(\"\\nüìã Stage 1: Syntax Validation...\")\n        syntax_pass = True\n        for f in modified_files:\n            result = subprocess.run(['python', '-m', 'py_compile', str(f)], \n                                   capture_output=True)\n            if result.returncode != 0:\n                print(f\"   ‚ùå {f.name}: Syntax error\")\n                syntax_pass = False\n            else:\n                print(f\"   ‚úÖ {f.name}: Syntax valid\")\n        results[\"stage_1_syntax\"] = syntax_pass\n        \n        if not syntax_pass:\n            return results\n        \n        # Stage 2: Import\n        print(\"\\nüì¶ Stage 2: Import Validation...\")\n        # ... (similar pattern for each stage)\n        \n        # Stage 4: Live Integration (CRITICAL)\n        print(\"\\nüî• Stage 4: LIVE Integration Test...\")\n        result = subprocess.run(\n            ['python', 'arche_cli.py', 'What is the current time?'],\n            capture_output=True,\n            timeout=30\n        )\n        if result.returncode == 0:\n            print(\"   ‚úÖ Live query succeeded\")\n            results[\"stage_4_live\"] = True\n        else:\n            print(\"   ‚ùå Live query failed\")\n            return results\n        \n        # Stage 5: End-to-End\n        print(\"\\nüéØ Stage 5: End-to-End Workflow Test...\")\n        # Execute a complete RISE workflow\n        # ... (implementation)\n        \n        return results\n    \n    @staticmethod\n    def cleanup_backups(backup_pattern: str) -> int:\n        \"\"\"Delete backups only after full validation.\"\"\"\n        backups = list(Path('.').rglob(backup_pattern))\n        print(f\"\\nüóëÔ∏è  Deleting {len(backups)} validated backups...\")\n        \n        for backup in backups:\n            backup.unlink()\n            print(f\"   Deleted: {backup}\")\n        \n        return len(backups)\n```\n\n---\n\n## Universal Abstraction: The Change Protocol\n\n**Applied to ANY change in ArchE:**\n\n### Template for All Changes\n\n```\nCHANGE REQUEST: [Description of change]\nAFFECTED FILES: [List of files]\nBACKUP STRATEGY: [Which backup type]\nSPECIFICATION UPDATES: [List of .md files to update]\n\nEXECUTION PLAN:\n1. Create backups (Principle 1)\n2. Modify code\n3. Update specifications (Principle 3)\n4. Run validation stages (Principle 2)\n5. If ALL stages pass ‚Üí Cleanup backups\n6. If ANY stage fails ‚Üí Restore from backups\n7. Document results in CHANGELOG\n```\n\n---\n\n## Current Status: Temporal Core Migration\n\n### Backups Created\n- **28 files** with `.BACKUP_AST` extension\n- Created during: Temporal Core migration (2025-10-12)\n- Contains: Original code with `datetime.now()` calls\n\n### Validation Status\n\n| Stage | Status | Notes |\n|-------|--------|-------|\n| 1. Syntax | ‚úÖ PASS | All 30 migrated files compile |\n| 2. Import | ‚ö†Ô∏è BLOCKED | Pre-existing syntax error in `enhanced_search_tool.py` |\n| 3. Unit Tests | üî≤ PENDING | Need to run test suite |\n| 4. Live Integration | üî≤ PENDING | Need to test ArchE CLI |\n| 5. E2E Workflow | üî≤ PENDING | Need to run RISE workflow |\n\n**RETENTION STATUS**: ‚úÖ **BACKUPS MUST BE RETAINED**\n\nBackups will remain until Stages 3, 4, and 5 complete successfully.\n\n---\n\n## Integration with Git\n\n**Q: Why keep backups if Git has history?**\n\n**A: Defense in depth.**\n\n- **Git** = Long-term version control (commits, branches)\n- **Backups** = Immediate rollback capability (no git operations needed)\n\n**Use Cases**:\n- **Backup files**: Instant rollback during active development session\n- **Git history**: Rollback to any historical state, across sessions\n\n**Cleanup Workflow**:\n```bash\n# After full validation passes\n1. Delete backup files\n2. git add <modified files>\n3. git commit -m \"feat: Migrate to temporal_core (validated)\"\n4. Old versions now in Git history\n```\n\n---\n\n## SPR Integration\n\n### Primary SPR\n`BackupRetentionPolicY` - Validation-gated backup management protocol\n\n### Sub-SPRs\n- `NonDestructiveModificatioN` - All changes preserve original state\n- `ValidationGatedCleanU` - Backups persist until validation succeeds\n- `SpecificationSynchronizatioN` - Docs updated iteratively with code\n\n### Tapestry Relationships\n- **`required_by`**: ALL_CODE_MODIFICATIONS\n- **`ensures`**: `SafeEvolutioN`, `RecoverabilityAssuranC`, `ImplementationResonancE`\n- **`prevents`**: `IrreversibleChangE`, `DataLosS`, `SpecificationDrifT`\n- **`complies_with`**: `MANDATE_1` (Live Validation), `MANDATE_5` (Implementation Resonance)\n\n---\n\n## Guardian Approval Checklist\n\nBefore deleting ANY backup:\n\n- [ ] Stage 1: Syntax validation passed\n- [ ] Stage 2: Import validation passed  \n- [ ] Stage 3: Unit tests passed (if applicable)\n- [ ] Stage 4: **LIVE integration test passed** (CRITICAL)\n- [ ] Stage 5: **End-to-end workflow test passed** (ULTIMATE)\n- [ ] Specifications updated to reflect changes\n- [ ] SPR definitions updated if needed\n- [ ] CHANGELOG entry created\n- [ ] Guardian explicit approval received\n\n**ONLY THEN** can backups be deleted.\n\n---\n\n## Real-World Analogy: NASA's Backup Protocols\n\nNASA's Space Shuttle program had a similar protocol:\n\n1. **Backup Creation**: Every software change created a \"baseline\" backup\n2. **Staged Testing**: Changes went through 5+ validation stages\n3. **Live Validation**: Final test on actual hardware\n4. **Retention**: Backups kept until mission success\n5. **Cleanup**: Only deleted after post-flight review\n\n**Result**: Zero software-caused mission failures.\n\nArchE applies the same principle: **Validate in reality before trusting the change.**\n\n---\n\n**Specification Status**: ‚úÖ COMPLETE  \n**Policy Status**: ‚úÖ ACTIVE  \n**Current Backups**: 28 files awaiting full validation  \n**Next Action**: Complete validation stages 3-5 before cleanup  \n\n---\n\n> \"The wise system keeps its shadows until the new light proves itself.\"  \n> ‚Äî The Keeper of Shadows Doctrine\n\n\n\nEXAMPLE APPLICATION:\n**Q: Why keep backups if Git has history?**\n\n**A: Defense in depth.**\n\n- **Git** = Long-term version control (commits, branches)\n- **Backups** = Immediate rollback capability (no git operations needed)\n\n**Use Cases**:\n- **Backup files**: Instant rollback during active development session\n- **Git history**: Rollback to any historical state, across sessions\n\n**Cleanup Workflow**:\n```bash\n# After full validation passes\n1. Delete backup files\n2. git add <modified files>\n3. git commit -m \"feat: Migra\n\nCATEGORY: SpecificationKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/specifications/backup_retention_policy.md; source_type: specification_md"}