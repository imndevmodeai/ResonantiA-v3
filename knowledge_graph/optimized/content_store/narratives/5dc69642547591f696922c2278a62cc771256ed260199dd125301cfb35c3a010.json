{"content": "TERM: Class: LogScribe\n\nDEFINITION:\nClass: LogScribe\n\nA class to generate human-readable changelogs from GitHub repository commits.\n\nMethods: __init__, _parse_repo_url, _fetch_commits, _generate_changelog_prompt, generate_changelog\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/logscribe_core.py, type: python_class\n\nFULL IMPLEMENTATION CODE (logscribe_core.py):\n```python\nimport os\nimport requests\nimport openai\nimport logging\nfrom datetime import datetime, timedelta\n\n# ============================================================================\n# TEMPORAL CORE INTEGRATION (CANONICAL DATETIME SYSTEM)\n# ============================================================================\nfrom .temporal_core import now_iso, format_filename, format_log, Timer\nfrom typing import List, Dict, Any, Optional\n\n# ============================================================================\n# TEMPORAL CORE INTEGRATION (CANONICAL DATETIME SYSTEM)\n# ============================================================================\nfrom Three_PointO_ArchE.temporal_core import now, now_iso, ago, from_now, format_log, format_filename\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass LogScribe:\n    \"\"\"\n    A class to generate human-readable changelogs from GitHub repository commits.\n    \"\"\"\n\n    def __init__(self, api_key: str, github_token: Optional[str] = None):\n        \"\"\"\n        Initializes the LogScribe instance.\n\n        Args:\n            api_key (str): The OpenAI API key.\n            github_token (str, optional): A GitHub personal access token for higher\n                                         API rate limits. Defaults to None.\n        \"\"\"\n        if not api_key:\n            raise ValueError(\"OpenAI API key is required.\")\n        openai.api_key = api_key\n        self.github_headers = {\n            \"Accept\": \"application/vnd.github.v3+json\"\n        }\n        if github_token:\n            self.github_headers[\"Authorization\"] = f\"token {github_token}\"\n        logger.info(\"LogScribe instance initialized\")\n\n    def _parse_repo_url(self, repo_url: str) -> Optional[Dict[str, str]]:\n        \"\"\"Parses a GitHub URL to extract owner and repo name.\"\"\"\n        try:\n            parts = repo_url.strip().split('/')\n            if \"github.com\" not in parts[-3]:\n                logger.error(f\"Invalid GitHub URL format: {repo_url}\")\n                return None\n            owner = parts[-2]\n            repo = parts[-1].replace('.git', '')\n            logger.debug(f\"Parsed repository: {owner}/{repo}\")\n            return {\"owner\": owner, \"repo\": repo}\n        except IndexError:\n            logger.error(f\"Failed to parse repository URL: {repo_url}\")\n            return None\n\n    def _fetch_commits(self, owner: str, repo: str, since_date: str) -> List[Dict[str, Any]]:\n        \"\"\"Fetches all commits from a repository since a given date.\"\"\"\n        commits_url = f\"https://api.github.com/repos/{owner}/{repo}/commits\"\n        params = {\"since\": since_date, \"per_page\": 100}\n        all_commits = []\n        page = 1\n\n        while True:\n            params['page'] = page\n            try:\n                response = requests.get(commits_url, headers=self.github_headers, params=params)\n                response.raise_for_status()\n                \n                data = response.json()\n                if not data:\n                    break\n                \n                all_commits.extend(data)\n                logger.debug(f\"Fetched {len(data)} commits from page {page}\")\n                page += 1\n            except requests.exceptions.RequestException as e:\n                logger.error(f\"Error fetching commits: {str(e)}\")\n                raise\n        \n        logger.info(f\"Total commits fetched: {len(all_commits)}\")\n        return all_commits\n\n    def _generate_changelog_prompt(self, commit_messages: str) -> str:\n        \"\"\"Creates the prompt for the OpenAI API.\"\"\"\n        return f\"\"\"\n        You are an expert technical writer specializing in software release notes.\n        Your task is to analyze the following raw commit messages from a GitHub repository\n        and generate a clean, well-structured, and human-readable changelog in Markdown format.\n\n        **Instructions:**\n        1.  **Categorize each meaningful commit** into one of the following sections:\n            - `ðŸš€ New Features`: For commits that introduce new functionality.\n            - `ðŸ› Bug Fixes`: For commits that fix bugs.\n            - `ðŸ”§ Maintenance & Refactoring`: For code cleanup, dependency updates, and internal improvements.\n            - `ðŸ“š Documentation`: For changes to READMEs, guides, or comments.\n        2.  **Summarize each commit message** into a concise, user-friendly list item.\n        3.  **Ignore trivial commits**, such as \"Merge branch '...'\", \"Update README.md\" (unless it's a significant doc change), or style fixes.\n        4.  **Format the output** as a Markdown document with a main title \"Changelog\" and the categorized sections as H2 headings.\n        5.  If no meaningful commits are found in a category, omit that section entirely.\n\n        **Raw Commit Messages:**\n        ---\n        {commit_messages}\n        ---\n        \"\"\"\n\n    def generate_changelog(self, repo_url: str, days_ago: int = 7) -> str:\n        \"\"\"\n        Generates a changelog for a given GitHub repository.\n\n        Args:\n            repo_url (str): The full URL of the GitHub repository.\n            days_ago (int, optional): How many days back to look for commits. Defaults to 7.\n\n        Returns:\n            str: A formatted Markdown string of the changelog.\n        \n        Raises:\n            ValueError: If the repository URL is invalid.\n            requests.exceptions.RequestException: If there's an issue with the GitHub API request.\n        \"\"\"\n        logger.info(f\"Generating changelog for {repo_url} (last {days_ago} days)\")\n        \n        repo_info = self._parse_repo_url(repo_url)\n        if not repo_info:\n            raise ValueError(\"Invalid GitHub repository URL provided.\")\n\n        since_date_dt = now() - timedelta(days=days_ago)\n        since_date_iso = since_date_dt.isoformat()\n\n        logger.info(f\"Fetching commits for {repo_info['owner']}/{repo_info['repo']} since {since_date_iso}\")\n        \n        try:\n            commits = self._fetch_commits(repo_info['owner'], repo_info['repo'], since_date_iso)\n            if not commits:\n                logger.warning(f\"No commits found in the last {days_ago} days\")\n                return f\"## Changelog\\n\\nNo new commits found in the last {days_ago} days.\"\n\n            commit_messages = \"\\n\".join([f\"- {c['commit']['message']}\" for c in commits])\n            \n            logger.info(\"Generating changelog with AI...\")\n            prompt = self._generate_changelog_prompt(commit_messages)\n            \n            try:\n                response = openai.chat.completions.create(\n                    model=\"gpt-4\",\n                    messages=[\n                        {\"role\": \"system\", \"content\": \"You are an expert technical writer.\"},\n                        {\"role\": \"user\", \"content\": prompt}\n                    ],\n                    temperature=0.2,\n                )\n                \n                changelog = response.choices[0].message.content\n                logger.info(\"Changelog generated successfully\")\n                return changelog.strip()\n            except openai.error.OpenAIError as e:\n                logger.error(f\"OpenAI API error: {str(e)}\")\n                raise RuntimeError(f\"Failed to generate changelog: {str(e)}\")\n\n        except requests.exceptions.HTTPError as e:\n            if e.response.status_code == 404:\n                logger.error(f\"Repository not found: {repo_url}\")\n                raise ValueError(\"Repository not found. Please check the URL.\")\n            else:\n                logger.error(f\"GitHub API error: {str(e)}\")\n                raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {str(e)}\")\n            raise RuntimeError(f\"An unexpected error occurred: {str(e)}\")\n\nif __name__ == '__main__':\n    # --- Keyholder: Replace with your actual data for testing ---\n    OPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\", \"YOUR_API_KEY_HERE\")\n    GITHUB_TOKEN = os.environ.get(\"GITHUB_TOKEN\") # Optional, but recommended\n    \n    # Example usage:\n    # repo_to_analyze = \"https://github.com/imndevmodeai/ResonantiA-v3\"\n    repo_to_analyze = \"https://github.com/facebook/react\"\n    \n    if OPENAI_API_KEY == \"YOUR_API_KEY_HERE\":\n        logger.error(\"OpenAI API key not set\")\n        print(\"ERROR: Please set your OpenAI API key in the script or as an environment variable.\")\n    else:\n        try:\n            scribe = LogScribe(api_key=OPENAI_API_KEY, github_token=GITHUB_TOKEN)\n            final_changelog = scribe.generate_changelog(repo_to_analyze, days_ago=7)\n            print(\"\\n--- Generated Changelog ---\")\n            print(final_changelog)\n        except (ValueError, RuntimeError, requests.exceptions.RequestException) as e:\n            logger.error(f\"Error during execution: {str(e)}\")\n            print(f\"\\nERROR: {e}\") \n```\n\nEXAMPLE APPLICATION:\nClass: LogScribe\n\nA class to generate human-readable changelogs from GitHub repository commits.\n\nMethods: __init__, _parse_repo_url, _fetch_commits, _generate_changelog_prompt, generate_changelog\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/logscribe_core.py; source_type: python_class"}