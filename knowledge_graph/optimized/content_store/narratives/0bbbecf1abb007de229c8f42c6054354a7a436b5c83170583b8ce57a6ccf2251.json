{"content": "TERM: Class: NexusInterface\n\nDEFINITION:\nCentral communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_interface.py, type: python_class\n\nFULL IMPLEMENTATION CODE (nexus_interface.py):\n```python\n\"\"\"\nNexusInterface: ArchE's Central Nervous System\n==============================================\n\nThe NexusInterface serves as ArchE's central communication bus, implementing\na publisher-subscriber pattern for asynchronous, decoupled communication\nbetween all system components.\n\nThis implementation provides:\n- Event publishing and subscription\n- Real-time message routing\n- ThoughtTrail integration\n- WebSocket support for external clients\n- Event filtering and routing\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport threading\nimport time\nfrom collections import defaultdict\nfrom datetime import datetime\n\n# ============================================================================\n# TEMPORAL CORE INTEGRATION (CANONICAL DATETIME SYSTEM)\n# ============================================================================\nfrom .temporal_core import now_iso, format_filename, format_log, Timer\nfrom typing import Dict, List, Any, Callable, Optional, Set\nimport websockets\nfrom websockets.server import WebSocketServerProtocol\n\nlogger = logging.getLogger(__name__)\n\nclass NexusInterface:\n    \"\"\"\n    Central communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n    \"\"\"\n    \n    def __init__(self, websocket_port: int = 8765):\n        \"\"\"\n        Initialize the NexusInterface.\n        \n        Args:\n            websocket_port: Port for WebSocket server\n        \"\"\"\n        self.subscribers = defaultdict(list)  # topic -> list of callbacks\n        self.event_history = []  # Store recent events for debugging\n        self.max_history = 1000\n        self.websocket_port = websocket_port\n        self.websocket_clients: Set[WebSocketServerProtocol] = set()\n        self._thoughttrail = None\n        self._running = False\n        self._lock = threading.Lock()\n        self._server_thread = None\n        self._loop = None\n        \n        logger.info(f\"NexusInterface initialized with WebSocket port {websocket_port}\")\n    \n    def publish(self, topic: str, data: Dict[str, Any]) -> None:\n        \"\"\"\n        Publish an event to a specific topic.\n        \n        Args:\n            topic: The topic/channel name\n            data: The event data to publish\n        \"\"\"\n        event = {\n            \"topic\": topic,\n            \"data\": data,\n            \"timestamp\": now_iso(),\n            \"event_id\": f\"{topic}_{int(time.time() * 1000)}\"\n        }\n        \n        with self._lock:\n            # Store in history\n            self.event_history.append(event)\n            if len(self.event_history) > self.max_history:\n                self.event_history.pop(0)\n            \n            # Notify subscribers\n            if topic in self.subscribers:\n                for callback in self.subscribers[topic]:\n                    try:\n                        callback(data)\n                    except Exception as e:\n                        logger.error(f\"Subscriber callback failed for topic {topic}: {e}\")\n        \n        # Broadcast to WebSocket clients\n        if self._loop:\n            asyncio.run_coroutine_threadsafe(self._broadcast_to_websockets(event), self._loop)\n        \n        logger.debug(f\"Published event to topic '{topic}': {event['event_id']}\")\n    \n    def subscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Subscribe to events from a specific topic.\n        \n        Args:\n            topic: The topic to subscribe to\n            callback: Function to call when events are published\n        \"\"\"\n        with self._lock:\n            self.subscribers[topic].append(callback)\n        \n        logger.info(f\"Subscribed to topic '{topic}'\")\n    \n    def unsubscribe(self, topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n        \"\"\"\n        Unsubscribe from a specific topic.\n        \n        Args:\n            topic: The topic to unsubscribe from\n            callback: The callback function to remove\n        \"\"\"\n        with self._lock:\n            if topic in self.subscribers:\n                try:\n                    self.subscribers[topic].remove(callback)\n                except ValueError:\n                    logger.warning(f\"Callback not found in subscribers for topic '{topic}'\")\n        \n        logger.info(f\"Unsubscribed from topic '{topic}'\")\n    \n    def inject_thoughttrail(self, thoughttrail_instance) -> None:\n        \"\"\"\n        Inject ThoughtTrail instance for bidirectional communication.\n        \n        Args:\n            thoughttrail_instance: The ThoughtTrail instance\n        \"\"\"\n        self._thoughttrail = thoughttrail_instance\n        thoughttrail_instance.inject_nexus(self)\n        logger.info(\"ThoughtTrail injected into NexusInterface\")\n    \n    def get_event_history(self, topic: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get recent event history.\n        \n        Args:\n            topic: Filter by topic (None for all topics)\n            limit: Maximum number of events to return\n            \n        Returns:\n            List of recent events\n        \"\"\"\n        with self._lock:\n            events = self.event_history[-limit:] if limit else self.event_history\n            \n            if topic:\n                events = [e for e in events if e[\"topic\"] == topic]\n            \n            return events\n    \n    def get_subscriber_count(self, topic: str) -> int:\n        \"\"\"\n        Get the number of subscribers for a topic.\n        \n        Args:\n            topic: The topic to check\n            \n        Returns:\n            Number of subscribers\n        \"\"\"\n        with self._lock:\n            return len(self.subscribers.get(topic, []))\n    \n    def get_topics(self) -> List[str]:\n        \"\"\"\n        Get all active topics.\n        \n        Returns:\n            List of topic names\n        \"\"\"\n        with self._lock:\n            return list(self.subscribers.keys())\n    \n    def start_server_in_thread(self):\n        \"\"\"Starts the WebSocket server in a separate thread.\"\"\"\n        if self._running:\n            logger.warning(\"WebSocket server is already running.\")\n            return\n\n        self._server_thread = threading.Thread(target=self._run_server, daemon=True)\n        self._server_thread.start()\n        logger.info(\"WebSocket server thread started.\")\n\n    def _run_server(self):\n        \"\"\"The target function for the server thread.\"\"\"\n        self._loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._loop)\n        self._loop.run_until_complete(self.start_websocket_server())\n\n    async def start_websocket_server(self) -> None:\n        \"\"\"Start the WebSocket server for external clients.\"\"\"\n        self._running = True\n        \n        async def handle_client(websocket: WebSocketServerProtocol, path: str):\n            self.websocket_clients.add(websocket)\n            logger.info(f\"WebSocket client connected: {websocket.remote_address}\")\n            \n            try:\n                # Send initial connection message\n                await websocket.send(json.dumps({\n                    \"type\": \"connection_established\",\n                    \"timestamp\": now_iso(),\n                    \"message\": \"Connected to ArchE Nexus\"\n                }))\n                \n                # Keep connection alive\n                async for message in websocket:\n                    await self._handle_websocket_message(websocket, message)\n                    \n            except websockets.exceptions.ConnectionClosed:\n                pass\n            finally:\n                self.websocket_clients.discard(websocket)\n                logger.info(f\"WebSocket client disconnected: {websocket.remote_address}\")\n        \n        async with websockets.serve(handle_client, \"localhost\", self.websocket_port) as server:\n            logger.info(f\"WebSocket server started on port {self.websocket_port}\")\n            self.server_instance = server\n            await asyncio.Future()  # Run forever\n    \n    async def _broadcast_to_websockets(self, event: Dict[str, Any]) -> None:\n        \"\"\"Broadcast event to all connected WebSocket clients.\"\"\"\n        if not self.websocket_clients:\n            return\n        \n        message = json.dumps({\n            \"type\": \"nexus_event\",\n            \"event\": event\n        })\n        \n        # Send to all clients concurrently\n        disconnected_clients = set()\n        for client in self.websocket_clients:\n            try:\n                await client.send(message)\n            except websockets.exceptions.ConnectionClosed:\n                disconnected_clients.add(client)\n            except Exception as e:\n                logger.error(f\"Failed to send to WebSocket client: {e}\")\n                disconnected_clients.add(client)\n        \n        # Remove disconnected clients\n        with self._lock:\n            self.websocket_clients -= disconnected_clients\n    \n    async def _handle_websocket_message(self, websocket: WebSocketServerProtocol, message: str) -> None:\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        try:\n            data = json.loads(message)\n            message_type = data.get(\"type\")\n            \n            if message_type == \"subscribe\":\n                # Client wants to subscribe to a topic\n                topic = data.get(\"topic\")\n                if topic:\n                    # Create a callback that sends to this specific client\n                    async def client_callback(event_data):\n                        try:\n                            await websocket.send(json.dumps({\n                                \"type\": \"topic_event\",\n                                \"topic\": topic,\n                                \"data\": event_data,\n                                \"timestamp\": now_iso()\n                            }))\n                        except websockets.exceptions.ConnectionClosed:\n                            pass\n                    \n                    self.subscribe(topic, client_callback)\n                    \n                    await websocket.send(json.dumps({\n                        \"type\": \"subscription_confirmed\",\n                        \"topic\": topic,\n                        \"timestamp\": now_iso()\n                    }))\n            \n            elif message_type == \"query_history\":\n                # Client wants event history\n                topic = data.get(\"topic\")\n                limit = data.get(\"limit\", 100)\n                history = self.get_event_history(topic, limit)\n                \n                await websocket.send(json.dumps({\n                    \"type\": \"history_response\",\n                    \"history\": history,\n                    \"timestamp\": now_iso()\n                }))\n            \n            elif message_type == \"get_topics\":\n                # Client wants list of active topics\n                topics = self.get_topics()\n                await websocket.send(json.dumps({\n                    \"type\": \"topics_response\",\n                    \"topics\": topics,\n                    \"timestamp\": now_iso()\n                }))\n            \n            else:\n                await websocket.send(json.dumps({\n                    \"type\": \"error\",\n                    \"message\": f\"Unknown message type: {message_type}\",\n                    \"timestamp\": now_iso()\n                }))\n                \n        except json.JSONDecodeError:\n            await websocket.send(json.dumps({\n                \"type\": \"error\",\n                \"message\": \"Invalid JSON\",\n                \"timestamp\": now_iso()\n            }))\n        except Exception as e:\n            logger.error(f\"Error handling WebSocket message: {e}\")\n            await websocket.send(json.dumps({\n                \"type\": \"error\",\n                \"message\": str(e),\n                \"timestamp\": now_iso()\n            }))\n    \n    def stop(self) -> None:\n        \"\"\"Stop the NexusInterface and its WebSocket server.\"\"\"\n        if not self._running:\n            return\n            \n        self._running = False\n        if self._loop:\n            self._loop.call_soon_threadsafe(self._loop.stop)\n        \n        if self._server_thread:\n            self._server_thread.join(timeout=5)\n\n        logger.info(\"NexusInterface and WebSocket server stopped\")\n\n# Global instance\nnexus_interface = NexusInterface()\n\n# Convenience functions\ndef publish_event(topic: str, data: Dict[str, Any]) -> None:\n    \"\"\"Publish an event to the global NexusInterface.\"\"\"\n    nexus_interface.publish(topic, data)\n\ndef subscribe_to_topic(topic: str, callback: Callable[[Dict[str, Any]], None]) -> None:\n    \"\"\"Subscribe to a topic on the global NexusInterface.\"\"\"\n    nexus_interface.subscribe(topic, callback)\n\ndef get_nexus() -> NexusInterface:\n    \"\"\"Get the global NexusInterface instance.\"\"\"\n    return nexus_interface\n\n__all__ = [\n    'NexusInterface',\n    'nexus_interface',\n    'publish_event',\n    'subscribe_to_topic',\n    'get_nexus'\n]\n\n\n```\n\nEXAMPLE APPLICATION:\nCentral communication hub for ArchE.\n    \n    Implements a publisher-subscriber pattern where components can:\n    - Publish events to specific topics\n    - Subscribe to events from specific topics\n    - Filter events based on criteria\n    - Connect external clients via WebSocket\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_interface.py; source_type: python_class"}