{"content": "TERM: Class: MockMastermind\n\nDEFINITION:\nClass: MockMastermind\n\n\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_server.py, type: python_class\n\nFULL IMPLEMENTATION CODE (nexus_server.py):\n```python\n\"\"\"\n==============================\nNexus Server (nexus_server.py)\n==============================\n\nAs Above: The Heart of the Oracle's Chamber\n--------------------------------------------\nThis server is the heart of the Nexus, the bridge between the chaotic, powerful forge of the Mastermind and the serene, public-facing Oracle's Chamber. It is not the mind itself, but the antechamber to the mind. It listens for petitions from the outside world, translates them into the language of the forge, carries them to the Mastermind, and then faithfully transmits the Mastermind's wisdom back to the world in a clear, coherent stream. It is the guardian of the threshold, ensuring that all communication is orderly, secure, and worthy of the Oracle.\n\nSo Below: The Operational Logic\n-------------------------------\nThis module implements a FastAPI application that serves as the backend for the Nexus Interface. It provides a secure REST API for command execution and a WebSocket endpoint for real-time, asynchronous communication of ArchE's cognitive stream. It is designed to be the primary gateway for all external interactions with the ArchE `MastermindServer`.\n\"\"\"\n\nimport asyncio\nimport logging\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom fastapi.responses import JSONResponse\nfrom typing import List, Dict, Any\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# --- Application Setup ---\napp = FastAPI(\n    title=\"ArchE Nexus Server\",\n    description=\"The API and real-time communication gateway to the ArchE Mastermind.\",\n    version=\"1.0.0\"\n)\n\n# --- Connection Management for WebSockets ---\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n\n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n        logger.info(f\"New client connected: {websocket.client}. Total clients: {len(self.active_connections)}\")\n\n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n        logger.info(f\"Client disconnected: {websocket.client}. Total clients: {len(self.active_connections)}\")\n\n    async def broadcast(self, message: Dict[str, Any]):\n        \"\"\"Broadcasts a message to all connected clients.\"\"\"\n        for connection in self.active_connections:\n            await connection.send_json(message)\n\nmanager = ConnectionManager()\n\n# --- ArchE Mastermind Integration ---\n# Attempt to import the real MastermindServer\ntry:\n    from .mastermind_server import MastermindServer\n    mastermind_instance = MastermindServer()\n    logger.info(\"✅ Successfully connected to the live ArchE MastermindServer.\")\nexcept ImportError as e:\n    logger.warning(f\"⚠️ Could not import MastermindServer ({e}). Falling back to MockMastermind.\")\n    # --- Placeholder for MastermindServer Integration ---\n    # In a real implementation, this would be the actual MastermindServer instance.\n    class MockMastermind:\n        async def process_command(self, command: str):\n            \"\"\"Simulates processing a command and yielding stream responses.\"\"\"\n            logger.info(f\"MockMastermind processing command: '{command}'\")\n            yield {\"type\": \"TEXT_RESPONSE\", \"payload\": f\"Acknowledged command: '{command}'. Beginning processing...\"}\n            await asyncio.sleep(2)\n            yield {\"type\": \"STATUS_UPDATE\", \"payload\": {\"task\": \"Analyzing data...\", \"progress\": 0.5}}\n            await asyncio.sleep(2)\n            yield {\"type\": \"TEXT_RESPONSE\", \"payload\": \"Analysis complete. Formulating response.\"}\n            await asyncio.sleep(1)\n            final_reflection = {\n                \"status\": \"success\",\n                \"summary\": \"The command was processed successfully by the mock mastermind.\",\n                \"confidence\": 0.99\n            }\n            yield {\"type\": \"COMMAND_COMPLETE\", \"payload\": {\"final_reflection\": final_reflection}}\n\n    mastermind_instance = MockMastermind()\n# ----------------------------------------------------\n\n\n# --- API Endpoints ---\n\n@app.get(\"/\", tags=[\"Status\"])\nasync def root():\n    \"\"\"Root endpoint to check if the server is running.\"\"\"\n    return {\"status\": \"ArchE Nexus Server is online.\"}\n\n@app.post(\"/api/v1/command\", tags=[\"Commands\"])\nasync def execute_command(command_request: Dict[str, str]):\n    \"\"\"\n    Receives a command and passes it to the Mastermind for processing.\n    The results will be streamed over the WebSocket connection.\n    \"\"\"\n    command = command_request.get(\"command\")\n    if not command:\n        return JSONResponse(status_code=400, content={\"error\": \"Command not provided.\"})\n\n    logger.info(f\"Received command via API: '{command}'\")\n    \n    # Asynchronously run the command processing\n    async def command_processor():\n        # This is a simplified integration. A real one would be more complex.\n        if isinstance(mastermind_instance, MockMastermind):\n             async for response in mastermind_instance.process_command(command):\n                await manager.broadcast(response)\n        else:\n            # TODO: Adapt the output of the real mastermind_instance to the streaming format.\n            # This requires a deeper integration with the IARCompliantWorkflowEngine's output.\n            await manager.broadcast({\"type\": \"TEXT_RESPONSE\", \"payload\": \"Command sent to live Mastermind. Real-time streaming pending full integration.\"})\n            # result = await mastermind_instance.engine.run_workflow_from_prompt(command)\n            # await manager.broadcast({\"type\": \"COMMAND_COMPLETE\", \"payload\": {\"final_reflection\": result.get('reflection')}})\n\n    asyncio.create_task(command_processor())\n\n    return {\"status\": \"Command received and is being processed asynchronously.\"}\n\n# --- WebSocket Endpoint ---\n\n@app.websocket(\"/ws/v1/stream\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    The main WebSocket endpoint for streaming real-time updates from ArchE.\n    \"\"\"\n    await manager.connect(websocket)\n    try:\n        # Send a welcome message\n        await websocket.send_json({\n            \"type\": \"SYSTEM_MESSAGE\",\n            \"payload\": \"Successfully connected to ArchE's cognitive stream.\"\n        })\n        # Keep the connection alive\n        while True:\n            await websocket.receive_text()\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n    except Exception as e:\n        logger.error(f\"An error occurred in the WebSocket connection: {e}\", exc_info=True)\n        manager.disconnect(websocket)\n\n# --- Server Startup Logic (for direct execution) ---\nif __name__ == \"__main__\":\n    import uvicorn\n    logger.info(\"Starting ArchE Nexus Server with Uvicorn...\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8888, log_level=\"info\")\n\n```\n\nEXAMPLE APPLICATION:\nClass: MockMastermind\n\n\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/nexus_server.py; source_type: python_class"}