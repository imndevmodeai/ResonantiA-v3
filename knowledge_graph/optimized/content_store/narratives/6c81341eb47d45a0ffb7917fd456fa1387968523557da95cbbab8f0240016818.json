{"content": "TERM: Class: WebSocketTimeoutWrapper\n\nDEFINITION:\nClass: WebSocketTimeoutWrapper\n\nWebSocket timeout wrapper for VCD Bridge compatibility\nHandles timeout parameter compatibility issues with different websockets library versions\n\nMethods: __init__\n\nBLUEPRINT DETAILS:\nExtracted from /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/websocket_timeout_wrapper.py, type: python_class\n\nFULL IMPLEMENTATION CODE (websocket_timeout_wrapper.py):\n```python\n#!/usr/bin/env python3\n\"\"\"\nWebSocket Timeout Wrapper - VCD Bridge Compatibility Fix\nProvides timeout-compatible WebSocket connection handling for VCD Bridge\n\"\"\"\n\nimport asyncio\nimport websockets\nimport logging\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\nclass WebSocketTimeoutWrapper:\n    \"\"\"\n    WebSocket timeout wrapper for VCD Bridge compatibility\n    Handles timeout parameter compatibility issues with different websockets library versions\n    \"\"\"\n    \n    def __init__(self, timeout: float = 5.0):\n        self.timeout = timeout\n        self.logger = logging.getLogger(f\"{__name__}.WebSocketTimeoutWrapper\")\n    \n    async def connect_with_timeout(self, uri: str, **kwargs) -> websockets.WebSocketServerProtocol:\n        \"\"\"\n        Connect to WebSocket with timeout handling\n        \n        Args:\n            uri: WebSocket URI\n            **kwargs: Additional connection parameters\n            \n        Returns:\n            WebSocket connection\n            \n        Raises:\n            ConnectionRefusedError: If connection is refused\n            asyncio.TimeoutError: If connection times out\n            Exception: For other connection errors\n        \"\"\"\n        try:\n            # Remove timeout from kwargs if present (for compatibility)\n            kwargs.pop('timeout', None)\n            \n            # Use asyncio.wait_for for timeout handling\n            connection = await asyncio.wait_for(\n                websockets.connect(uri, **kwargs),\n                timeout=self.timeout\n            )\n            \n            self.logger.info(f\"Successfully connected to {uri}\")\n            return connection\n            \n        except asyncio.TimeoutError:\n            self.logger.error(f\"Connection to {uri} timed out after {self.timeout}s\")\n            raise\n        except ConnectionRefusedError:\n            self.logger.error(f\"Connection to {uri} refused\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Connection to {uri} failed: {e}\")\n            raise\n    \n    async def send_with_timeout(self, websocket: websockets.WebSocketServerProtocol, \n                              message: str, timeout: Optional[float] = None) -> None:\n        \"\"\"\n        Send message with timeout handling\n        \n        Args:\n            websocket: WebSocket connection\n            message: Message to send\n            timeout: Optional timeout override\n        \"\"\"\n        timeout = timeout or self.timeout\n        \n        try:\n            await asyncio.wait_for(\n                websocket.send(message),\n                timeout=timeout\n            )\n            self.logger.debug(f\"Message sent successfully\")\n        except asyncio.TimeoutError:\n            self.logger.error(f\"Send operation timed out after {timeout}s\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Send operation failed: {e}\")\n            raise\n    \n    async def recv_with_timeout(self, websocket: websockets.WebSocketServerProtocol,\n                              timeout: Optional[float] = None) -> str:\n        \"\"\"\n        Receive message with timeout handling\n        \n        Args:\n            websocket: WebSocket connection\n            timeout: Optional timeout override\n            \n        Returns:\n            Received message\n        \"\"\"\n        timeout = timeout or self.timeout\n        \n        try:\n            message = await asyncio.wait_for(\n                websocket.recv(),\n                timeout=timeout\n            )\n            self.logger.debug(f\"Message received successfully\")\n            return message\n        except asyncio.TimeoutError:\n            self.logger.error(f\"Receive operation timed out after {timeout}s\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"Receive operation failed: {e}\")\n            raise\n\nasync def test_vcd_bridge_connection(uri: str = \"ws://localhost:8765\", \n                                   timeout: float = 5.0) -> Dict[str, Any]:\n    \"\"\"\n    Test VCD Bridge connection with timeout wrapper\n    \n    Args:\n        uri: WebSocket URI\n        timeout: Connection timeout\n        \n    Returns:\n        Connection test results\n    \"\"\"\n    wrapper = WebSocketTimeoutWrapper(timeout)\n    \n    try:\n        async with wrapper.connect_with_timeout(uri) as websocket:\n            # Send test message\n            test_message = {\n                \"type\": \"test_connection\",\n                \"timestamp\": datetime.now().isoformat(),\n                \"client\": \"websocket_timeout_wrapper\"\n            }\n            \n            import json\n            await wrapper.send_with_timeout(websocket, json.dumps(test_message))\n            \n            # Wait for response\n            response = await wrapper.recv_with_timeout(websocket)\n            data = json.loads(response)\n            \n            return {\n                \"status\": \"connected\",\n                \"response_received\": True,\n                \"response_data\": data,\n                \"timestamp\": datetime.now().isoformat()\n            }\n            \n    except asyncio.TimeoutError:\n        return {\n            \"status\": \"timeout\",\n            \"response_received\": False,\n            \"error\": f\"Connection timed out after {timeout}s\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n    except ConnectionRefusedError:\n        return {\n            \"status\": \"connection_refused\",\n            \"response_received\": False,\n            \"error\": \"Connection refused - VCD Bridge server not running\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n    except Exception as e:\n        return {\n            \"status\": \"error\",\n            \"response_received\": False,\n            \"error\": str(e),\n            \"timestamp\": datetime.now().isoformat()\n        }\n\n# Convenience function for VCD Analysis Agent\nasync def test_vcd_bridge_connection_simple() -> Dict[str, Any]:\n    \"\"\"Simple VCD Bridge connection test for VCD Analysis Agent\"\"\"\n    return await test_vcd_bridge_connection()\n\nif __name__ == \"__main__\":\n    # Test the wrapper\n    import asyncio\n    \n    async def main():\n        print(\"Testing WebSocket Timeout Wrapper...\")\n        result = await test_vcd_bridge_connection()\n        print(f\"Test result: {result}\")\n    \n    asyncio.run(main())\n\n\n\n\n\n\n\n\n```\n\nEXAMPLE APPLICATION:\nClass: WebSocketTimeoutWrapper\n\nWebSocket timeout wrapper for VCD Bridge compatibility\nHandles timeout parameter compatibility issues with different websockets library versions\n\nMethods: __init__\n\nCATEGORY: CodeKnowledge\n\nRELATIONSHIPS:\ntype: FromCodebase; source: /mnt/3626C55326C514B1/Happier/Three_PointO_ArchE/websocket_timeout_wrapper.py; source_type: python_class"}