{"content": "TERM: Mesa\n\nDEFINITION:\nA Python framework for agent-based modeling that enables the simulation of complex systems through individual agent behaviors and interactions. It provides tools for creating, running, and analyzing agent-based models.\n\nBLUEPRINT DETAILS:\nMesa framework integration in Three_PointO_ArchE/agent_based_modeling_tool.py with ScalableAgentModel and BasicGridModel classes using Mesa for agent-based simulation.\n\nIMPLEMENTATION CODE (agent_based_modeling_tool.py) - First 30KB:\n```python\n# ResonantiA Protocol v3.0 - agent_based_modeling_tool.py\n# Implements Agent-Based Modeling (ABM) capabilities using Mesa (if available).\n# Includes enhanced temporal analysis of results and mandatory IAR output.\n\nimport os\nimport json\nimport logging\nimport numpy as np\nimport pandas as pd\nimport time\nimport uuid # For unique filenames/run IDs\nfrom typing import Dict, Any, List, Optional, Union, Tuple, Callable, Type # Expanded type hints\n# Use relative imports for configuration\ntry:\n    from . import config\nexcept ImportError:\n    # Fallback config if running standalone or package structure differs\n    class FallbackConfig: OUTPUT_DIR = 'outputs'; ABM_VISUALIZATION_ENABLED = True; ABM_DEFAULT_ANALYSIS_TYPE='basic'; MODEL_SAVE_DIR='outputs/models' # Added model save dir\n    config = FallbackConfig(); logging.warning(\"config.py not found for abm tool, using fallback configuration.\")\n\n# --- Import ScalableAgent ---\ntry:\n    from .scalable_framework import ScalableAgent\n    SCALABLE_AGENT_AVAILABLE = True\nexcept ImportError:\n    ScalableAgent = None\n    SCALABLE_AGENT_AVAILABLE = False\n    logging.getLogger(__name__).warning(\"scalable_framework.py not found. The 'scalable_agent' model type will not be available.\")\n\n\n# --- Import Mesa and Visualization Libraries (Set flag based on success) ---\nMESA_AVAILABLE = False\nVISUALIZATION_LIBS_AVAILABLE = False\nSCIPY_AVAILABLE = False # For advanced pattern analysis\ntry:\n    import mesa\n    from mesa import Agent, Model\n    # from mesa.scheduler import RandomActivation, SimultaneousActivation, StagedActivation # Removed these unused imports\n    from mesa.space import MultiGrid, NetworkGrid\n    from mesa.datacollection import DataCollector\n    MESA_AVAILABLE = True\n    logger_abm_imp = logging.getLogger(__name__)\n    logger_abm_imp.info(\"Mesa library loaded successfully for ABM.\")\n    try:\n        import matplotlib.pyplot as plt\n        # import networkx as nx # Import if network models/analysis are used\n        VISUALIZATION_LIBS_AVAILABLE = True\n        logger_abm_imp.info(\"Matplotlib/NetworkX library loaded successfully for ABM visualization.\")\n    except ImportError:\n        plt = None; nx = None\n        logger_abm_imp.warning(\"Matplotlib/NetworkX not found. ABM visualization will be disabled.\")\n    try:\n        from scipy import ndimage # For pattern detection example\n        SCIPY_AVAILABLE = True\n        logger_abm_imp.info(\"SciPy library loaded successfully for ABM analysis.\")\n    except ImportError:\n        ndimage = None\n        logger_abm_imp.warning(\"SciPy not found. Advanced ABM pattern analysis will be disabled.\")\n\nexcept ImportError as e_mesa:\n    # Define dummy classes if Mesa is not installed\n    mesa = None; Agent = object; Model = object\n    # RandomActivation = object; SimultaneousActivation = object; StagedActivation = object # Removed dummy objects\n    MultiGrid = object; NetworkGrid = object; DataCollector = object; plt = None; nx = None; ndimage = None\n    logging.getLogger(__name__).warning(f\"Mesa library import failed: {e_mesa}. ABM Tool will run in SIMULATION MODE.\")\nexcept Exception as e_mesa_other:\n    mesa = None; Agent = object; Model = object\n    # RandomActivation = object; SimultaneousActivation = object; StagedActivation = object # Removed dummy objects\n    MultiGrid = object; NetworkGrid = object; DataCollector = object; plt = None; nx = None; ndimage = None\n    logging.getLogger(__name__).error(f\"Unexpected error importing Mesa/visualization libs: {e_mesa_other}. ABM Tool simulating.\")\n\n\nlogger = logging.getLogger(__name__) # Logger for this module\n\n# --- IAR Helper Function ---\n# Use the canonical, centralized reflection utility from reflection_utils\nfrom .utils.reflection_utils import create_reflection, ExecutionStatus\nfrom .thought_trail import log_to_thought_trail\n\n# --- Default Agent and Model Implementations ---\n# (Provide basic examples that can be overridden or extended)\ndef _create_reflection(status: str, summary: str, confidence: Optional[float], alignment: Optional[str], issues: Optional[List[str]], preview: Any) -> Dict[str, Any]:\n    \"\"\"Helper function to create the standardized IAR reflection dictionary.\"\"\"\n    if confidence is not None: confidence = max(0.0, min(1.0, confidence))\n    issues_list = issues if issues else None\n    try:\n        preview_str = str(preview) if preview is not None else None\n        if preview_str and len(preview_str) > 150: preview_str = preview_str[:150] + \"...\"\n    except Exception: preview_str = \"[Preview Error]\"\n    return {\"status\": status, \"summary\": summary, \"confidence\": confidence, \"alignment_check\": alignment if alignment else \"N/A\", \"potential_issues\": issues_list, \"raw_output_preview\": preview_str}\n\n# --- Default Agent and Model Implementations ---\n# (Provide basic examples that can be overridden or extended)\nclass BasicGridAgent(Agent if MESA_AVAILABLE else object):\n    \"\"\" A simple agent for grid-based models with a binary state. \"\"\"\n    def __init__(self, model, state=0, **kwargs):\n        if not MESA_AVAILABLE: # Simulation mode init\n            self.model = model; self.pos = None\n            self.state = state; self.next_state = state; self.params = kwargs\n            return\n        # Mesa init\n        super().__init__(model)\n        # Mesa auto-assigns a unique_id via AgentSet; store for convenience\n        self.unique_id = getattr(self, 'unique_id', None)\n        self.state = int(state) # Ensure state is integer\n        self.next_state = self.state\n        self.params = kwargs # Store any extra parameters\n\n    @log_to_thought_trail\n    def step(self):\n        \"\"\" Defines agent behavior within a simulation step. \"\"\"\n        if not MESA_AVAILABLE or not hasattr(self.model, 'grid') or self.model.grid is None or self.pos is None:\n            # Handle simulation mode or cases where grid/pos is not set\n            self.next_state = self.state\n            return\n        try:\n            # Example logic: Activate if enough neighbors are active\n            neighbors = self.model.grid.get_neighbors(self.pos, moore=True, include_center=False)\n            active_neighbors = sum(1 for a in neighbors if hasattr(a, 'state') and a.state > 0)\n            # Use activation_threshold from the model if available, else default\n            threshold = getattr(self.model, 'activation_threshold', 2)\n\n            # Determine next state based on logic\n            if self.state == 0 and active_neighbors >= threshold:\n                self.next_state = 1\n            elif self.state == 1 and active_neighbors < threshold -1 : # Example deactivation\n                self.next_state = 0\n            else:\n                self.next_state = self.state # Maintain current state otherwise\n\n        except Exception as e_agent_step:\n            logger.error(f\"Error in agent {self.unique_id} step at pos {self.pos}: {e_agent_step}\", exc_info=True)\n            self.next_state = self.state # Default to current state on error\n\n    @log_to_thought_trail\n    def advance(self):\n        \"\"\" Updates the agent's state based on the calculated next_state. \"\"\"\n        # Check if next_state was calculated and differs from current state\n        if hasattr(self, 'next_state') and self.state != self.next_state:\n            self.state = self.next_state\n\nclass ScalableAgentModel(Model if MESA_AVAILABLE else object):\n    \"\"\"\n    A Mesa model designed to run a simulation with multiple ScalableAgents.\n    \"\"\"\n    def __init__(self, num_agents=10, agent_params: dict = None, **model_params):\n        if not MESA_AVAILABLE or not SCALABLE_AGENT_AVAILABLE:\n            self.run_id = uuid.uuid4().hex[:8]\n            logger.warning(f\"SIMULATING ScalableAgentModel (Run ID: {self.run_id}) as Mesa or ScalableAgent is not available.\")\n            return\n\n        super().__init__()\n        self.run_id = uuid.uuid4().hex[:8]\n        self.num_agents = num_agents\n        agent_params = agent_params or {}\n\n        # Create agents\n        for i in range(self.num_agents):\n            # Create a unique initial state and operators for each agent\n            # This is a placeholder; real scenarios would have more complex setup\n            initial_state = agent_params.get('initial_state', np.random.rand(2))\n            operators = agent_params.get('operators', {'default': np.eye(2)})\n            \n            agent = ScalableAgent(\n                agent_id=f\"scalable_{i}\",\n                initial_state=initial_state,\n                operators=operators,\n                action_registry=agent_params.get('action_registry', {}),\n                workflow_modes=agent_params.get('workflow_modes', {}),\n                operator_selection_strategy=agent_params.get('operator_selection_strategy', lambda a: next(iter(a.operators)))\n            )\n            self.schedule.add(agent)\n\n        self.datacollector = DataCollector(\n            agent_reporters={\"State\": \"current_state\", \"Entropy\": \"current_entropy\"}\n        )\n\n    @log_to_thought_trail\n    def step(self):\n        \"\"\"Advance the model by one step.\"\"\"\n        self.schedule.step()\n        self.datacollector.collect(self)\n\nclass BasicGridModel(Model if MESA_AVAILABLE else object):\n    \"\"\" A simple grid-based model using BasicGridAgent. \"\"\"\n    def __init__(self, width=10, height=10, density=0.5, activation_threshold=2, agent_class: Type[Agent] = BasicGridAgent, scheduler_type='random', torus=True, seed=None, **model_params):\n        self._step_count = 0\n        self.run_id = uuid.uuid4().hex[:8] # Assign a unique ID for this model run\n        self._scheduler_type = scheduler_type.lower() # Store for use in step()\n\n        if not MESA_AVAILABLE: # Simulation mode init\n            self.random = np.random.RandomState(seed if seed is not None else int(time.time()))\n            self.width = width; self.height = height; self.density = density; self.activation_threshold = activation_threshold; self.num_agents = 0\n            self.agent_class = agent_class; self.custom_agent_params = model_params.get('agent_params', {})\n            self.model_params = model_params; self.grid = None; \n            self.agents_sim = [] # Use a list for simulated agents\n            self._create_agents_sim()\n            self.num_agents = len(self.agents_sim)\n            logger.info(f\"Initialized SIMULATED BasicGridModel (Run ID: {self.run_id})\")\n            return\n        \n        # Mesa init\n        super().__init__(seed=seed) # Pass seed to Mesa's base Model for reproducibility\n        self.width = int(width); self.height = int(height); self.density = float(density); self.activation_threshold = int(activation_threshold)\n        self.num_agents = 0 # Will be updated after agent creation\n        self.agent_class = agent_class if issubclass(agent_class, Agent) else BasicGridAgent\n        self.custom_agent_params = model_params.pop('agent_params', {}) # Extract agent params\n        self.model_params = model_params # Store remaining model-level params\n\n        # Setup grid\n        self.grid = MultiGrid(self.width, self.height, torus=torus)\n        \n        # Note: In Mesa 3.0+, explicit scheduler instantiation (RandomActivation, etc.)\n        # is replaced by AgentSet methods. The Model base class provides `self.agents` (an AgentSet).\n        # We store the intended scheduler_type to be used by the step() method.\n        if self._scheduler_type not in ['random', 'simultaneous', 'staged']:\n            logger.warning(f\"Unknown scheduler_type '{scheduler_type}'. Defaulting to 'random' behavior in step().\")\n            self._scheduler_type = 'random'\n\n        # Setup data collection\n        model_reporters = {\n            \"Active\": lambda m: self.count_active_agents(),\n            \"Inactive\": lambda m: self.count_inactive_agents()\n        }\n        agent_reporters = {\"State\": \"state\"}\n        self.datacollector = DataCollector(model_reporters=model_reporters, agent_reporters=agent_reporters)\n\n        # Create agents and place them. Agents are automatically added to self.agents (AgentSet)\n        self._create_agents_mesa() \n        self.num_agents = len(self.agents) # self.agents is the AgentSet from Mesa's Model base class\n\n        self.running = True\n        self.datacollector.collect(self)\n        logger.info(f\"Initialized Mesa BasicGridModel (Run ID: {self.run_id}) with {self.num_agents} agents using '{self._scheduler_type}' activation style.\")\n\n    def _create_agents_mesa(self):\n        \"\"\" Helper method to create agents for Mesa model. Agents are added to self.agents AgentSet. \"\"\"\n        agent_id_counter = 0 # unique_id is now auto-assigned by Mesa Model when adding to AgentSet\n        initial_active_count = 0\n        for x in range(self.width):\n            for y in range(self.height):\n                if self.random.random() < self.density:\n                    initial_state = 1 if self.random.random() < 0.1 else 0\n                    if initial_state == 1: initial_active_count += 1\n                    # Create agent instance; Mesa auto-assigns unique_id when only model is passed.\n                    agent = self.agent_class(self, state=initial_state, **self.custom_agent_params)\n                    # No need to explicitly call self.schedule.add(agent) or assign unique_id from counter\n                    # The Model base class handles adding the agent to self.agents.\n                    self.grid.place_agent(agent, (x, y))\n        # num_agents will be len(self.agents) after this method, set in __init__\n        logger.info(f\"Created agents for Mesa model. Initial active: {initial_active_count}. Total agents in AgentSet: {len(self.agents)}\")\n\n    def _create_agents_sim(self):\n        \"\"\" Helper method to create agents for simulation mode. \"\"\"\n        agent_id_counter = 0; initial_active_count = 0\n        self.agents_sim = [] # Ensure it's a list for simulation\n        for x in range(self.width):\n            for y in range(self.height):\n                if self.random.random() < self.density:\n                        initial_state = 1 if self.random.random() < 0.1 else 0\n                        if initial_state == 1: initial_active_count += 1\n                        # For simulation, manually assign unique_id and store in a list\n                        agent = self.agent_class(self, state=initial_state, **self.custom_agent_params); \n                        agent.unique_id = agent_id_counter # Explicit for sim\n                        agent_id_counter += 1\n                        agent.pos = (x, y); self.agents_sim.append(agent)\n        logger.info(f\"Created {len(self.agents_sim)} agents for SIMULATED model. Initial active: {initial_active_count}\")\n\n    @log_to_thought_trail\n    def step(self):\n        \"\"\" Advances the model by one step. \"\"\"\n        self._step_count += 1 # Mesa 3.0+ Model.steps auto-increments, but this can be model's internal counter\n        if MESA_AVAILABLE:\n            # Use AgentSet activation methods based on the stored scheduler type\n            if self._scheduler_type == 'random':\n                self.agents.shuffle_do(\"step\") # Executes step() and then advance() for each agent in random order\n                # In Mesa 3.0, shuffle_do typically handles both step and advance logic if agents define them.\n                # If BasicGridAgent only has `step` to determine `next_state` and `advance` to apply it, this is fine.\n                # For more complex agents that might have separate advance logic called by SimultaneousActivation, \n                # ensure shuffle_do covers it or adjust agent/model logic.\n                # The default Agent.step() in Mesa 3.0 is a placeholder. Our BasicGridAgent.step() calculates next_state.\n                # Our BasicGridAgent.advance() applies next_state. So, we need both.\n                # However, `shuffle_do` calls the method passed to it. If we need sequential step then advance, it's more complex.\n                # Let's assume for `BasicGridAgent`, `step` computes next_state and `advance` applies it.\n                # Mesa's `shuffle_do(\"step\")` calls `agent.step()`. Then `shuffle_do(\"advance\")` would call `agent.advance()`.\n                # For RandomActivation, the typical pattern is: each agent steps, then each agent advances.\n                # It seems `shuffle_do` is for a single method call per agent. \n                # If RandomActivation implies step then advance for *each agent individually* before the next agent steps, \n                # then shuffle_do(\"step\") might be enough if BasicGridAgent.step() calls self.advance() internally at the end.\n                # Our current BasicGridAgent does not do that. So we need two passes for RandomActivation style.\n                \n                # According to Mesa 3.0 migration for RandomActivation:\n                # Replace self.schedule.step() with self.agents.shuffle_do(\"step\")\n                # This implies shuffle_do(\"step\") should be enough if the agent's step method does all its work for the turn.\n                # Let's assume BasicGridAgent.step calculates next_state, and BasicGridAgent.advance applies it.\n                # For random activation, usually all agents compute their next state, then all agents apply it.\n                # So, it would be: self.agents.shuffle_do(\"step\") and then self.agents.shuffle_do(\"advance\")\n                self.agents.do(\"step\") # All agents determine their next_state\n                self.agents.do(\"advance\") # All agents apply their next_state (order for advance may not matter for BasicGridAgent)\n                                        # Using `do` instead of `shuffle_do` for advance as order might not be critical for advance phase here.\n\n            elif self._scheduler_type == 'simultaneous':\n                # All agents compute their next state based on the *current* state of others\n                self.agents.do(\"step\") \n                # Then all agents apply their new state simultaneously\n                self.agents.do(\"advance\")\n            elif self._scheduler_type == 'staged':\n                # Assuming stage_list is defined, e.g., [\"step\", \"advance\"] or custom stages\n                # For BasicGridAgent, the stages are effectively \"step\" (calculate) and \"advance\" (apply)\n                stage_list = [\"step\", \"advance\"] # Default for BasicGridAgent\n                # One could pass stage_list as a model parameter if models have more complex staging\n                for stage_method_name in stage_list:\n                    self.agents.do(stage_method_name)\n            else: # Fallback, should have been defaulted in __init__\n                logger.warning(f\"Undefined scheduler type '{self._scheduler_type}' in step(), defaulting to random-like activation.\")\n                self.agents.do(\"step\")\n                self.agents.do(\"advance\")\n\n            self.datacollector.collect(self)\n        else: # Simulate step for non-Mesa mode (simulation)\n            # Simulation logic for self.agents_sim\n            next_states = {}\n            for agent in self.agents_sim: \n                active_neighbors_sim = 0\n                if hasattr(agent, 'pos') and agent.pos is not None:\n                    for dx in [-1, 0, 1]:\n                            for dy in [-1, 0, 1]:\n                                if dx == 0 and dy == 0: continue\n                                nx, ny = agent.pos[0] + dx, agent.pos[1] + dy\n                                neighbor = next((a for a in self.agents_sim if hasattr(a,'pos') and a.pos == (nx, ny)), None)\n                                if neighbor and hasattr(neighbor, 'state') and neighbor.state > 0: active_neighbors_sim += 1\n                current_state = getattr(agent, 'state', 0)\n                # Using agent.params.get for activation_threshold if it was passed via agent_params to BasicGridAgent\n                # Otherwise, using model's activation_threshold for simulation consistency\n                sim_activation_threshold = agent.params.get('activation_threshold', self.activation_threshold)\n\n                if current_state == 0 and active_neighbors_sim >= sim_activation_threshold: \n                    next_states[agent.unique_id] = 1\n                # Example deactivation for simulation, matching BasicGridAgent logic roughly\n                elif current_state == 1 and active_neighbors_sim < sim_activation_threshold -1: \n                    next_states[agent.unique_id] = 0\n                else: \n                    next_states[agent.unique_id] = current_state\n            \n            for agent in self.agents_sim:\n                if agent.unique_id in next_states:\n                    setattr(agent, 'state', next_states[agent.unique_id])\n            logger.debug(f\"Simulated step {self._step_count} completed.\")\n\n    # Helper methods for data collection reporters\n    @log_to_thought_trail\n    def count_active_agents(self):\n        \"\"\" Counts agents with state > 0. \"\"\"\n        return sum(1 for agent in self.agents if hasattr(agent, 'state') and agent.state > 0) if MESA_AVAILABLE else sum(1 for agent in self.agents_sim if hasattr(agent, 'state') and agent.state > 0)\n    @log_to_thought_trail\n    def count_inactive_agents(self):\n        \"\"\" Counts agents with state <= 0. \"\"\"\n        return sum(1 for agent in self.agents if hasattr(agent, 'state') and agent.state <= 0) if MESA_AVAILABLE else sum(1 for agent in self.agents_sim if hasattr(agent, 'state') and agent.state <= 0)\n\n    @log_to_thought_trail\n    def get_agent_states(self) -> np.ndarray:\n        \"\"\" Returns a 2D NumPy array representing the state of each agent on the grid. \"\"\"\n        states = np.full((self.width, self.height), -1.0)\n        agent_list_to_iterate = self.agents if MESA_AVAILABLE else self.agents_sim\n        if not agent_list_to_iterate: return states\n\n        for agent in agent_list_to_iterate:\n            # Check if agent has position and state attributes\n            if hasattr(agent, 'pos') and agent.pos is not None and hasattr(agent, 'state'):\n                try:\n                    x, y = agent.pos\n                    # Ensure position is within grid bounds before assignment\n                    if 0 <= x < self.width and 0 <= y < self.height:\n                            states[int(x), int(y)] = float(agent.state) # Use float for potential non-integer states\n                    else:\n                            logger.warning(f\"Agent {getattr(agent,'unique_id','N/A')} has out-of-bounds position {agent.pos}. Skipping state assignment.\")\n                except (TypeError, IndexError) as pos_err:\n                    logger.warning(f\"Agent {getattr(agent,'unique_id','N/A')} position error during state retrieval: {pos_err}\")\n            # else: logger.debug(f\"Agent {getattr(agent,'unique_id','N/A')} missing pos or state attribute.\") # Optional debug\n        return states\n\n# --- ABM Tool Class (Handles Operations & IAR) ---\nclass ABMTool:\n    \"\"\"\n    [IAR Enabled] Provides interface for creating, running, and analyzing\n    Agent-Based Models using Mesa (if available) or simulation. Includes temporal analysis. (v3.0)\n    \"\"\"\n    def __init__(self):\n        self.is_available = MESA_AVAILABLE # Flag indicating if Mesa library loaded\n        logger.info(f\"ABM Tool (v3.0) initialized (Mesa Available: {self.is_available})\")\n\n    @log_to_thought_trail\n    def create_model(self, model_type: str = \"basic\", agent_class: Optional[Type[Agent]] = None, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Creates an ABM model instance based on specified type and parameters.\n        Returns a dictionary containing the model instance and reflection.\n        \"\"\"\n        model_type = model_type.lower()\n        logger.info(f\"Attempting to create ABM model of type: '{model_type}'\")\n        # IAR setup\n        reflection = _create_reflection(\"Failure\", f\"Model creation failed for type '{model_type}'.\", 0.0, \"N/A\", [\"Initialization error.\"], None)\n        model = None\n        \n        try:\n            if model_type == \"basic\":\n                # For BasicGridModel, we expect grid dimensions and density\n                width = kwargs.get('width', 10)\n                height = kwargs.get('height', 10)\n                density = kwargs.get('density', 0.5)\n                model = BasicGridModel(width=width, height=height, density=density, agent_class=agent_class or BasicGridAgent, **kwargs)\n\n            elif model_type == \"scalable_agent\":\n                if not SCALABLE_AGENT_AVAILABLE:\n                    raise ImportError(\"ScalableAgent framework is not available. Cannot create 'scalable_agent' model.\")\n                \n                num_agents = kwargs.get('num_agents', 10)\n                agent_params = kwargs.get('agent_params', {}) # Pass complex agent params here\n                model = ScalableAgentModel(num_agents=num_agents, agent_params=agent_params, **kwargs)\n\n            elif model_type == \"combat\":\n                from .combat_abm import GorillaCombatModel\n                num_humans = kwargs.get('num_humans', 30)\n                width = kwargs.get('width', 20)\n                height = kwargs.get('height', 20)\n                seed = kwargs.get('seed', None)\n                model = GorillaCombatModel(width=width, height=height, num_humans=num_humans, seed=seed)\n\n            elif model_type == \"generic_dsl\":\n                from .abm_dsl_engine import create_model_from_schema\n                schema = kwargs.get('schema') or kwargs.get('dsl_schema')\n                if schema is None and 'model_params' in kwargs:\n                    schema = kwargs['model_params'].get('schema') or kwargs['model_params'].get('dsl_schema')\n                if schema is None:\n                    raise ValueError(\"Missing 'schema' parameter for generic_dsl model.\")\n                if isinstance(schema, str):\n                    try:\n                        schema = json.loads(schema)\n                    except Exception:\n                        raise ValueError(\"Schema string for generic_dsl could not be parsed as JSON.\")\n                seed = kwargs.get('seed', None)\n                model = create_model_from_schema(schema, seed=seed)\n\n            # ... (potential for other model types like \"network\")\n            else:\n                raise ValueError(f\"Unknown model_type '{model_type}'. Supported types: 'basic', 'scalable_agent', 'combat', 'generic_dsl'.\")\n\n            if model:\n                reflection = _create_reflection(\n                    \"Success\", f\"Successfully created ABM model '{model_type}' (Run ID: {getattr(model, 'run_id', 'N/A')}).\",\n                    0.95, \"Model instantiated as per specification.\", None,\n                    f\"Model: {model.__class__.__name__}, Agents: {getattr(model, 'num_agents', 'N/A')}\"\n                )\n        except Exception as e_create:\n            logger.error(f\"Error creating ABM model '{model_type}': {e_create}\", exc_info=True)\n            reflection = _create_reflection(\"Failure\", f\"Model creation failed: {e_create}\", 0.0, \"N/A\", [f\"Model creation error: {e_create}\"], None)\n\n        return {\n            \"model\": model, \"type\": model_type,\n                \"dimensions\": [getattr(model,'width',None), getattr(model,'height',None)] if hasattr(model,'grid') and isinstance(model.grid, MultiGrid) else None,\n                \"agent_count\": getattr(model,'num_agents',0),\n            \"params\": {**getattr(model,'model_params',{}), \"scheduler\": getattr(model, 'scheduler_type', 'random'), \"seed\": getattr(model, 'seed', None), \"torus\": getattr(model, 'torus', True)},\n            \"agent_params_used\": getattr(model,'custom_agent_params',{}),\n            \"reflection\": reflection\n        }\n\n    @log_to_thought_trail\n    def run_simulation(self, model: Any, steps: int = 100, visualize: bool = False, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        [IAR Enabled] Runs the simulation for a given model instance for a number of steps.\n\n        Args:\n            model: The initialized Mesa Model instance (or simulated config dict).\n            steps (int): The number of steps to run the simulation.\n            visualize (bool): If True, attempt to generate and save a visualization.\n            **kwargs: Additional arguments (currently unused, for future expansion).\n\n        Returns:\n            Dict containing simulation results (data, final state), optional visualization path, and IAR reflection.\n        \"\"\"\n        # --- Initialize Results & Reflection ---\n        primary_result = {\"error\": None, \"simulation_steps_run\": 0, \"note\": \"\"}\n        reflection_status = \"Failure\"; reflection_summary = \"Simulation initialization failed.\"; reflection_confidence = 0.0; reflection_alignment = \"N/A\"; reflection_issues = []; reflection_preview = None\n\n        # --- Simulation Mode ---\n        if not self.is_available:\n            # Check if input is a simulated model config\n            if isinstance(model, dict) and model.get(\"simulated\"):\n                primary_result[\"note\"] = \"SIMULATED results - Mesa library not available\"\n                logger.warning(f\"Simulating ABM run for {steps} steps (Mesa unavailable).\")\n                sim_result = self._simulate_model_run(steps, visualize, model.get(\"width\", 10), model.get(\"height\", 10))\n                primary_result.update(sim_result)\n                primary_result[\"error\"] = sim_result.get(\"error\")\n                if primary_result[\"error\"]: reflection_issues = [primary_result[\"error\"]]\n                else: reflection_status = \"Success\"; reflection_summary = f\"Simulated ABM run for {steps} steps completed.\"; reflection_confidence = 0.6; reflection_alignment = \"Aligned with simulation goal (simulated).\"; reflection_issues = [\"Results are simulated.\"]; reflection_preview = {\"steps\": steps, \"final_active\": primary_result.get(\"active_count\")}\n                return {**primary_result, \"reflection\": _create_reflection(reflection_status, reflection_summary, reflection_confidence, reflection_alignment, reflection_issues, reflection_preview)}\n            else:\n                # Input is not a valid simulated model dict\n                primary_result[\"error\"] = \"Mesa not available and input 'model' is ...\n```\n\nEXAMPLE APPLICATION:\nMesa enables the AgentbasedmodelinG tool to simulate market dynamics through individual trader agents, revealing how simple rules can lead to complex emergent patterns like market bubbles and crashes.\n\nCATEGORY: ExternalLibrary\n\nRELATIONSHIPS:\ntype: AgentBasedModelingFramework; enables: Agent-Based Modeling, Complex System Simulation, Emergence Analysis; used_by: AgentbasedmodelinG, Complex System Visioning, Temporal Analysis; provides: Agent Classes, Model Framework, Data Collection; confidence: high"}