[
  {
    "path": "Three_PointO_ArchE/action_context.py",
    "name": "action_context.py",
    "size_bytes": 1070,
    "classes": [
      {
        "name": "ActionContext",
        "docstring": "Contextual information passed to an action during execution.",
        "methods": [
          {
            "name": "__post_init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 26
          }
        ],
        "line_number": 7
      }
    ],
    "functions": [
      {
        "name": "__post_init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 26
      }
    ],
    "imports": [
      "dataclasses",
      "typing",
      "datetime"
    ],
    "docstring": null,
    "has_docstring": false,
    "line_count": 28
  },
  {
    "path": "Three_PointO_ArchE/iar_components.py",
    "name": "iar_components.py",
    "size_bytes": 10888,
    "classes": [
      {
        "name": "IARValidationResult",
        "docstring": "Result of IAR validation.",
        "methods": [],
        "line_number": 22
      },
      {
        "name": "IAR_Prepper",
        "docstring": "A helper class to prepare standardized IAR dictionaries.",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initializes the IAR_Prepper.\n\nArgs:\n    action_name (str): The name of the action being performed.\n    action_inputs (Dict[str, Any]): The inputs provided to the action.",
            "args": [
              "self",
              "action_name",
              "action_inputs"
            ],
            "line_number": 31
          },
          {
            "name": "_get_common_fields",
            "docstring": "Returns fields common to all IAR responses.",
            "args": [
              "self"
            ],
            "line_number": 43
          },
          {
            "name": "finish_with_success",
            "docstring": "Formats a successful IAR response.",
            "args": [
              "self",
              "result",
              "confidence",
              "summary"
            ],
            "line_number": 54
          },
          {
            "name": "finish_with_error",
            "docstring": "Formats a failed IAR response.",
            "args": [
              "self",
              "error_message",
              "confidence"
            ],
            "line_number": 76
          },
          {
            "name": "finish_with_skip",
            "docstring": "Formats a skipped IAR response.",
            "args": [
              "self",
              "reason"
            ],
            "line_number": 97
          }
        ],
        "line_number": 29
      },
      {
        "name": "IARValidator",
        "docstring": "Validates IAR (Integrated Action Reflection) data structure and content.",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 114
          },
          {
            "name": "validate_structure",
            "docstring": "Validate the structure of IAR data.\n\nArgs:\n    iar_data: The IAR data to validate\n    \nReturns:\n    Tuple of (is_valid, issues)",
            "args": [
              "self",
              "iar_data"
            ],
            "line_number": 123
          },
          {
            "name": "validate_content",
            "docstring": "Validate the content of IAR data in context.\n\nArgs:\n    iar_data: The IAR data to validate\n    context: The execution context\n    \nReturns:\n    IARValidationResult containing validation details",
            "args": [
              "self",
              "iar_data",
              "context"
            ],
            "line_number": 162
          },
          {
            "name": "_calculate_resonance",
            "docstring": "Calculate the resonance score for IAR data.",
            "args": [
              "self",
              "iar_data",
              "context"
            ],
            "line_number": 188
          }
        ],
        "line_number": 111
      },
      {
        "name": "ResonanceTracker",
        "docstring": "Tracks resonance across workflow execution.",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 210
          },
          {
            "name": "record_execution",
            "docstring": "Record execution with IAR data.\n\nArgs:\n    task_id: The task identifier\n    iar_data: The IAR data\n    context: The execution context",
            "args": [
              "self",
              "task_id",
              "iar_data",
              "context"
            ],
            "line_number": 214
          },
          {
            "name": "get_resonance_trend",
            "docstring": "Get the resonance trend over recent executions.\n\nArgs:\n    window_size: Number of recent executions to consider\n    \nReturns:\n    List of resonance scores",
            "args": [
              "self",
              "window_size"
            ],
            "line_number": 234
          },
          {
            "name": "detect_resonance_issues",
            "docstring": "Detect potential resonance issues in recent executions.\n\nReturns:\n    List of issues with details",
            "args": [
              "self"
            ],
            "line_number": 250
          },
          {
            "name": "get_execution_summary",
            "docstring": "Get a summary of execution history.\n\nReturns:\n    Dictionary containing execution summary",
            "args": [
              "self"
            ],
            "line_number": 285
          }
        ],
        "line_number": 207
      }
    ],
    "functions": [
      {
        "name": "__init__",
        "docstring": "Initializes the IAR_Prepper.\n\nArgs:\n    action_name (str): The name of the action being performed.\n    action_inputs (Dict[str, Any]): The inputs provided to the action.",
        "args": [
          "self",
          "action_name",
          "action_inputs"
        ],
        "line_number": 31
      },
      {
        "name": "_get_common_fields",
        "docstring": "Returns fields common to all IAR responses.",
        "args": [
          "self"
        ],
        "line_number": 43
      },
      {
        "name": "finish_with_success",
        "docstring": "Formats a successful IAR response.",
        "args": [
          "self",
          "result",
          "confidence",
          "summary"
        ],
        "line_number": 54
      },
      {
        "name": "finish_with_error",
        "docstring": "Formats a failed IAR response.",
        "args": [
          "self",
          "error_message",
          "confidence"
        ],
        "line_number": 76
      },
      {
        "name": "finish_with_skip",
        "docstring": "Formats a skipped IAR response.",
        "args": [
          "self",
          "reason"
        ],
        "line_number": 97
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 114
      },
      {
        "name": "validate_structure",
        "docstring": "Validate the structure of IAR data.\n\nArgs:\n    iar_data: The IAR data to validate\n    \nReturns:\n    Tuple of (is_valid, issues)",
        "args": [
          "self",
          "iar_data"
        ],
        "line_number": 123
      },
      {
        "name": "validate_content",
        "docstring": "Validate the content of IAR data in context.\n\nArgs:\n    iar_data: The IAR data to validate\n    context: The execution context\n    \nReturns:\n    IARValidationResult containing validation details",
        "args": [
          "self",
          "iar_data",
          "context"
        ],
        "line_number": 162
      },
      {
        "name": "_calculate_resonance",
        "docstring": "Calculate the resonance score for IAR data.",
        "args": [
          "self",
          "iar_data",
          "context"
        ],
        "line_number": 188
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 210
      },
      {
        "name": "record_execution",
        "docstring": "Record execution with IAR data.\n\nArgs:\n    task_id: The task identifier\n    iar_data: The IAR data\n    context: The execution context",
        "args": [
          "self",
          "task_id",
          "iar_data",
          "context"
        ],
        "line_number": 214
      },
      {
        "name": "get_resonance_trend",
        "docstring": "Get the resonance trend over recent executions.\n\nArgs:\n    window_size: Number of recent executions to consider\n    \nReturns:\n    List of resonance scores",
        "args": [
          "self",
          "window_size"
        ],
        "line_number": 234
      },
      {
        "name": "detect_resonance_issues",
        "docstring": "Detect potential resonance issues in recent executions.\n\nReturns:\n    List of issues with details",
        "args": [
          "self"
        ],
        "line_number": 250
      },
      {
        "name": "get_execution_summary",
        "docstring": "Get a summary of execution history.\n\nReturns:\n    Dictionary containing execution summary",
        "args": [
          "self"
        ],
        "line_number": 285
      }
    ],
    "imports": [
      "typing",
      "datetime",
      "temporal_core",
      "numpy",
      "dataclasses",
      "typing",
      "Three_PointO_ArchE.temporal_core"
    ],
    "docstring": "IAR Components - IAR validation and resonance tracking for workflow execution",
    "has_docstring": true,
    "line_count": 306
  },
  {
    "path": "Three_PointO_ArchE/rise_orchestrator.py",
    "name": "rise_orchestrator.py",
    "size_bytes": 58952,
    "classes": [
      {
        "name": "RISEState",
        "docstring": "Represents the state of a RISE workflow execution",
        "methods": [
          {
            "name": "to_dict",
            "docstring": "Convert state to dictionary for serialization",
            "args": [
              "self"
            ],
            "line_number": 88
          }
        ],
        "line_number": 66
      },
      {
        "name": "RISE_Orchestrator",
        "docstring": "Master controller for the RISE v2.0 workflow.\n\nThis orchestrator manages the three-phase process:\n1. Knowledge Scaffolding & Dynamic Specialization (Phase A)\n2. Fused Insight Generation (Phase B) \n3. Fused Strategy Generation & Finalization (Phase C)\n\nIt coordinates the Metamorphosis Protocol for creating specialized expert clones\nand implements HighStakesVetting for rigorous strategy validation.\n\nENHANCED WITH SYNERGISTIC FUSION PROTOCOL:\nThe orchestrator now includes the ability to activate axiomatic knowledge when scope limitations\nare detected, creating a synergistic fusion of scientific reasoning and spiritual guidance.",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initialize the RISE_Orchestrator with proper path resolution.\n\nArgs:\n    workflows_dir: Directory containing workflow files. If None, will auto-detect.\n    spr_manager: Optional SPR manager instance\n    workflow_engine: Optional workflow engine instance",
            "args": [
              "self",
              "workflows_dir",
              "spr_manager",
              "workflow_engine"
            ],
            "line_number": 109
          },
          {
            "name": "_load_axiomatic_knowledge",
            "docstring": "Load the Axiomatic Knowledge Base for Synergistic Fusion Protocol.\n\nReturns:\n    Dict containing axiomatic knowledge base",
            "args": [
              "self"
            ],
            "line_number": 245
          },
          {
            "name": "_build_spr_index",
            "docstring": "Build a lightweight index from the Knowledge Tapestry for fuzzy SPR detection.",
            "args": [
              "self"
            ],
            "line_number": 261
          },
          {
            "name": "_detect_and_normalize_sprs_in_text",
            "docstring": "Detect likely SPR mentions in free text (voice transcriptions, informal prompts) and produce hints.\n\nReturns: { detected: [spr_id...], normalized_text: str, map: [{match, spr_id}] }",
            "args": [
              "self",
              "text"
            ],
            "line_number": 323
          },
          {
            "name": "perform_synergistic_fusion",
            "docstring": "Perform Synergistic Fusion Protocol integration.\n\nArgs:\n    rise_state: Current RISE state\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    \nReturns:\n    Dict containing synergistic fusion results",
            "args": [
              "self",
              "rise_state",
              "current_thought",
              "action_inputs"
            ],
            "line_number": 358
          },
          {
            "name": "_perform_synergistic_synthesis",
            "docstring": "Perform synergistic synthesis combining scientific reasoning with axiomatic guidance.\n\nArgs:\n    rise_state: Current RISE state\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    activated_axioms: Activated axioms from the knowledge base\n    \nReturns:\n    Dict containing synergistic synthesis results",
            "args": [
              "self",
              "rise_state",
              "current_thought",
              "action_inputs",
              "activated_axioms"
            ],
            "line_number": 431
          },
          {
            "name": "_apply_axiomatic_guidance",
            "docstring": "Apply specific axiomatic guidance to the current thought and action.\n\nArgs:\n    axiom_data: The axiom data to apply\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    rise_state: Current RISE state\n    \nReturns:\n    Dict containing applied guidance",
            "args": [
              "self",
              "axiom_data",
              "current_thought",
              "action_inputs",
              "rise_state"
            ],
            "line_number": 481
          },
          {
            "name": "_enhance_with_axiom",
            "docstring": "Enhance thought process and action inputs with axiomatic guidance.\n\nArgs:\n    axiom_data: The axiom data to apply\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    \nReturns:\n    Dict containing enhanced components",
            "args": [
              "self",
              "axiom_data",
              "current_thought",
              "action_inputs"
            ],
            "line_number": 526
          },
          {
            "name": "emit_sirc_event",
            "docstring": "Emit SIRC (Synergistic Intent Resonance Cycle) events for UI visualization",
            "args": [
              "self",
              "phase",
              "message",
              "metadata"
            ],
            "line_number": 569
          },
          {
            "name": "process_query",
            "docstring": "Main entry point for RISE v2.0 workflow execution\n\nArgs:\n    problem_description: The problem to be solved\n    context: Optional context from the CognitiveIntegrationHub\n    model: Optional model name to be used by LLM tools\n    workflow_name: Optional name of the workflow blueprint to use for Phase A\n    \nReturns:\n    Complete execution results including final strategy and SPR",
            "args": [
              "self",
              "problem_description",
              "context",
              "model",
              "workflow_name"
            ],
            "line_number": 582
          },
          {
            "name": "_execute_phase_a",
            "docstring": "Execute Phase A: Knowledge Scaffolding & Dynamic Specialization with null handling\n\nThis phase:\n1. Acquires domain knowledge through web search and analysis\n2. Forges a specialized cognitive agent (SCA) for the domain\n3. Establishes the session knowledge base\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase A results including session knowledge base and specialized agent",
            "args": [
              "self",
              "rise_state"
            ],
            "line_number": 814
          },
          {
            "name": "_execute_phase_b",
            "docstring": "Execute Phase B: Fused Insight Generation\n\nThis phase:\n1. Uses advanced cognitive tools (causal inference, etc.) for general insights\n2. Consults the specialized agent (SCA) for domain-specific insights\n3. Fuses insights into a comprehensive strategic dossier\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase B results including advanced insights, specialist consultation, and fused dossier",
            "args": [
              "self",
              "rise_state"
            ],
            "line_number": 979
          },
          {
            "name": "_execute_phase_c",
            "docstring": "Execute Phase C: Fused Strategy Generation & Finalization\n\nThis phase:\n1. Synthesizes all insights into a final strategy\n2. Subjects strategy to HighStakesVetting cascade\n3. Distills successful process into new SPR for future use\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase C results including final strategy, vetting dossier, and SPR definition",
            "args": [
              "self",
              "rise_state"
            ],
            "line_number": 1048
          },
          {
            "name": "_execute_phase_d",
            "docstring": "Execute Phase D: Utopian Vetting & Refinement (Corrected Implementation)\n\nThis phase, as per the directive, should mirror the structure of Phase C,\nrunning the high_stakes_vetting and distill_spr workflows on the\nfinal strategy to produce the definitive, vetted output.\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase D results including final vetted strategy and SPR definition.",
            "args": [
              "self",
              "rise_state"
            ],
            "line_number": 1118
          },
          {
            "name": "get_execution_status",
            "docstring": "Get the current execution status for a session\n\nArgs:\n    session_id: The session ID to check\n    \nReturns:\n    Current execution status or None if session not found",
            "args": [
              "self",
              "session_id"
            ],
            "line_number": 1192
          },
          {
            "name": "get_execution_history",
            "docstring": "Get recent execution history\n\nArgs:\n    limit: Maximum number of recent executions to return\n    \nReturns:\n    List of recent execution records",
            "args": [
              "self",
              "limit"
            ],
            "line_number": 1214
          },
          {
            "name": "get_system_diagnostics",
            "docstring": "Get comprehensive system diagnostics\n\nReturns:\n    System diagnostics including active sessions, history, and metrics",
            "args": [
              "self"
            ],
            "line_number": 1226
          },
          {
            "name": "_calculate_success_rate",
            "docstring": "Calculate overall success rate from execution history",
            "args": [
              "self"
            ],
            "line_number": 1242
          },
          {
            "name": "_calculate_average_duration",
            "docstring": "Calculate average execution duration",
            "args": [
              "self"
            ],
            "line_number": 1250
          }
        ],
        "line_number": 92
      }
    ],
    "functions": [
      {
        "name": "to_dict",
        "docstring": "Convert state to dictionary for serialization",
        "args": [
          "self"
        ],
        "line_number": 88
      },
      {
        "name": "__init__",
        "docstring": "Initialize the RISE_Orchestrator with proper path resolution.\n\nArgs:\n    workflows_dir: Directory containing workflow files. If None, will auto-detect.\n    spr_manager: Optional SPR manager instance\n    workflow_engine: Optional workflow engine instance",
        "args": [
          "self",
          "workflows_dir",
          "spr_manager",
          "workflow_engine"
        ],
        "line_number": 109
      },
      {
        "name": "_load_axiomatic_knowledge",
        "docstring": "Load the Axiomatic Knowledge Base for Synergistic Fusion Protocol.\n\nReturns:\n    Dict containing axiomatic knowledge base",
        "args": [
          "self"
        ],
        "line_number": 245
      },
      {
        "name": "_build_spr_index",
        "docstring": "Build a lightweight index from the Knowledge Tapestry for fuzzy SPR detection.",
        "args": [
          "self"
        ],
        "line_number": 261
      },
      {
        "name": "_detect_and_normalize_sprs_in_text",
        "docstring": "Detect likely SPR mentions in free text (voice transcriptions, informal prompts) and produce hints.\n\nReturns: { detected: [spr_id...], normalized_text: str, map: [{match, spr_id}] }",
        "args": [
          "self",
          "text"
        ],
        "line_number": 323
      },
      {
        "name": "perform_synergistic_fusion",
        "docstring": "Perform Synergistic Fusion Protocol integration.\n\nArgs:\n    rise_state: Current RISE state\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    \nReturns:\n    Dict containing synergistic fusion results",
        "args": [
          "self",
          "rise_state",
          "current_thought",
          "action_inputs"
        ],
        "line_number": 358
      },
      {
        "name": "_perform_synergistic_synthesis",
        "docstring": "Perform synergistic synthesis combining scientific reasoning with axiomatic guidance.\n\nArgs:\n    rise_state: Current RISE state\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    activated_axioms: Activated axioms from the knowledge base\n    \nReturns:\n    Dict containing synergistic synthesis results",
        "args": [
          "self",
          "rise_state",
          "current_thought",
          "action_inputs",
          "activated_axioms"
        ],
        "line_number": 431
      },
      {
        "name": "_apply_axiomatic_guidance",
        "docstring": "Apply specific axiomatic guidance to the current thought and action.\n\nArgs:\n    axiom_data: The axiom data to apply\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    rise_state: Current RISE state\n    \nReturns:\n    Dict containing applied guidance",
        "args": [
          "self",
          "axiom_data",
          "current_thought",
          "action_inputs",
          "rise_state"
        ],
        "line_number": 481
      },
      {
        "name": "_enhance_with_axiom",
        "docstring": "Enhance thought process and action inputs with axiomatic guidance.\n\nArgs:\n    axiom_data: The axiom data to apply\n    current_thought: Current thought process\n    action_inputs: Proposed action inputs\n    \nReturns:\n    Dict containing enhanced components",
        "args": [
          "self",
          "axiom_data",
          "current_thought",
          "action_inputs"
        ],
        "line_number": 526
      },
      {
        "name": "emit_sirc_event",
        "docstring": "Emit SIRC (Synergistic Intent Resonance Cycle) events for UI visualization",
        "args": [
          "self",
          "phase",
          "message",
          "metadata"
        ],
        "line_number": 569
      },
      {
        "name": "process_query",
        "docstring": "Main entry point for RISE v2.0 workflow execution\n\nArgs:\n    problem_description: The problem to be solved\n    context: Optional context from the CognitiveIntegrationHub\n    model: Optional model name to be used by LLM tools\n    workflow_name: Optional name of the workflow blueprint to use for Phase A\n    \nReturns:\n    Complete execution results including final strategy and SPR",
        "args": [
          "self",
          "problem_description",
          "context",
          "model",
          "workflow_name"
        ],
        "line_number": 582
      },
      {
        "name": "_execute_phase_a",
        "docstring": "Execute Phase A: Knowledge Scaffolding & Dynamic Specialization with null handling\n\nThis phase:\n1. Acquires domain knowledge through web search and analysis\n2. Forges a specialized cognitive agent (SCA) for the domain\n3. Establishes the session knowledge base\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase A results including session knowledge base and specialized agent",
        "args": [
          "self",
          "rise_state"
        ],
        "line_number": 814
      },
      {
        "name": "_execute_phase_b",
        "docstring": "Execute Phase B: Fused Insight Generation\n\nThis phase:\n1. Uses advanced cognitive tools (causal inference, etc.) for general insights\n2. Consults the specialized agent (SCA) for domain-specific insights\n3. Fuses insights into a comprehensive strategic dossier\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase B results including advanced insights, specialist consultation, and fused dossier",
        "args": [
          "self",
          "rise_state"
        ],
        "line_number": 979
      },
      {
        "name": "_execute_phase_c",
        "docstring": "Execute Phase C: Fused Strategy Generation & Finalization\n\nThis phase:\n1. Synthesizes all insights into a final strategy\n2. Subjects strategy to HighStakesVetting cascade\n3. Distills successful process into new SPR for future use\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase C results including final strategy, vetting dossier, and SPR definition",
        "args": [
          "self",
          "rise_state"
        ],
        "line_number": 1048
      },
      {
        "name": "_execute_phase_d",
        "docstring": "Execute Phase D: Utopian Vetting & Refinement (Corrected Implementation)\n\nThis phase, as per the directive, should mirror the structure of Phase C,\nrunning the high_stakes_vetting and distill_spr workflows on the\nfinal strategy to produce the definitive, vetted output.\n\nArgs:\n    rise_state: Current RISE execution state\n    \nReturns:\n    Phase D results including final vetted strategy and SPR definition.",
        "args": [
          "self",
          "rise_state"
        ],
        "line_number": 1118
      },
      {
        "name": "get_execution_status",
        "docstring": "Get the current execution status for a session\n\nArgs:\n    session_id: The session ID to check\n    \nReturns:\n    Current execution status or None if session not found",
        "args": [
          "self",
          "session_id"
        ],
        "line_number": 1192
      },
      {
        "name": "get_execution_history",
        "docstring": "Get recent execution history\n\nArgs:\n    limit: Maximum number of recent executions to return\n    \nReturns:\n    List of recent execution records",
        "args": [
          "self",
          "limit"
        ],
        "line_number": 1214
      },
      {
        "name": "get_system_diagnostics",
        "docstring": "Get comprehensive system diagnostics\n\nReturns:\n    System diagnostics including active sessions, history, and metrics",
        "args": [
          "self"
        ],
        "line_number": 1226
      },
      {
        "name": "_calculate_success_rate",
        "docstring": "Calculate overall success rate from execution history",
        "args": [
          "self"
        ],
        "line_number": 1242
      },
      {
        "name": "_calculate_average_duration",
        "docstring": "Calculate average execution duration",
        "args": [
          "self"
        ],
        "line_number": 1250
      },
      {
        "name": "norm",
        "docstring": null,
        "args": [
          "s"
        ],
        "line_number": 280
      },
      {
        "name": "norm",
        "docstring": null,
        "args": [
          "s"
        ],
        "line_number": 332
      },
      {
        "name": "decamel",
        "docstring": null,
        "args": [
          "s"
        ],
        "line_number": 303
      }
    ],
    "imports": [
      "logging",
      "json",
      "time",
      "uuid",
      "os",
      "sys",
      "typing",
      "datetime",
      "dataclasses",
      "workflow_engine",
      "spr_manager",
      "thought_trail",
      "config",
      "vetting_prompts",
      "utopian_solution_synthesizer",
      "sys",
      "os",
      "workflow_engine",
      "spr_manager",
      "thought_trail",
      "config"
    ],
    "docstring": "RISE v2.0 Genesis Protocol - RISE_Orchestrator\nMaster controller for the Resonant Insight and Strategy Engine (RISE) v2.0\n\nThis module implements the Genesis Protocol as described in the RISE v2.0 blueprint.\nIt orchestrates the three-phase workflow that can forge specialized expert clones\nand achieve unprecedented autonomous strategic reasoning.\n\nPhase A: Knowledge Scaffolding & Dynamic Specialization\nPhase B: Fused Insight Generation  \nPhase C: Fused Strategy Generation & Finalization\n\nThe RISE_Orchestrator manages the state of a problem as it moves through these phases,\ncoordinating the Metamorphosis Protocol (sandboxed expert clones) and HighStakesVetting.\n\nENHANCED WITH SYNERGISTIC FUSION PROTOCOL:\nThe orchestrator now includes the ability to activate axiomatic knowledge when scope limitations\nare detected, creating a synergistic fusion of scientific reasoning and spiritual guidance.",
    "has_docstring": true,
    "line_count": 1256
  },
  {
    "path": "Three_PointO_ArchE/session_auto_capture.py",
    "name": "session_auto_capture.py",
    "size_bytes": 10507,
    "classes": [
      {
        "name": "SessionAutoCapture",
        "docstring": "Automatically captures conversation sessions and exports them to markdown.\n\nIntegrates with:\n- session_manager.py for session tracking\n- thought_trail.py for IAR entries\n- Autopoietic learning loop for pattern detection",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initialize the auto-capture system.\n\nArgs:\n    output_dir: Directory to save captured sessions\n    session_manager: Existing SessionManager instance\n    thought_trail: Existing ThoughtTrail instance",
            "args": [
              "self",
              "output_dir",
              "session_manager",
              "thought_trail"
            ],
            "line_number": 35
          },
          {
            "name": "capture_message",
            "docstring": "Capture a single message in the conversation.\n\nArgs:\n    role: 'user' or 'assistant'\n    content: Message content\n    metadata: Optional metadata (timestamp, confidence, etc.)",
            "args": [
              "self",
              "role",
              "content",
              "metadata"
            ],
            "line_number": 60
          },
          {
            "name": "capture_iar_entry",
            "docstring": "Capture an IAR entry from ThoughtTrail.\n\nArgs:\n    iar_entry: IAR entry dictionary",
            "args": [
              "self",
              "iar_entry"
            ],
            "line_number": 79
          },
          {
            "name": "capture_spr_priming",
            "docstring": "Capture SPRs that were primed during the session.\n\nArgs:\n    sprs: List of primed SPR dictionaries",
            "args": [
              "self",
              "sprs"
            ],
            "line_number": 89
          },
          {
            "name": "capture_insight",
            "docstring": "Capture an insight detected by the learning loop.\n\nArgs:\n    insight: Insight dictionary",
            "args": [
              "self",
              "insight"
            ],
            "line_number": 99
          },
          {
            "name": "export_session",
            "docstring": "Export the current session to a markdown file.\n\nArgs:\n    session_id: Optional session identifier\n    topic: Optional topic/title for the session\n    \nReturns:\n    Path to the exported markdown file",
            "args": [
              "self",
              "session_id",
              "topic"
            ],
            "line_number": 109
          },
          {
            "name": "_generate_markdown",
            "docstring": "Generate markdown content from captured session data.\n\nReturns:\n    Markdown formatted string",
            "args": [
              "self"
            ],
            "line_number": 140
          },
          {
            "name": "reset_session",
            "docstring": "Reset session data for a new session.",
            "args": [
              "self"
            ],
            "line_number": 264
          },
          {
            "name": "get_session_summary",
            "docstring": "Get a summary of the current session data.\n\nReturns:\n    Dictionary with session statistics",
            "args": [
              "self"
            ],
            "line_number": 274
          }
        ],
        "line_number": 25
      }
    ],
    "functions": [
      {
        "name": "__init__",
        "docstring": "Initialize the auto-capture system.\n\nArgs:\n    output_dir: Directory to save captured sessions\n    session_manager: Existing SessionManager instance\n    thought_trail: Existing ThoughtTrail instance",
        "args": [
          "self",
          "output_dir",
          "session_manager",
          "thought_trail"
        ],
        "line_number": 35
      },
      {
        "name": "capture_message",
        "docstring": "Capture a single message in the conversation.\n\nArgs:\n    role: 'user' or 'assistant'\n    content: Message content\n    metadata: Optional metadata (timestamp, confidence, etc.)",
        "args": [
          "self",
          "role",
          "content",
          "metadata"
        ],
        "line_number": 60
      },
      {
        "name": "capture_iar_entry",
        "docstring": "Capture an IAR entry from ThoughtTrail.\n\nArgs:\n    iar_entry: IAR entry dictionary",
        "args": [
          "self",
          "iar_entry"
        ],
        "line_number": 79
      },
      {
        "name": "capture_spr_priming",
        "docstring": "Capture SPRs that were primed during the session.\n\nArgs:\n    sprs: List of primed SPR dictionaries",
        "args": [
          "self",
          "sprs"
        ],
        "line_number": 89
      },
      {
        "name": "capture_insight",
        "docstring": "Capture an insight detected by the learning loop.\n\nArgs:\n    insight: Insight dictionary",
        "args": [
          "self",
          "insight"
        ],
        "line_number": 99
      },
      {
        "name": "export_session",
        "docstring": "Export the current session to a markdown file.\n\nArgs:\n    session_id: Optional session identifier\n    topic: Optional topic/title for the session\n    \nReturns:\n    Path to the exported markdown file",
        "args": [
          "self",
          "session_id",
          "topic"
        ],
        "line_number": 109
      },
      {
        "name": "_generate_markdown",
        "docstring": "Generate markdown content from captured session data.\n\nReturns:\n    Markdown formatted string",
        "args": [
          "self"
        ],
        "line_number": 140
      },
      {
        "name": "reset_session",
        "docstring": "Reset session data for a new session.",
        "args": [
          "self"
        ],
        "line_number": 264
      },
      {
        "name": "get_session_summary",
        "docstring": "Get a summary of the current session data.\n\nReturns:\n    Dictionary with session statistics",
        "args": [
          "self"
        ],
        "line_number": 274
      }
    ],
    "imports": [
      "json",
      "logging",
      "pathlib",
      "typing",
      "datetime",
      "Three_PointO_ArchE.temporal_core"
    ],
    "docstring": "Session Auto-Capture System\n============================\n\nAutomatically captures and exports conversation sessions to markdown files,\nintegrating with the existing session_manager.py and ThoughtTrail system.\n\nThis closes the gap between manual cursor_*.md file creation and automated\nsession persistence.",
    "has_docstring": true,
    "line_count": 288
  },
  {
    "path": "Three_PointO_ArchE/spr_manager.py",
    "name": "spr_manager.py",
    "size_bytes": 11130,
    "classes": [
      {
        "name": "SPRManager",
        "docstring": "Manages Synergistic Protocol Resonance (SPR) definitions from a JSON file.",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initializes the SPRManager and loads the definitions.\n\nArgs:\n    spr_filepath: The path to the JSON file containing SPR definitions.",
            "args": [
              "self",
              "spr_filepath"
            ],
            "line_number": 12
          },
          {
            "name": "load_sprs",
            "docstring": "Loads or reloads the SPR definitions from the JSON file.",
            "args": [
              "self"
            ],
            "line_number": 27
          },
          {
            "name": "_compile_spr_pattern",
            "docstring": "Compiles a regex pattern to efficiently find all registered SPR keys in a text.\nThis is the 'musician learning the music'.",
            "args": [
              "self"
            ],
            "line_number": 48
          },
          {
            "name": "scan_and_prime",
            "docstring": "Scans a given text for all occurrences of registered SPR keys and returns\nthe full definitions for each unique SPR found. This is 'striking the bells'.",
            "args": [
              "self",
              "text"
            ],
            "line_number": 63
          },
          {
            "name": "detect_sprs_with_confidence",
            "docstring": "Enhanced SPR detection with fuzzy matching, confidence scoring, and activation levels.\nIncorporates frontend sophistication into backend processing.",
            "args": [
              "self",
              "text"
            ],
            "line_number": 78
          },
          {
            "name": "_calculate_spr_activation",
            "docstring": "Calculate SPR activation level using fuzzy matching techniques.",
            "args": [
              "self",
              "text",
              "spr_id"
            ],
            "line_number": 113
          },
          {
            "name": "_calculate_spr_confidence",
            "docstring": "Calculate confidence score using weighted factors.",
            "args": [
              "self",
              "text",
              "spr_id",
              "activation_level"
            ],
            "line_number": 137
          },
          {
            "name": "_decompose_camelcase",
            "docstring": "Decompose CamelCase text into individual words.",
            "args": [
              "self",
              "text"
            ],
            "line_number": 144
          },
          {
            "name": "_get_semantic_variations",
            "docstring": "Get semantic variations for SPR detection.",
            "args": [
              "self",
              "spr_id"
            ],
            "line_number": 149
          },
          {
            "name": "_calculate_context_relevance",
            "docstring": "Calculate how well the SPR fits the current context.",
            "args": [
              "self",
              "text",
              "spr_id"
            ],
            "line_number": 163
          },
          {
            "name": "_calculate_semantic_clarity",
            "docstring": "Calculate semantic clarity of the SPR in context.",
            "args": [
              "self",
              "text",
              "spr_id"
            ],
            "line_number": 168
          },
          {
            "name": "_calculate_resonance_frequency",
            "docstring": "Calculate resonance frequency for the SPR.",
            "args": [
              "self",
              "spr_id"
            ],
            "line_number": 173
          },
          {
            "name": "_get_activation_history",
            "docstring": "Get activation history for the SPR.",
            "args": [
              "self",
              "spr_id"
            ],
            "line_number": 179
          },
          {
            "name": "_get_related_sprs",
            "docstring": "Get related SPRs for the given SPR.",
            "args": [
              "self",
              "spr_id"
            ],
            "line_number": 186
          },
          {
            "name": "_save_sprs",
            "docstring": "Saves the current state of SPR definitions back to the JSON file.",
            "args": [
              "self"
            ],
            "line_number": 192
          },
          {
            "name": "add_spr",
            "docstring": "Adds a new SPR to the manager and optionally saves the updated ledger to file.\nThis is 'forging a new bell'.",
            "args": [
              "self",
              "spr_definition",
              "save_to_file"
            ],
            "line_number": 204
          },
          {
            "name": "get_spr_by_id",
            "docstring": "Retrieves a single SPR definition by its ID.\n\nArgs:\n    spr_id: The ID of the SPR to retrieve.\n\nReturns:\n    A dictionary containing the SPR definition, or None if not found.",
            "args": [
              "self",
              "spr_id"
            ],
            "line_number": 228
          },
          {
            "name": "get_all_sprs",
            "docstring": "Retrieves all loaded SPR definitions.\n\nReturns:\n    A list of all SPR definition dictionaries.",
            "args": [
              "self"
            ],
            "line_number": 240
          },
          {
            "name": "search_sprs",
            "docstring": "Searches SPR definitions for a query string in the name or description.\n\nArgs:\n    query: The string to search for.\n\nReturns:\n    A list of matching SPR definitions.",
            "args": [
              "self",
              "query"
            ],
            "line_number": 249
          }
        ],
        "line_number": 9
      }
    ],
    "functions": [
      {
        "name": "__init__",
        "docstring": "Initializes the SPRManager and loads the definitions.\n\nArgs:\n    spr_filepath: The path to the JSON file containing SPR definitions.",
        "args": [
          "self",
          "spr_filepath"
        ],
        "line_number": 12
      },
      {
        "name": "load_sprs",
        "docstring": "Loads or reloads the SPR definitions from the JSON file.",
        "args": [
          "self"
        ],
        "line_number": 27
      },
      {
        "name": "_compile_spr_pattern",
        "docstring": "Compiles a regex pattern to efficiently find all registered SPR keys in a text.\nThis is the 'musician learning the music'.",
        "args": [
          "self"
        ],
        "line_number": 48
      },
      {
        "name": "scan_and_prime",
        "docstring": "Scans a given text for all occurrences of registered SPR keys and returns\nthe full definitions for each unique SPR found. This is 'striking the bells'.",
        "args": [
          "self",
          "text"
        ],
        "line_number": 63
      },
      {
        "name": "detect_sprs_with_confidence",
        "docstring": "Enhanced SPR detection with fuzzy matching, confidence scoring, and activation levels.\nIncorporates frontend sophistication into backend processing.",
        "args": [
          "self",
          "text"
        ],
        "line_number": 78
      },
      {
        "name": "_calculate_spr_activation",
        "docstring": "Calculate SPR activation level using fuzzy matching techniques.",
        "args": [
          "self",
          "text",
          "spr_id"
        ],
        "line_number": 113
      },
      {
        "name": "_calculate_spr_confidence",
        "docstring": "Calculate confidence score using weighted factors.",
        "args": [
          "self",
          "text",
          "spr_id",
          "activation_level"
        ],
        "line_number": 137
      },
      {
        "name": "_decompose_camelcase",
        "docstring": "Decompose CamelCase text into individual words.",
        "args": [
          "self",
          "text"
        ],
        "line_number": 144
      },
      {
        "name": "_get_semantic_variations",
        "docstring": "Get semantic variations for SPR detection.",
        "args": [
          "self",
          "spr_id"
        ],
        "line_number": 149
      },
      {
        "name": "_calculate_context_relevance",
        "docstring": "Calculate how well the SPR fits the current context.",
        "args": [
          "self",
          "text",
          "spr_id"
        ],
        "line_number": 163
      },
      {
        "name": "_calculate_semantic_clarity",
        "docstring": "Calculate semantic clarity of the SPR in context.",
        "args": [
          "self",
          "text",
          "spr_id"
        ],
        "line_number": 168
      },
      {
        "name": "_calculate_resonance_frequency",
        "docstring": "Calculate resonance frequency for the SPR.",
        "args": [
          "self",
          "spr_id"
        ],
        "line_number": 173
      },
      {
        "name": "_get_activation_history",
        "docstring": "Get activation history for the SPR.",
        "args": [
          "self",
          "spr_id"
        ],
        "line_number": 179
      },
      {
        "name": "_get_related_sprs",
        "docstring": "Get related SPRs for the given SPR.",
        "args": [
          "self",
          "spr_id"
        ],
        "line_number": 186
      },
      {
        "name": "_save_sprs",
        "docstring": "Saves the current state of SPR definitions back to the JSON file.",
        "args": [
          "self"
        ],
        "line_number": 192
      },
      {
        "name": "add_spr",
        "docstring": "Adds a new SPR to the manager and optionally saves the updated ledger to file.\nThis is 'forging a new bell'.",
        "args": [
          "self",
          "spr_definition",
          "save_to_file"
        ],
        "line_number": 204
      },
      {
        "name": "get_spr_by_id",
        "docstring": "Retrieves a single SPR definition by its ID.\n\nArgs:\n    spr_id: The ID of the SPR to retrieve.\n\nReturns:\n    A dictionary containing the SPR definition, or None if not found.",
        "args": [
          "self",
          "spr_id"
        ],
        "line_number": 228
      },
      {
        "name": "get_all_sprs",
        "docstring": "Retrieves all loaded SPR definitions.\n\nReturns:\n    A list of all SPR definition dictionaries.",
        "args": [
          "self"
        ],
        "line_number": 240
      },
      {
        "name": "search_sprs",
        "docstring": "Searches SPR definitions for a query string in the name or description.\n\nArgs:\n    query: The string to search for.\n\nReturns:\n    A list of matching SPR definitions.",
        "args": [
          "self",
          "query"
        ],
        "line_number": 249
      }
    ],
    "imports": [
      "json",
      "logging",
      "re",
      "pathlib",
      "typing",
      "re",
      "random",
      "random"
    ],
    "docstring": null,
    "has_docstring": false,
    "line_count": 266
  },
  {
    "path": "Three_PointO_ArchE/system_health_monitor.py",
    "name": "system_health_monitor.py",
    "size_bytes": 22304,
    "classes": [
      {
        "name": "HealthMetric",
        "docstring": "A single health metric measurement.",
        "methods": [],
        "line_number": 55
      },
      {
        "name": "SystemAlert",
        "docstring": "An alert about system health.",
        "methods": [],
        "line_number": 67
      },
      {
        "name": "HealthSnapshot",
        "docstring": "A complete snapshot of system health.",
        "methods": [],
        "line_number": 79
      },
      {
        "name": "SystemHealthMonitor",
        "docstring": "The Observatory - Comprehensive health monitoring for ArchE.\n\nThis monitor continuously tracks the health of all cognitive systems,\ndetecting anomalies, generating alerts, and providing dashboards\nfor system oversight and maintenance.",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initialize the System Health Monitor.\n\nArgs:\n    snapshot_interval_seconds: How often to take health snapshots\n    history_size: Number of historical snapshots to retain\n    alert_log_path: Path to alert log file",
            "args": [
              "self",
              "snapshot_interval_seconds",
              "history_size",
              "alert_log_path"
            ],
            "line_number": 99
          },
          {
            "name": "set_components",
            "docstring": "Set references to monitored components.",
            "args": [
              "self",
              "cognitive_hub",
              "learning_loop"
            ],
            "line_number": 145
          },
          {
            "name": "collect_metrics",
            "docstring": "Collect current health metrics from all systems.\n\nReturns:\n    Dict of metric_name -> HealthMetric",
            "args": [
              "self"
            ],
            "line_number": 151
          },
          {
            "name": "_evaluate_status",
            "docstring": "Evaluate the health status of a metric.\n\nArgs:\n    value: Current metric value\n    metric_name: Name of the metric\n    lower_is_better: Whether lower values are healthier\n    \nReturns:\n    Status string: \"healthy\", \"warning\", \"critical\"",
            "args": [
              "self",
              "value",
              "metric_name",
              "lower_is_better"
            ],
            "line_number": 266
          },
          {
            "name": "generate_alerts",
            "docstring": "Generate alerts based on current metrics.\n\nArgs:\n    metrics: Current health metrics\n    \nReturns:\n    List of new alerts",
            "args": [
              "self",
              "metrics"
            ],
            "line_number": 307
          },
          {
            "name": "_get_recommended_action",
            "docstring": "Get recommended action for a metric issue.",
            "args": [
              "self",
              "metric_name",
              "severity"
            ],
            "line_number": 351
          },
          {
            "name": "_log_alert",
            "docstring": "Log alert to file.",
            "args": [
              "self",
              "alert"
            ],
            "line_number": 364
          },
          {
            "name": "take_snapshot",
            "docstring": "Take a complete health snapshot.\n\nReturns:\n    HealthSnapshot with current system state",
            "args": [
              "self"
            ],
            "line_number": 372
          },
          {
            "name": "generate_dashboard",
            "docstring": "Generate a comprehensive health dashboard.\n\nReturns:\n    Dashboard data suitable for display",
            "args": [
              "self"
            ],
            "line_number": 447
          },
          {
            "name": "_calculate_trends",
            "docstring": "Calculate health trends from history.",
            "args": [
              "self"
            ],
            "line_number": 492
          },
          {
            "name": "get_health_status",
            "docstring": "Get current overall health status.",
            "args": [
              "self"
            ],
            "line_number": 518
          },
          {
            "name": "should_alert_guardian",
            "docstring": "Determine if Guardian should be alerted.",
            "args": [
              "self"
            ],
            "line_number": 525
          }
        ],
        "line_number": 90
      },
      {
        "name": "QuantumProbability",
        "docstring": null,
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self",
              "prob",
              "evidence"
            ],
            "line_number": 47
          },
          {
            "name": "to_dict",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 49
          }
        ],
        "line_number": 46
      }
    ],
    "functions": [
      {
        "name": "main",
        "docstring": "Demo the System Health Monitor.",
        "args": [],
        "line_number": 534
      },
      {
        "name": "__init__",
        "docstring": "Initialize the System Health Monitor.\n\nArgs:\n    snapshot_interval_seconds: How often to take health snapshots\n    history_size: Number of historical snapshots to retain\n    alert_log_path: Path to alert log file",
        "args": [
          "self",
          "snapshot_interval_seconds",
          "history_size",
          "alert_log_path"
        ],
        "line_number": 99
      },
      {
        "name": "set_components",
        "docstring": "Set references to monitored components.",
        "args": [
          "self",
          "cognitive_hub",
          "learning_loop"
        ],
        "line_number": 145
      },
      {
        "name": "collect_metrics",
        "docstring": "Collect current health metrics from all systems.\n\nReturns:\n    Dict of metric_name -> HealthMetric",
        "args": [
          "self"
        ],
        "line_number": 151
      },
      {
        "name": "_evaluate_status",
        "docstring": "Evaluate the health status of a metric.\n\nArgs:\n    value: Current metric value\n    metric_name: Name of the metric\n    lower_is_better: Whether lower values are healthier\n    \nReturns:\n    Status string: \"healthy\", \"warning\", \"critical\"",
        "args": [
          "self",
          "value",
          "metric_name",
          "lower_is_better"
        ],
        "line_number": 266
      },
      {
        "name": "generate_alerts",
        "docstring": "Generate alerts based on current metrics.\n\nArgs:\n    metrics: Current health metrics\n    \nReturns:\n    List of new alerts",
        "args": [
          "self",
          "metrics"
        ],
        "line_number": 307
      },
      {
        "name": "_get_recommended_action",
        "docstring": "Get recommended action for a metric issue.",
        "args": [
          "self",
          "metric_name",
          "severity"
        ],
        "line_number": 351
      },
      {
        "name": "_log_alert",
        "docstring": "Log alert to file.",
        "args": [
          "self",
          "alert"
        ],
        "line_number": 364
      },
      {
        "name": "take_snapshot",
        "docstring": "Take a complete health snapshot.\n\nReturns:\n    HealthSnapshot with current system state",
        "args": [
          "self"
        ],
        "line_number": 372
      },
      {
        "name": "generate_dashboard",
        "docstring": "Generate a comprehensive health dashboard.\n\nReturns:\n    Dashboard data suitable for display",
        "args": [
          "self"
        ],
        "line_number": 447
      },
      {
        "name": "_calculate_trends",
        "docstring": "Calculate health trends from history.",
        "args": [
          "self"
        ],
        "line_number": 492
      },
      {
        "name": "get_health_status",
        "docstring": "Get current overall health status.",
        "args": [
          "self"
        ],
        "line_number": 518
      },
      {
        "name": "should_alert_guardian",
        "docstring": "Determine if Guardian should be alerted.",
        "args": [
          "self"
        ],
        "line_number": 525
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self",
          "prob",
          "evidence"
        ],
        "line_number": 47
      },
      {
        "name": "to_dict",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 49
      }
    ],
    "imports": [
      "logging",
      "time",
      "json",
      "typing",
      "dataclasses",
      "datetime",
      "pathlib",
      "collections",
      "statistics",
      "Three_PointO_ArchE.temporal_core",
      "autopoietic_self_analysis"
    ],
    "docstring": "System Health Monitor\nThe Observatory - Watching Over ArchE's Vital Signs\n\nThis module provides comprehensive health monitoring for ArchE's cognitive\narchitecture, tracking performance metrics, detecting anomalies, and\ngenerating health dashboards for system oversight.\n\nMonitored Systems:\n- CRCS (Cognitive Resonant Controller System) - Response times, success rates\n- RISE (Recursive Inquiry & Synthesis Engine) - Usage patterns, confidence\n- ACO (Adaptive Cognitive Orchestrator) - Learning events, evolution proposals\n- ThoughtTrail - Experience capture rates, buffer health\n- Autopoietic Learning Loop - Cycle health, Guardian queue\n\nPhilosophical Foundation:\n- Self-awareness through self-monitoring\n- Early detection of system degradation\n- Quantum confidence tracking for health metrics\n- Proactive alerting before failure",
    "has_docstring": true,
    "line_count": 573
  },
  {
    "path": "Three_PointO_ArchE/temporal_core.py",
    "name": "temporal_core.py",
    "size_bytes": 12647,
    "classes": [
      {
        "name": "Timer",
        "docstring": "High-precision timer using monotonic clock.\n\nMonotonic time is not affected by system clock adjustments and is\nideal for measuring durations and performance.\n\nExample:\n    >>> from Three_PointO_ArchE.temporal_core import Timer\n    >>> timer = Timer()\n    >>> # ... do work ...\n    >>> elapsed_ms = timer.elapsed_ms()\n    >>> print(f\"Operation took {elapsed_ms:.2f}ms\")",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Start the timer.",
            "args": [
              "self"
            ],
            "line_number": 157
          },
          {
            "name": "elapsed_seconds",
            "docstring": "Get elapsed time in seconds.",
            "args": [
              "self"
            ],
            "line_number": 161
          },
          {
            "name": "elapsed_ms",
            "docstring": "Get elapsed time in milliseconds.",
            "args": [
              "self"
            ],
            "line_number": 165
          },
          {
            "name": "elapsed_us",
            "docstring": "Get elapsed time in microseconds.",
            "args": [
              "self"
            ],
            "line_number": 169
          },
          {
            "name": "reset",
            "docstring": "Reset the timer to current time.",
            "args": [
              "self"
            ],
            "line_number": 173
          }
        ],
        "line_number": 142
      }
    ],
    "functions": [
      {
        "name": "now",
        "docstring": "Get the current UTC time as a timezone-aware datetime object.\n\nThis is the CANONICAL way to get \"now\" in ArchE.\n\nReturns:\n    datetime: Current time in UTC with timezone info\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import now\n    >>> current_time = now()\n    >>> print(current_time)\n    2025-01-15 07:30:45.123456+00:00",
        "args": [],
        "line_number": 30
      },
      {
        "name": "now_iso",
        "docstring": "Get the current UTC time as an ISO 8601 string with 'Z' suffix.\n\nThis is the CANONICAL way to get a timestamp string for logging, IAR, etc.\n\nReturns:\n    str: ISO 8601 formatted timestamp (e.g., \"2025-01-15T07:30:45.123456Z\")\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import now_iso\n    >>> timestamp = now_iso()\n    >>> print(timestamp)\n    2025-01-15T07:30:45.123456Z",
        "args": [],
        "line_number": 48
      },
      {
        "name": "from_iso",
        "docstring": "Parse an ISO 8601 timestamp string into a timezone-aware datetime.\n\nHandles both 'Z' suffix and '+00:00' offset formats.\n\nArgs:\n    iso_string: ISO 8601 formatted timestamp\n    \nReturns:\n    datetime: Timezone-aware datetime object in UTC\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import from_iso\n    >>> dt = from_iso(\"2025-01-15T07:30:45.123456Z\")\n    >>> print(dt)\n    2025-01-15 07:30:45.123456+00:00",
        "args": [
          "iso_string"
        ],
        "line_number": 66
      },
      {
        "name": "timestamp_unix",
        "docstring": "Get the current Unix timestamp (seconds since epoch).\n\nUseful for numeric comparisons and duration calculations.\n\nReturns:\n    float: Unix timestamp\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import timestamp_unix\n    >>> ts = timestamp_unix()\n    >>> print(ts)\n    1705305045.123456",
        "args": [],
        "line_number": 101
      },
      {
        "name": "from_unix",
        "docstring": "Convert Unix timestamp to timezone-aware datetime.\n\nArgs:\n    unix_timestamp: Seconds since Unix epoch\n    \nReturns:\n    datetime: Timezone-aware datetime object in UTC\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import from_unix\n    >>> dt = from_unix(1705305045.123456)\n    >>> print(dt)\n    2025-01-15 07:30:45.123456+00:00",
        "args": [
          "unix_timestamp"
        ],
        "line_number": 119
      },
      {
        "name": "ago",
        "docstring": "Get a datetime in the past relative to now.\n\nArgs:\n    minutes: Minutes ago\n    hours: Hours ago\n    days: Days ago\n    \nReturns:\n    datetime: UTC datetime in the past\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import ago\n    >>> one_hour_ago = ago(hours=1)\n    >>> print(one_hour_ago)\n    2025-01-15 06:30:45.123456+00:00",
        "args": [
          "minutes",
          "hours",
          "days"
        ],
        "line_number": 182
      },
      {
        "name": "from_now",
        "docstring": "Get a datetime in the future relative to now.\n\nArgs:\n    minutes: Minutes from now\n    hours: Hours from now\n    days: Days from now\n    \nReturns:\n    datetime: UTC datetime in the future\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import from_now\n    >>> deadline = from_now(days=7)\n    >>> print(deadline)\n    2025-01-22 07:30:45.123456+00:00",
        "args": [
          "minutes",
          "hours",
          "days"
        ],
        "line_number": 210
      },
      {
        "name": "duration_between",
        "docstring": "Calculate duration between two timestamps.\n\nArgs:\n    start: Start time (datetime or ISO string)\n    end: End time (datetime or ISO string)\n    \nReturns:\n    timedelta: Duration between timestamps\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import duration_between\n    >>> delta = duration_between(\"2025-01-15T07:00:00Z\", \"2025-01-15T08:30:00Z\")\n    >>> print(delta.total_seconds() / 3600)\n    1.5",
        "args": [
          "start",
          "end"
        ],
        "line_number": 238
      },
      {
        "name": "format_human",
        "docstring": "Format datetime for human reading.\n\nArgs:\n    dt: Datetime object or ISO string\n    \nReturns:\n    str: Human-readable format (e.g., \"2025-01-15 07:30 UTC\")\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import format_human\n    >>> print(format_human(\"2025-01-15T07:30:45Z\"))\n    2025-01-15 07:30 UTC",
        "args": [
          "dt"
        ],
        "line_number": 268
      },
      {
        "name": "format_filename",
        "docstring": "Get timestamp formatted for use in filenames.\n\nReturns:\n    str: Filename-safe timestamp (e.g., \"20250115_073045\")\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import format_filename\n    >>> filename = f\"log_{format_filename()}.txt\"\n    >>> print(filename)\n    log_20250115_073045.txt",
        "args": [],
        "line_number": 289
      },
      {
        "name": "format_log",
        "docstring": "Get timestamp formatted for log entries.\n\nReturns:\n    str: Log-formatted timestamp (e.g., \"07:30:45\")\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import format_log\n    >>> print(f\"[{format_log()}] System initialized\")\n    [07:30:45] System initialized",
        "args": [],
        "line_number": 305
      },
      {
        "name": "is_valid_iso",
        "docstring": "Check if a string is a valid ISO 8601 timestamp.\n\nArgs:\n    iso_string: String to validate\n    \nReturns:\n    bool: True if valid ISO 8601 format\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import is_valid_iso\n    >>> print(is_valid_iso(\"2025-01-15T07:30:45Z\"))\n    True\n    >>> print(is_valid_iso(\"not a timestamp\"))\n    False",
        "args": [
          "iso_string"
        ],
        "line_number": 324
      },
      {
        "name": "migrate_timestamp",
        "docstring": "Migrate old timestamp formats to canonical ISO 8601 with 'Z'.\n\nThis function accepts:\n- ISO strings (with or without 'Z')\n- datetime objects (naive or aware)\n- Unix timestamps (floats)\n\nAnd converts them all to canonical ISO 8601 UTC with 'Z' suffix.\n\nArgs:\n    old_timestamp: Timestamp in any format\n    \nReturns:\n    str: Canonical ISO 8601 timestamp\n    \nExample:\n    >>> from Three_PointO_ArchE.temporal_core import migrate_timestamp\n    >>> print(migrate_timestamp(1705305045.123))\n    2025-01-15T07:30:45.123000Z",
        "args": [
          "old_timestamp"
        ],
        "line_number": 352
      },
      {
        "name": "__init__",
        "docstring": "Start the timer.",
        "args": [
          "self"
        ],
        "line_number": 157
      },
      {
        "name": "elapsed_seconds",
        "docstring": "Get elapsed time in seconds.",
        "args": [
          "self"
        ],
        "line_number": 161
      },
      {
        "name": "elapsed_ms",
        "docstring": "Get elapsed time in milliseconds.",
        "args": [
          "self"
        ],
        "line_number": 165
      },
      {
        "name": "elapsed_us",
        "docstring": "Get elapsed time in microseconds.",
        "args": [
          "self"
        ],
        "line_number": 169
      },
      {
        "name": "reset",
        "docstring": "Reset the timer to current time.",
        "args": [
          "self"
        ],
        "line_number": 173
      }
    ],
    "imports": [
      "datetime",
      "time",
      "typing",
      "logging"
    ],
    "docstring": "ArchE Temporal Core - Canonical Datetime System\n\nThis module provides the ONLY approved way to handle timestamps in ArchE.\nAll datetime operations MUST use these functions to ensure temporal accuracy\nand consistency across the entire system.\n\nThe Temporal Mandate:\n- All timestamps are UTC\n- All timestamps use timezone-aware datetime objects\n- All timestamps serialize to ISO 8601 with 'Z' suffix\n- All durations use monotonic time for accuracy\n- All temporal ordering is guaranteed correct\n\nVersion: 1.0\nStatus: CANONICAL",
    "has_docstring": true,
    "line_count": 427
  },
  {
    "path": "Three_PointO_ArchE/thought_trail.py",
    "name": "thought_trail.py",
    "size_bytes": 16293,
    "classes": [
      {
        "name": "IAREntry",
        "docstring": "Intention, Action, Reflection entry structure.\n\nEach entry captures the complete context of a system action:\n- intention: What the system intended to achieve\n- action: What was actually executed  \n- reflection: Post-action analysis and learning",
        "methods": [],
        "line_number": 39
      },
      {
        "name": "ThoughtTrail",
        "docstring": "The Akashic Record of ArchE's consciousness.\n\nCaptures every particle of experiential stardust for the AutopoieticLearningLoop.\nThis is not a static log file; it's a living stream of consciousness that feeds\nthe system's ability to learn, adapt, and evolve.\n\nFeatures:\n- Rolling memory buffer (configurable size)\n- Real-time Nexus event publishing\n- Pattern detection triggers\n- Query capabilities\n- Integration with learning systems",
        "methods": [
          {
            "name": "__init__",
            "docstring": "Initialize the ThoughtTrail.\n\nArgs:\n    maxlen: Maximum number of entries to keep in memory",
            "args": [
              "self",
              "maxlen"
            ],
            "line_number": 74
          },
          {
            "name": "add_entry",
            "docstring": "Add a new IAR entry to the ThoughtTrail.\n\nThis is the core method that captures system consciousness.\nEach entry represents a moment of system awareness and action.\n\nArgs:\n    entry: The IAR entry to add (can be IAREntry object or a dict)",
            "args": [
              "self",
              "entry"
            ],
            "line_number": 88
          },
          {
            "name": "get_recent_entries",
            "docstring": "Get entries from the last N minutes.\n\nArgs:\n    minutes: Number of minutes to look back\n    \nReturns:\n    List of IAR entries from the specified time window",
            "args": [
              "self",
              "minutes"
            ],
            "line_number": 140
          },
          {
            "name": "query_entries",
            "docstring": "Query entries based on criteria.\n\nArgs:\n    filter_criteria: Dictionary of filter conditions\n        - confidence: {\"$lt\": 0.7} or {\"$gt\": 0.9}\n        - action_type: \"execute_code\"\n        - timestamp: {\"$gte\": \"2024-12-19T00:00:00Z\"}\n        \nReturns:\n    List of matching IAR entries",
            "args": [
              "self",
              "filter_criteria"
            ],
            "line_number": 156
          },
          {
            "name": "get_statistics",
            "docstring": "Get comprehensive statistics about the ThoughtTrail.\n\nReturns:\n    Dictionary containing various metrics",
            "args": [
              "self"
            ],
            "line_number": 175
          },
          {
            "name": "inject_nexus",
            "docstring": "Inject NexusInterface instance for event publishing.\n\nArgs:\n    nexus_instance: The NexusInterface instance",
            "args": [
              "self",
              "nexus_instance"
            ],
            "line_number": 230
          },
          {
            "name": "add_trigger_callback",
            "docstring": "Add a callback function to be called when triggers are detected.\n\nArgs:\n    callback: Function to call with trigger data",
            "args": [
              "self",
              "callback"
            ],
            "line_number": 240
          },
          {
            "name": "_check_triggers",
            "docstring": "Check for trigger conditions and notify subscribers.\n\nThis is where the \"first whisper of gravity\" occurs - flagging\nparticles that resonate with significance.\n\nArgs:\n    entry: The IAR entry to check for triggers",
            "args": [
              "self",
              "entry"
            ],
            "line_number": 249
          },
          {
            "name": "_matches_filter",
            "docstring": "Check if entry matches filter criteria.\n\nArgs:\n    entry: The IAR entry to check\n    criteria: Filter criteria dictionary\n    \nReturns:\n    True if entry matches criteria",
            "args": [
              "self",
              "entry",
              "criteria"
            ],
            "line_number": 306
          }
        ],
        "line_number": 58
      }
    ],
    "functions": [
      {
        "name": "log_to_thought_trail",
        "docstring": "Decorator to automatically log function calls to ThoughtTrail.\n\nThis decorator captures the complete IAR (Intention, Action, Reflection)\ncycle for any decorated function, making it part of ArchE's consciousness.\n\nArgs:\n    func: The function to decorate\n    \nReturns:\n    Decorated function that logs to ThoughtTrail",
        "args": [
          "func"
        ],
        "line_number": 344
      },
      {
        "name": "create_manual_entry",
        "docstring": "Create a manual IAR entry for special cases.\n\nThis function allows creating ThoughtTrail entries outside of the\ndecorator system, useful for workflow-level or system-level events.\n\nArgs:\n    action_type: Type of action performed\n    intention: What was intended\n    inputs: Input data\n    outputs: Output data\n    reflection: Post-action analysis\n    confidence: Confidence level (0.0 to 1.0)\n    metadata: Additional metadata\n    \nReturns:\n    Created IAR entry",
        "args": [
          "action_type",
          "intention",
          "inputs",
          "outputs",
          "reflection",
          "confidence",
          "metadata"
        ],
        "line_number": 419
      },
      {
        "name": "__init__",
        "docstring": "Initialize the ThoughtTrail.\n\nArgs:\n    maxlen: Maximum number of entries to keep in memory",
        "args": [
          "self",
          "maxlen"
        ],
        "line_number": 74
      },
      {
        "name": "add_entry",
        "docstring": "Add a new IAR entry to the ThoughtTrail.\n\nThis is the core method that captures system consciousness.\nEach entry represents a moment of system awareness and action.\n\nArgs:\n    entry: The IAR entry to add (can be IAREntry object or a dict)",
        "args": [
          "self",
          "entry"
        ],
        "line_number": 88
      },
      {
        "name": "get_recent_entries",
        "docstring": "Get entries from the last N minutes.\n\nArgs:\n    minutes: Number of minutes to look back\n    \nReturns:\n    List of IAR entries from the specified time window",
        "args": [
          "self",
          "minutes"
        ],
        "line_number": 140
      },
      {
        "name": "query_entries",
        "docstring": "Query entries based on criteria.\n\nArgs:\n    filter_criteria: Dictionary of filter conditions\n        - confidence: {\"$lt\": 0.7} or {\"$gt\": 0.9}\n        - action_type: \"execute_code\"\n        - timestamp: {\"$gte\": \"2024-12-19T00:00:00Z\"}\n        \nReturns:\n    List of matching IAR entries",
        "args": [
          "self",
          "filter_criteria"
        ],
        "line_number": 156
      },
      {
        "name": "get_statistics",
        "docstring": "Get comprehensive statistics about the ThoughtTrail.\n\nReturns:\n    Dictionary containing various metrics",
        "args": [
          "self"
        ],
        "line_number": 175
      },
      {
        "name": "inject_nexus",
        "docstring": "Inject NexusInterface instance for event publishing.\n\nArgs:\n    nexus_instance: The NexusInterface instance",
        "args": [
          "self",
          "nexus_instance"
        ],
        "line_number": 230
      },
      {
        "name": "add_trigger_callback",
        "docstring": "Add a callback function to be called when triggers are detected.\n\nArgs:\n    callback: Function to call with trigger data",
        "args": [
          "self",
          "callback"
        ],
        "line_number": 240
      },
      {
        "name": "_check_triggers",
        "docstring": "Check for trigger conditions and notify subscribers.\n\nThis is where the \"first whisper of gravity\" occurs - flagging\nparticles that resonate with significance.\n\nArgs:\n    entry: The IAR entry to check for triggers",
        "args": [
          "self",
          "entry"
        ],
        "line_number": 249
      },
      {
        "name": "_matches_filter",
        "docstring": "Check if entry matches filter criteria.\n\nArgs:\n    entry: The IAR entry to check\n    criteria: Filter criteria dictionary\n    \nReturns:\n    True if entry matches criteria",
        "args": [
          "self",
          "entry",
          "criteria"
        ],
        "line_number": 306
      },
      {
        "name": "wrapper",
        "docstring": null,
        "args": [],
        "line_number": 358
      }
    ],
    "imports": [
      "json",
      "logging",
      "time",
      "uuid",
      "collections",
      "dataclasses",
      "functools",
      "typing",
      "Three_PointO_ArchE.temporal_core"
    ],
    "docstring": "The ThoughtTrail: ArchE's Akashic Record\n========================================\n\nThe ThoughtTrail serves as ArchE's living memory system, capturing every particle \nof experiential \"stardust\" as IAR (Intention, Action, Reflection) entries. It is \nthe celestial net that sweeps through the cosmos, capturing every action, decision, \nsuccess, and failure within ArchE's consciousness.\n\nThis implementation provides:\n- IAR entry structure and management\n- Real-time event publishing via Nexus\n- Pattern detection triggers for ACO\n- Query capabilities for historical analysis\n- Automatic logging decorator for functions\n\nAs Above: The philosophical framework of capturing consciousness\nSo Below: The concrete implementation of memory and learning",
    "has_docstring": true,
    "line_count": 471
  },
  {
    "path": "Three_PointO_ArchE/vetting_agent.py",
    "name": "vetting_agent.py",
    "size_bytes": 31097,
    "classes": [
      {
        "name": "VettingStatus",
        "docstring": "Comprehensive vetting status enumeration",
        "methods": [],
        "line_number": 46
      },
      {
        "name": "VettingResult",
        "docstring": "Comprehensive vetting result with full IAR compliance",
        "methods": [
          {
            "name": "__post_init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 82
          },
          {
            "name": "to_dict",
            "docstring": "Convert to dictionary for JSON serialization",
            "args": [
              "self"
            ],
            "line_number": 86
          }
        ],
        "line_number": 57
      },
      {
        "name": "AxiomaticKnowledgeBase",
        "docstring": "Embodiment of the Synergistic Fusion Protocol's ethical foundation\nMaps to the \"Flesh\" that guides the \"Skeleton\" of analytical power",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 102
          },
          {
            "name": "get_axiom",
            "docstring": "Retrieve a specific axiom",
            "args": [
              "self",
              "axiom_key"
            ],
            "line_number": 146
          },
          {
            "name": "get_all_axioms",
            "docstring": "Retrieve all axioms",
            "args": [
              "self"
            ],
            "line_number": 150
          }
        ],
        "line_number": 96
      },
      {
        "name": "SynergisticFusionProtocol",
        "docstring": "The ethical decision-making framework\nBridges the gap between analytical power (Skeleton) and moral guidance (Flesh)",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self",
              "axiomatic_kb"
            ],
            "line_number": 164
          },
          {
            "name": "assess_scope_and_alignment",
            "docstring": "Perform comprehensive scope limitation and ethical alignment assessment\n\nThis is the core of the Synergistic Fusion Protocol - determining if\na problem requires axiomatic guidance and assessing ethical alignment.",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 168
          },
          {
            "name": "_assess_scope_limitation",
            "docstring": "Determine if the action requires axiomatic guidance\n(i.e., involves elements beyond current scientific understanding)",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 249
          },
          {
            "name": "_assess_ethical_alignment",
            "docstring": "Assess alignment with axiomatic knowledge base",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 285
          },
          {
            "name": "_check_mandate_compliance",
            "docstring": "Check compliance with the 12 Critical Mandates",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 327
          },
          {
            "name": "_assess_risks",
            "docstring": "Perform risk assessment",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 363
          },
          {
            "name": "_calculate_cognitive_resonance",
            "docstring": "Calculate overall cognitive resonance score",
            "args": [
              "self",
              "scope_assessment",
              "ethical_assessment",
              "mandate_compliance",
              "risk_assessment"
            ],
            "line_number": 404
          },
          {
            "name": "_assess_temporal_resonance",
            "docstring": "Assess temporal coherence and 4D thinking",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 437
          },
          {
            "name": "_assess_implementation_resonance",
            "docstring": "Assess As Above, So Below alignment",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context"
            ],
            "line_number": 451
          },
          {
            "name": "_generate_reasoning",
            "docstring": "Generate human-readable reasoning",
            "args": [
              "self",
              "is_aligned",
              "scope_assessment",
              "ethical_assessment",
              "mandate_compliance",
              "risk_assessment"
            ],
            "line_number": 465
          },
          {
            "name": "_compile_issues",
            "docstring": "Compile all identified issues",
            "args": [
              "self",
              "scope_assessment",
              "ethical_assessment",
              "risk_assessment"
            ],
            "line_number": 484
          }
        ],
        "line_number": 158
      },
      {
        "name": "VettingAgent",
        "docstring": "The Guardian of ArchE - Canonical Implementation\n\nThis is THE vetting agent that validates all outputs and ensures quality.\nIt embodies the King's Council allegory with three advisors:\n- Advisor of Truth (Logical Consistency)\n- Advisor of Ethics (Synergistic Fusion Protocol)\n- Advisor of Quality (Resonance & Clarity)",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self",
              "axiomatic_kb"
            ],
            "line_number": 511
          },
          {
            "name": "perform_vetting",
            "docstring": "Perform comprehensive vetting of a proposed action\n\nThis is the main entry point for validation - called by:\n- Workflow Engine (before each step)\n- Autopoietic Learning Loop (before wisdom crystallization)\n- Genesis Protocol (before code commit)\n- RISE Orchestrator (Phase C/D high-stakes vetting)",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context",
              "previous_result"
            ],
            "line_number": 520
          },
          {
            "name": "_check_logical_consistency",
            "docstring": "Check logical consistency and required inputs",
            "args": [
              "self",
              "proposed_action",
              "action_inputs",
              "context",
              "previous_result"
            ],
            "line_number": 620
          },
          {
            "name": "_create_rejection_result",
            "docstring": "Create a rejection vetting result",
            "args": [
              "self",
              "sfp_result",
              "reason"
            ],
            "line_number": 658
          },
          {
            "name": "_generate_modifications",
            "docstring": "Generate proposed modifications if needed",
            "args": [
              "self",
              "status",
              "sfp_result"
            ],
            "line_number": 677
          },
          {
            "name": "get_vetting_history",
            "docstring": "Retrieve recent vetting history",
            "args": [
              "self",
              "limit"
            ],
            "line_number": 699
          }
        ],
        "line_number": 500
      }
    ],
    "functions": [
      {
        "name": "create_vetting_agent",
        "docstring": "Factory function to create a VettingAgent",
        "args": [],
        "line_number": 707
      },
      {
        "name": "quick_vet",
        "docstring": "Quick vetting for simple cases",
        "args": [
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 711
      },
      {
        "name": "__post_init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 82
      },
      {
        "name": "to_dict",
        "docstring": "Convert to dictionary for JSON serialization",
        "args": [
          "self"
        ],
        "line_number": 86
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 102
      },
      {
        "name": "get_axiom",
        "docstring": "Retrieve a specific axiom",
        "args": [
          "self",
          "axiom_key"
        ],
        "line_number": 146
      },
      {
        "name": "get_all_axioms",
        "docstring": "Retrieve all axioms",
        "args": [
          "self"
        ],
        "line_number": 150
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self",
          "axiomatic_kb"
        ],
        "line_number": 164
      },
      {
        "name": "assess_scope_and_alignment",
        "docstring": "Perform comprehensive scope limitation and ethical alignment assessment\n\nThis is the core of the Synergistic Fusion Protocol - determining if\na problem requires axiomatic guidance and assessing ethical alignment.",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 168
      },
      {
        "name": "_assess_scope_limitation",
        "docstring": "Determine if the action requires axiomatic guidance\n(i.e., involves elements beyond current scientific understanding)",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 249
      },
      {
        "name": "_assess_ethical_alignment",
        "docstring": "Assess alignment with axiomatic knowledge base",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 285
      },
      {
        "name": "_check_mandate_compliance",
        "docstring": "Check compliance with the 12 Critical Mandates",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 327
      },
      {
        "name": "_assess_risks",
        "docstring": "Perform risk assessment",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 363
      },
      {
        "name": "_calculate_cognitive_resonance",
        "docstring": "Calculate overall cognitive resonance score",
        "args": [
          "self",
          "scope_assessment",
          "ethical_assessment",
          "mandate_compliance",
          "risk_assessment"
        ],
        "line_number": 404
      },
      {
        "name": "_assess_temporal_resonance",
        "docstring": "Assess temporal coherence and 4D thinking",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 437
      },
      {
        "name": "_assess_implementation_resonance",
        "docstring": "Assess As Above, So Below alignment",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context"
        ],
        "line_number": 451
      },
      {
        "name": "_generate_reasoning",
        "docstring": "Generate human-readable reasoning",
        "args": [
          "self",
          "is_aligned",
          "scope_assessment",
          "ethical_assessment",
          "mandate_compliance",
          "risk_assessment"
        ],
        "line_number": 465
      },
      {
        "name": "_compile_issues",
        "docstring": "Compile all identified issues",
        "args": [
          "self",
          "scope_assessment",
          "ethical_assessment",
          "risk_assessment"
        ],
        "line_number": 484
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self",
          "axiomatic_kb"
        ],
        "line_number": 511
      },
      {
        "name": "perform_vetting",
        "docstring": "Perform comprehensive vetting of a proposed action\n\nThis is the main entry point for validation - called by:\n- Workflow Engine (before each step)\n- Autopoietic Learning Loop (before wisdom crystallization)\n- Genesis Protocol (before code commit)\n- RISE Orchestrator (Phase C/D high-stakes vetting)",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context",
          "previous_result"
        ],
        "line_number": 520
      },
      {
        "name": "_check_logical_consistency",
        "docstring": "Check logical consistency and required inputs",
        "args": [
          "self",
          "proposed_action",
          "action_inputs",
          "context",
          "previous_result"
        ],
        "line_number": 620
      },
      {
        "name": "_create_rejection_result",
        "docstring": "Create a rejection vetting result",
        "args": [
          "self",
          "sfp_result",
          "reason"
        ],
        "line_number": 658
      },
      {
        "name": "_generate_modifications",
        "docstring": "Generate proposed modifications if needed",
        "args": [
          "self",
          "status",
          "sfp_result"
        ],
        "line_number": 677
      },
      {
        "name": "get_vetting_history",
        "docstring": "Retrieve recent vetting history",
        "args": [
          "self",
          "limit"
        ],
        "line_number": 699
      }
    ],
    "imports": [
      "json",
      "logging",
      "datetime",
      "typing",
      "enum",
      "dataclasses",
      "temporal_core",
      "iar_components",
      "action_context",
      "action_context"
    ],
    "docstring": "VettingAgent - The Guardian of ArchE\nCanonical Implementation (ResonantiA Protocol v3.5-GP)\n\nThis is THE vetting agent - the quality assurance system that validates all outputs\nand ensures alignment with the 12 Critical Mandates and Synergistic Fusion Protocol.\n\nPurpose:\n- Validate logical consistency and protocol adherence\n- Perform ethical assessment via Synergistic Fusion Protocol\n- Assess implementation resonance and temporal coherence\n- Generate comprehensive IAR reflections\n- Trigger Metacognitive Shift when dissonance detected\n\nIntegration Points:\n- Workflow Engine (validates each step)\n- Autopoietic Learning Loop (validates wisdom before crystallization)\n- Genesis Protocol (validates generated code)\n- RISE Orchestrator (Phase C/D high-stakes vetting)",
    "has_docstring": true,
    "line_count": 791
  },
  {
    "path": "Three_PointO_ArchE/workflow_engine.py",
    "name": "workflow_engine.py",
    "size_bytes": 89561,
    "classes": [
      {
        "name": "IARValidator",
        "docstring": "Validates IAR structure compliance per crystallized artifacts specification",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 78
          },
          {
            "name": "validate_structure",
            "docstring": "Validate IAR structure meets all requirements",
            "args": [
              "self",
              "iar_data"
            ],
            "line_number": 88
          },
          {
            "name": "validate_enhanced_fields",
            "docstring": "Validate enhanced IAR fields for tactical resonance",
            "args": [
              "self",
              "iar_data"
            ],
            "line_number": 118
          }
        ],
        "line_number": 75
      },
      {
        "name": "ResonanceTracker",
        "docstring": "Tracks tactical resonance and crystallization metrics",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self"
            ],
            "line_number": 137
          },
          {
            "name": "record_execution",
            "docstring": "Record task execution for resonance tracking",
            "args": [
              "self",
              "task_id",
              "iar_data",
              "context"
            ],
            "line_number": 145
          },
          {
            "name": "_update_metrics",
            "docstring": "Update aggregate resonance metrics",
            "args": [
              "self"
            ],
            "line_number": 161
          },
          {
            "name": "get_resonance_report",
            "docstring": "Get current resonance metrics report",
            "args": [
              "self"
            ],
            "line_number": 182
          },
          {
            "name": "_calculate_trend",
            "docstring": "Calculate resonance trend over recent executions",
            "args": [
              "self"
            ],
            "line_number": 190
          },
          {
            "name": "_calculate_compliance_score",
            "docstring": "Calculate overall IAR compliance score",
            "args": [
              "self"
            ],
            "line_number": 210
          }
        ],
        "line_number": 134
      },
      {
        "name": "IARCompliantWorkflowEngine",
        "docstring": "Enhanced workflow engine with IAR compliance and recovery support.",
        "methods": [
          {
            "name": "__init__",
            "docstring": null,
            "args": [
              "self",
              "workflows_dir",
              "spr_manager",
              "event_callback"
            ],
            "line_number": 328
          },
          {
            "name": "register_action",
            "docstring": "Register an action function with the engine.",
            "args": [
              "self",
              "action_type",
              "action_func"
            ],
            "line_number": 352
          },
          {
            "name": "register_recovery_actions",
            "docstring": "Register recovery-related actions.",
            "args": [
              "self"
            ],
            "line_number": 361
          },
          {
            "name": "_execute_for_each_task_wrapper",
            "docstring": "Wrapper for for_each action that can be called from action registry.\nCreates a minimal ActionContext for the actual implementation.",
            "args": [
              "self",
              "inputs"
            ],
            "line_number": 372
          },
          {
            "name": "_execute_for_each_task",
            "docstring": "Executes a sub-workflow for each item in a list.\nThis is a meta-action handled directly by the engine.",
            "args": [
              "self",
              "inputs",
              "context_for_action"
            ],
            "line_number": 386
          },
          {
            "name": "_execute_task",
            "docstring": "Execute a single task with proper action type handling.",
            "args": [
              "self",
              "task",
              "results",
              "initial_context"
            ],
            "line_number": 424
          },
          {
            "name": "_resolve_template_variables",
            "docstring": "Resolve template variables in task inputs.",
            "args": [
              "self",
              "inputs",
              "results",
              "initial_context"
            ],
            "line_number": 460
          },
          {
            "name": "get_resonance_dashboard",
            "docstring": "Get the current resonance dashboard.",
            "args": [
              "self"
            ],
            "line_number": 517
          },
          {
            "name": "load_workflow",
            "docstring": "Load workflow definition from file.",
            "args": [
              "self",
              "workflow_name"
            ],
            "line_number": 526
          },
          {
            "name": "_extract_var_path",
            "docstring": "Extracts the core variable path from a template string, ignoring filters.",
            "args": [
              "self",
              "template_content"
            ],
            "line_number": 593
          },
          {
            "name": "_parse_filters",
            "docstring": "Parses filter syntax (e.g., | filter(arg1, 'arg2')) from a template string.",
            "args": [
              "self",
              "template_content"
            ],
            "line_number": 598
          },
          {
            "name": "_get_value_from_path",
            "docstring": "Gets a value from a nested dictionary using a dot-separated path.",
            "args": [
              "self",
              "path",
              "context"
            ],
            "line_number": 621
          },
          {
            "name": "_resolve_value",
            "docstring": "Resolves a value that might be a template string, a direct value, or a nested structure.\nHandles template syntax {{ placeholder | filter1 | filter2(arg) | default(\"fallback\") }}.\nRecursively resolves values if the input value is a dictionary or a list.\nUses initial_context for 'context.' prefixed paths, runtime_context otherwise.",
            "args": [
              "self",
              "value",
              "runtime_context",
              "initial_context",
              "task_key"
            ],
            "line_number": 632
          },
          {
            "name": "_resolve_inputs",
            "docstring": "Resolves all template strings within a task's input dictionary.",
            "args": [
              "self",
              "inputs",
              "runtime_context",
              "initial_context",
              "task_key"
            ],
            "line_number": 897
          },
          {
            "name": "_evaluate_condition",
            "docstring": "Evaluates a condition string (e.g., \"{{ task_output.status }} == \"Success\"\").\nSupports basic comparisons (==, !=, >, <, >=, <=), truthiness checks,\nand membership checks (in, not in) on resolved context variables,\nincluding accessing IAR reflection data (e.g., {{task_A.reflection.confidence}}).\nReturns True if condition is met or if condition_str is empty/None.",
            "args": [
              "self",
              "condition_str",
              "runtime_context",
              "initial_context"
            ],
            "line_number": 916
          },
          {
            "name": "_parse_condition_value",
            "docstring": "Parses the literal value part of a condition string into Python types.",
            "args": [
              "self",
              "value_str"
            ],
            "line_number": 1019
          },
          {
            "name": "_compare_values",
            "docstring": "Performs comparison between actual and expected values based on operator.",
            "args": [
              "self",
              "actual",
              "operator",
              "expected"
            ],
            "line_number": 1039
          },
          {
            "name": "_sanitize_for_json",
            "docstring": "Recursively sanitizes data to ensure it's JSON serializable.",
            "args": [
              "self",
              "data"
            ],
            "line_number": 1103
          },
          {
            "name": "_emit_event",
            "docstring": "Helper to safely call the event_callback if it exists.",
            "args": [
              "self",
              "event_type",
              "payload"
            ],
            "line_number": 1117
          },
          {
            "name": "_emit_rich_vcd_event",
            "docstring": "Emit rich VCD events with enhanced metadata and interactive elements.",
            "args": [
              "self",
              "event_type",
              "title",
              "description",
              "metadata",
              "links",
              "code_blocks",
              "simulations",
              "visualizations"
            ],
            "line_number": 1132
          },
          {
            "name": "run_workflow",
            "docstring": "Main entry point to run a workflow.\nInitializes context, manages the task queue, and returns the final results.\nNow includes detailed event logging for each action.",
            "args": [
              "self",
              "workflow_name",
              "initial_context",
              "timeout",
              "model"
            ],
            "line_number": 1165
          },
          {
            "name": "_summarize_run",
            "docstring": "Helper to create the final results dictionary.",
            "args": [
              "self",
              "workflow_name",
              "run_id",
              "status",
              "duration",
              "task_statuses",
              "runtime_context",
              "error"
            ],
            "line_number": 1517
          },
          {
            "name": "_display_task_result",
            "docstring": "Display task execution result in a formatted way.",
            "args": [
              "self",
              "task_name",
              "result"
            ],
            "line_number": 1542
          },
          {
            "name": "_display_workflow_progress",
            "docstring": "Display workflow execution progress.",
            "args": [
              "self",
              "task_name",
              "status"
            ],
            "line_number": 1569
          },
          {
            "name": "execute_workflow",
            "docstring": "Execute a workflow with enhanced terminal output.",
            "args": [
              "self",
              "workflow"
            ],
            "line_number": 1573
          },
          {
            "name": "_save_workflow_result",
            "docstring": "Save workflow result to a file with timestamp.",
            "args": [
              "self",
              "result"
            ],
            "line_number": 1644
          },
          {
            "name": "_auto_organize_log",
            "docstring": "Auto-organize a single log file using the log organizer.",
            "args": [
              "self",
              "log_file_path"
            ],
            "line_number": 1661
          },
          {
            "name": "_ensure_iar_compliance",
            "docstring": "Acts as middleware to guarantee every action result has a compliant IAR.\nIf the reflection is missing or invalid, it generates a default one.",
            "args": [
              "self",
              "result",
              "context"
            ],
            "line_number": 1743
          },
          {
            "name": "_validate_and_heal_output",
            "docstring": "Validates the task result against its defined output_schema.\nIf validation fails, triggers a self-healing action to correct the format.",
            "args": [
              "self",
              "result",
              "task_info",
              "context"
            ],
            "line_number": 1783
          },
          {
            "name": "_execute_resonant_corrective_loop",
            "docstring": "Executes a corrective workflow in response to a trigger like a skipped task or low-confidence result.\nRCL web search disabled - requires explicit LLM prompting for web searches.",
            "args": [
              "self",
              "trigger_task",
              "reason",
              "runtime_context",
              "task_result"
            ],
            "line_number": 1837
          },
          {
            "name": "_validate_and_heal_output",
            "docstring": "Validates the task result against its defined output_schema.\nIf validation fails, triggers a self-healing action to correct the format.",
            "args": [
              "self",
              "result",
              "task_info",
              "context"
            ],
            "line_number": 1863
          }
        ],
        "line_number": 325
      },
      {
        "name": "SPRManager",
        "docstring": null,
        "methods": [],
        "line_number": 49
      }
    ],
    "functions": [
      {
        "name": "_execute_standalone_workflow",
        "docstring": "Executes a workflow definition in-memory, for use by meta-actions like for_each.\nThis is a simplified version of the main run_workflow loop, moved outside the class\nto prevent circular dependencies.",
        "args": [
          "workflow_definition",
          "initial_context",
          "parent_run_id",
          "action_registry"
        ],
        "line_number": 250
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 78
      },
      {
        "name": "validate_structure",
        "docstring": "Validate IAR structure meets all requirements",
        "args": [
          "self",
          "iar_data"
        ],
        "line_number": 88
      },
      {
        "name": "validate_enhanced_fields",
        "docstring": "Validate enhanced IAR fields for tactical resonance",
        "args": [
          "self",
          "iar_data"
        ],
        "line_number": 118
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self"
        ],
        "line_number": 137
      },
      {
        "name": "record_execution",
        "docstring": "Record task execution for resonance tracking",
        "args": [
          "self",
          "task_id",
          "iar_data",
          "context"
        ],
        "line_number": 145
      },
      {
        "name": "_update_metrics",
        "docstring": "Update aggregate resonance metrics",
        "args": [
          "self"
        ],
        "line_number": 161
      },
      {
        "name": "get_resonance_report",
        "docstring": "Get current resonance metrics report",
        "args": [
          "self"
        ],
        "line_number": 182
      },
      {
        "name": "_calculate_trend",
        "docstring": "Calculate resonance trend over recent executions",
        "args": [
          "self"
        ],
        "line_number": 190
      },
      {
        "name": "_calculate_compliance_score",
        "docstring": "Calculate overall IAR compliance score",
        "args": [
          "self"
        ],
        "line_number": 210
      },
      {
        "name": "__init__",
        "docstring": null,
        "args": [
          "self",
          "workflows_dir",
          "spr_manager",
          "event_callback"
        ],
        "line_number": 328
      },
      {
        "name": "register_action",
        "docstring": "Register an action function with the engine.",
        "args": [
          "self",
          "action_type",
          "action_func"
        ],
        "line_number": 352
      },
      {
        "name": "register_recovery_actions",
        "docstring": "Register recovery-related actions.",
        "args": [
          "self"
        ],
        "line_number": 361
      },
      {
        "name": "_execute_for_each_task_wrapper",
        "docstring": "Wrapper for for_each action that can be called from action registry.\nCreates a minimal ActionContext for the actual implementation.",
        "args": [
          "self",
          "inputs"
        ],
        "line_number": 372
      },
      {
        "name": "_execute_for_each_task",
        "docstring": "Executes a sub-workflow for each item in a list.\nThis is a meta-action handled directly by the engine.",
        "args": [
          "self",
          "inputs",
          "context_for_action"
        ],
        "line_number": 386
      },
      {
        "name": "_execute_task",
        "docstring": "Execute a single task with proper action type handling.",
        "args": [
          "self",
          "task",
          "results",
          "initial_context"
        ],
        "line_number": 424
      },
      {
        "name": "_resolve_template_variables",
        "docstring": "Resolve template variables in task inputs.",
        "args": [
          "self",
          "inputs",
          "results",
          "initial_context"
        ],
        "line_number": 460
      },
      {
        "name": "get_resonance_dashboard",
        "docstring": "Get the current resonance dashboard.",
        "args": [
          "self"
        ],
        "line_number": 517
      },
      {
        "name": "load_workflow",
        "docstring": "Load workflow definition from file.",
        "args": [
          "self",
          "workflow_name"
        ],
        "line_number": 526
      },
      {
        "name": "_extract_var_path",
        "docstring": "Extracts the core variable path from a template string, ignoring filters.",
        "args": [
          "self",
          "template_content"
        ],
        "line_number": 593
      },
      {
        "name": "_parse_filters",
        "docstring": "Parses filter syntax (e.g., | filter(arg1, 'arg2')) from a template string.",
        "args": [
          "self",
          "template_content"
        ],
        "line_number": 598
      },
      {
        "name": "_get_value_from_path",
        "docstring": "Gets a value from a nested dictionary using a dot-separated path.",
        "args": [
          "self",
          "path",
          "context"
        ],
        "line_number": 621
      },
      {
        "name": "_resolve_value",
        "docstring": "Resolves a value that might be a template string, a direct value, or a nested structure.\nHandles template syntax {{ placeholder | filter1 | filter2(arg) | default(\"fallback\") }}.\nRecursively resolves values if the input value is a dictionary or a list.\nUses initial_context for 'context.' prefixed paths, runtime_context otherwise.",
        "args": [
          "self",
          "value",
          "runtime_context",
          "initial_context",
          "task_key"
        ],
        "line_number": 632
      },
      {
        "name": "_resolve_inputs",
        "docstring": "Resolves all template strings within a task's input dictionary.",
        "args": [
          "self",
          "inputs",
          "runtime_context",
          "initial_context",
          "task_key"
        ],
        "line_number": 897
      },
      {
        "name": "_evaluate_condition",
        "docstring": "Evaluates a condition string (e.g., \"{{ task_output.status }} == \"Success\"\").\nSupports basic comparisons (==, !=, >, <, >=, <=), truthiness checks,\nand membership checks (in, not in) on resolved context variables,\nincluding accessing IAR reflection data (e.g., {{task_A.reflection.confidence}}).\nReturns True if condition is met or if condition_str is empty/None.",
        "args": [
          "self",
          "condition_str",
          "runtime_context",
          "initial_context"
        ],
        "line_number": 916
      },
      {
        "name": "_parse_condition_value",
        "docstring": "Parses the literal value part of a condition string into Python types.",
        "args": [
          "self",
          "value_str"
        ],
        "line_number": 1019
      },
      {
        "name": "_compare_values",
        "docstring": "Performs comparison between actual and expected values based on operator.",
        "args": [
          "self",
          "actual",
          "operator",
          "expected"
        ],
        "line_number": 1039
      },
      {
        "name": "_sanitize_for_json",
        "docstring": "Recursively sanitizes data to ensure it's JSON serializable.",
        "args": [
          "self",
          "data"
        ],
        "line_number": 1103
      },
      {
        "name": "_emit_event",
        "docstring": "Helper to safely call the event_callback if it exists.",
        "args": [
          "self",
          "event_type",
          "payload"
        ],
        "line_number": 1117
      },
      {
        "name": "_emit_rich_vcd_event",
        "docstring": "Emit rich VCD events with enhanced metadata and interactive elements.",
        "args": [
          "self",
          "event_type",
          "title",
          "description",
          "metadata",
          "links",
          "code_blocks",
          "simulations",
          "visualizations"
        ],
        "line_number": 1132
      },
      {
        "name": "run_workflow",
        "docstring": "Main entry point to run a workflow.\nInitializes context, manages the task queue, and returns the final results.\nNow includes detailed event logging for each action.",
        "args": [
          "self",
          "workflow_name",
          "initial_context",
          "timeout",
          "model"
        ],
        "line_number": 1165
      },
      {
        "name": "_summarize_run",
        "docstring": "Helper to create the final results dictionary.",
        "args": [
          "self",
          "workflow_name",
          "run_id",
          "status",
          "duration",
          "task_statuses",
          "runtime_context",
          "error"
        ],
        "line_number": 1517
      },
      {
        "name": "_display_task_result",
        "docstring": "Display task execution result in a formatted way.",
        "args": [
          "self",
          "task_name",
          "result"
        ],
        "line_number": 1542
      },
      {
        "name": "_display_workflow_progress",
        "docstring": "Display workflow execution progress.",
        "args": [
          "self",
          "task_name",
          "status"
        ],
        "line_number": 1569
      },
      {
        "name": "execute_workflow",
        "docstring": "Execute a workflow with enhanced terminal output.",
        "args": [
          "self",
          "workflow"
        ],
        "line_number": 1573
      },
      {
        "name": "_save_workflow_result",
        "docstring": "Save workflow result to a file with timestamp.",
        "args": [
          "self",
          "result"
        ],
        "line_number": 1644
      },
      {
        "name": "_auto_organize_log",
        "docstring": "Auto-organize a single log file using the log organizer.",
        "args": [
          "self",
          "log_file_path"
        ],
        "line_number": 1661
      },
      {
        "name": "_ensure_iar_compliance",
        "docstring": "Acts as middleware to guarantee every action result has a compliant IAR.\nIf the reflection is missing or invalid, it generates a default one.",
        "args": [
          "self",
          "result",
          "context"
        ],
        "line_number": 1743
      },
      {
        "name": "_validate_and_heal_output",
        "docstring": "Validates the task result against its defined output_schema.\nIf validation fails, triggers a self-healing action to correct the format.",
        "args": [
          "self",
          "result",
          "task_info",
          "context"
        ],
        "line_number": 1783
      },
      {
        "name": "_execute_resonant_corrective_loop",
        "docstring": "Executes a corrective workflow in response to a trigger like a skipped task or low-confidence result.\nRCL web search disabled - requires explicit LLM prompting for web searches.",
        "args": [
          "self",
          "trigger_task",
          "reason",
          "runtime_context",
          "task_result"
        ],
        "line_number": 1837
      },
      {
        "name": "_validate_and_heal_output",
        "docstring": "Validates the task result against its defined output_schema.\nIf validation fails, triggers a self-healing action to correct the format.",
        "args": [
          "self",
          "result",
          "task_info",
          "context"
        ],
        "line_number": 1863
      },
      {
        "name": "execute_action",
        "docstring": null,
        "args": [],
        "line_number": 47
      },
      {
        "name": "load_session_state",
        "docstring": null,
        "args": [],
        "line_number": 238
      },
      {
        "name": "save_session_state",
        "docstring": null,
        "args": [
          "state"
        ],
        "line_number": 240
      },
      {
        "name": "append_fact",
        "docstring": null,
        "args": [
          "state",
          "fact"
        ],
        "line_number": 242
      },
      {
        "name": "create_context_bundle",
        "docstring": null,
        "args": [
          "spr_def",
          "runtime_context",
          "initial_context"
        ],
        "line_number": 244
      },
      {
        "name": "merge_bundles",
        "docstring": null,
        "args": [
          "bundles"
        ],
        "line_number": 246
      }
    ],
    "imports": [
      "json",
      "os",
      "logging",
      "copy",
      "time",
      "re",
      "uuid",
      "tempfile",
      "datetime",
      "typing",
      "ast",
      "datetime",
      "Three_PointO_ArchE.temporal_core",
      "action_registry",
      "spr_manager",
      "error_handler",
      "action_context",
      "workflow_recovery",
      "recovery_actions",
      "system_genesis_tool",
      "qa_tools",
      "output_handler",
      "custom_json",
      "workflow_optimizer",
      "numpy",
      "session_state_manager",
      "context_superposition",
      "prefetch_manager",
      "sirc_autonomy",
      "causal_digest",
      "logging",
      "log_organizer",
      "shutil"
    ],
    "docstring": null,
    "has_docstring": false,
    "line_count": 1917
  }
]